## 11.4 코드 오염 (Code Pollution)

* **정의**: 테스트만을 위해 `제품 코드에 불필요한 요소`(예: 테스트 전용 분기 스위치·플래그)를 추가하는 안티 패턴. 제품 코드와 테스트 코드가 섞여 유지비가 커진다 \[p.381] &#x20;
* **전형적 사례**: 로거(Logger)에 `isTestEnvironment` 같은 불리언 스위치를 두고 테스트 시 로깅을 끄는 방식\[예제 11.8/11.9, p.381]  &#x20;
* **해법**: 테스트 코드를 제품 코드베이스와 **분리**하고, **인터페이스**(예: `ILogger`) 뒤에 실제 구현과 테스트용 가짜 구현을 둔다. 컨트롤러는 구체 클래스가 아니라 인터페이스를 의존한다\[예제 11.10, p.382] &#x20;
* **추가 관찰**: 인터페이스 자체는 코드가 없어 잠재 버그 노출을 늘리지 않으며, 스위치식 분기보다 위험이 낮다 \[p.382]&#x20;

### 내 생각 (짧게)

* 운영/테스트 분기를 **제품 코드에** 박아 넣는 순간, “테스트 편의”가 “운영 복잡도”로 돌아온다. 포트/어댑터(헥사고날)처럼 **역할과 구현을 분리**하면 문제의 80%는 사라진다.
* 사실 테스트 코드가 비즈니스에 있다는것 자체가 넌센스임. 이걸 책에서 설명할 정도면 저자도 만만치 않은 환경에서 일했던 것은 분명한 듯 아니면 분량 채우기 인가?

---

## 11.5 구체 클래스를 목으로 처리하기

* **아이디어**: 인터페이스 대신 **구체 클래스**(예: `StatisticsCalculator`)를 목으로 만들어 일부 기능은 보존하고 외부 통신만 대체하려는 시도 \[p.383-384] &#x20;
* **문제점**: 단일 책임 원칙(SRP) 위반. 외부 서비스 호출 책임(입력 수집)과 **도메인 계산 책임**이 한 클래스에 결합되어 있기 때문 \[p.385-386]&#x20;
* **권장 리팩터링**:

  1. **입력 수집**을 `DeliveryGateway`(인터페이스)로 분리,
  2. **순수 계산**은 `StatisticsCalculator`에 남긴다,
  3. 컨트롤러는 두 의존성을 주입받아 사용(험블 오브젝트 패턴 적용) \[예제 11.14/11.15, p.386]  &#x20;
* **테크노트**: 일부 테스트 프레임워크로는 구체 클래스를 “부분 목(Partial Mock)”으로 만들 수 있지만(예: 기저 동작 유지 `CallBase=true`), **권장되지 않는 안티 패턴**으로 명시된다 \[p.385]&#x20;

### 내 생각 (짧게)

* “구체 클래스 목질(ing)”이 필요해지는 순간이 **리팩터링 시그널**. **입력 수집**과 **순수 계산**을 가르는 것만으로 테스트 안정성과 설계 응집도가 동시에 오른다.

---

## 11.6 시간 처리하기

* **문제의 본질**: 현재 시간/날짜에 의존하는 기능은 실행 시각 차이로 **거짓 양성/음성**을 유발할 수 있다. 시간을 **안정화**해야 한다 \[p.387]&#x20;
* **안티 패턴**: \*\*앰비언트 컨텍스트(정적 전역)\*\*로 시간을 노출하는 전역 `DateTimeServer.Now` 같은 방식. 제품 코드 오염 + 테스트 간 전역 상태 공유 위험 \[예제 11.16, p.387-388] &#x20;
* **권장 방식**:

  * 시간을 **명시적 의존성**으로 **주입**(서비스 또는 값).
  * 시작 지점(컨트롤러/유스케이스)에서는 서비스로 받고, \*\*도메인에는 값(Instant/DateTime)\*\*으로 넘겨 순수성을 유지한다 \[p.388-389]&#x20;

### 내 생각 (짧게)

* 시간은 “숨은 전역” 중 최악이다. **`Clock`/`Instant` 주입 → 도메인에는 값 전달** 패턴을 팀 표준으로 굳히면, 날짜 경계 테스트가 놀라울 정도로 쉬워진다.
* 시간을 이용해서 테스트 코드를 짜다 보면 노하우가 생길것 같다. 실제로 시간과 관련된 설정과 그 설정을 조회하거나 적용받는 도메인이 있다면 어떻게 코드를 작성해야 될지 감이 잡힐듯 하다.

---

## (작성) 한눈에 보는 정리표

| 주제            | 안티 패턴                    | 이유                 | 권장 해법                   | 핵심 이득          |
| ------------- | ------------------------ | ------------------ | ----------------------- | -------------- |
| 11.4 코드 오염    | 테스트 플래그/스위치(예: `isTest`) | 제품 코드 오염, 유지비 상승   | 인터페이스 도입 + 테스트 전용 구현 분리 | 버그 노출 축소, 결합도↓ |
| 11.5 구체 클래스 목 | 부분 목으로 외부 호출만 대체         | SRP 위반, 리팩터링 어렵게 함 | 입력 수집 게이트웨이 vs 순수 계산 분리 | 순수 계산 테스트 용이   |
| 11.6 시간 처리    | 전역(정적) 시간 제공자            | 전역 상태 공유, 거짓 양성    | 시간 의존성 주입(서비스→값)        | 도메인 순수성, 재현성↑  |

---

# Kotlin 예제 (도메인 포함, as‑is → to‑be, Kotest)

> 환경 가정: Kotlin 1.9.x, JDK 21, Spring 없이도 동작하는 순수 Kotlin 예시.
> 도메인: 광고 정산/보고(딜ivery를 광고 보고로 치환), 캠페인 승인 시각 로직 등.

### 11.4 코드 오염

#### as‑is: 테스트 스위치로 로깅 끄기(안티 패턴)

```kotlin
// 제품 코드 (안티 패턴)
class EventLogger(private val isTest: Boolean) {
    fun log(message: String) {
        if (isTest) return // 테스트에서는 로깅 비활성화: 제품 코드 오염, 예전엔 이런 코드를 상당히 많이 봤다.
        // 실제 파일/원격 로그 전송...
    }
}

class ReportController {
    fun generateDailyReport(logger: EventLogger): String {
        logger.log("generateDailyReport called")
        return "OK"
    }
}
```

#### to‑be: 인터페이스 + 테스트용 NoOp 구현

```kotlin
// 제품 코드
fun interface AuditLogPort { fun log(message: String) }

class FileAuditLog(/* file path, appender 등 DI */) : AuditLogPort {
    override fun log(message: String) {
        // 파일 또는 외부 로그 시스템으로 기록
    }
}

// 테스트 코드(전용 구현)
// 이렇게 껍데기 코드를 짜는것과 mock을 쓰는것과 차이점이 있나.?
class NoOpAuditLog : AuditLogPort {
    override fun log(message: String) { /* 아무 것도 안함 */ }
}

class ReportController2(private val auditLog: AuditLogPort) {
    fun generateDailyReport(): String {
        auditLog.log("generateDailyReport called")
        return "OK"
    }
}
```

```kotlin
// Kotest
import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.shouldBe

class ReportController2Test : StringSpec({
    "로깅 구현에 구애받지 않고 보고 생성 가능" {
        val sut = ReportController2(auditLog = NoOpAuditLog())
        sut.generateDailyReport() shouldBe "OK"
    }
})
```

---

### 11.5 구체 클래스를 목으로 처리 vs 역할 분리

#### as‑is: 외부 호출 + 계산이 결합된 서비스(부분 목 필요)

```kotlin
data class PartnerSpend(val impressions: Long, val cost: Long)

open class RevenueStatsService {
    open fun fetchDailyReports(partnerId: Long): List<PartnerSpend> {
        // 외부 API 호출 (비관리 의존성)
        error("calls external system")
    }
    fun calculateTotals(partnerId: Long): Pair<Long, Long> {
        val reports = fetchDailyReports(partnerId)
        val totalImp = reports.sumOf { it.impressions }
        val totalCost = reports.sumOf { it.cost }
        return totalImp to totalCost
    }
}

// 테스트에서는 fetchDailyReports만 오버라이드하는 '부분 목'을 만들고 싶어짐(안티 패턴)
```

#### to‑be: 게이트웨이(입력 수집)와 계산을 분리(험블 오브젝트 적용)

```kotlin
// 입력 수집 포트
fun interface ReportGateway {
    fun fetchDailyReports(partnerId: Long): List<PartnerSpend>
}

// 순수 계산기
class RevenueCalculator {
    fun totals(reports: List<PartnerSpend>): Pair<Long, Long> =
        reports.sumOf { it.impressions } to reports.sumOf { it.cost }
}

// 애플리케이션 서비스/컨트롤러
class PartnerReportController(
    private val gateway: ReportGateway,
    private val calculator: RevenueCalculator,
) {
    fun summary(partnerId: Long): String {
        val data = gateway.fetchDailyReports(partnerId)
        val (imp, cost) = calculator.totals(data)
        return "impressions=$imp, cost=$cost"
    }
}
```

```kotlin
// Kotest: 가짜 게이트웨이로 외부 호출 없이 순수 계산 검증
class PartnerReportControllerTest : StringSpec({
    "게이트웨이/계산 분리로 테스트가 단순해진다" {
        val fakeGateway = ReportGateway {
            listOf(PartnerSpend(1000, 200), PartnerSpend(500, 100))
        }
        val sut = PartnerReportController(fakeGateway, RevenueCalculator())
        sut.summary(42) shouldBe "impressions=1500, cost=300"
    }
})
```

---

### 11.6 시간 처리(전역 X → 명시적 주입)

#### as‑is: 전역 앰비언트 컨텍스트(안티 패턴)

```kotlin
// 전역 객체에 현재 시각을 숨김: 테스트 간 공유 상태 유발 가능
object TimeProvider {
    var nowFn: () -> java.time.Instant = { java.time.Instant.now() }
}
class Campaign {
    fun isActive(): Boolean = TimeProvider.nowFn().isBefore(java.time.Instant.parse("2099-12-31T23:59:59Z"))
}
```

#### to‑be: 시작점에서 Clock 주입 → 도메인에는 값(Instant) 전달

```kotlin
import java.time.Clock
import java.time.Instant

class Campaign2(private val endAt: Instant) {
    fun isActive(now: Instant): Boolean = now.isBefore(endAt)
}

class CampaignService(private val clock: Clock) {
    fun checkActive(c: Campaign2): Boolean = c.isActive(Instant.now(clock)) // 서비스는 Clock 사용
}
```

```kotlin
// Kotest: 고정 시계(FixedClock)로 재현 가능한 테스트
import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.shouldBe
import java.time.*

class CampaignServiceTest : StringSpec({
    "고정 시계로 시간 의존 로직을 안정적으로 검증" {
        val fixed = Instant.parse("2025-01-01T00:00:00Z")
        val clock = Clock.fixed(fixed, ZoneOffset.UTC)
        val svc = CampaignService(clock)
        val campaign = Campaign2(endAt = Instant.parse("2025-12-31T23:59:59Z"))

        svc.checkActive(campaign) shouldBe true
    }
})
```

> 주석 요점: 테스트는 \*\*`Clock.fixed`\*\*로 “현재”를 통제하고, 도메인에는 **`Instant` 값**만 전달하여 순수성 및 재현성을 보장한다.

---

## 외부 참고 자료 (간략 요약 + 링크)

* **코드 오염(Code Pollution)**: 테스트 편의를 위해 제품 코드에 테스트 전용 코드를 섞는 행위를 정의하고, 분리 원칙을 제시. Khorikov 블로그 ([Enterprise Craftsmanship][1])
* **구체 클래스 목의 함정 & 대안**: “목은 스텁이 아니다”라는 관점으로 상호작용 기반 테스트의 장단점을 설명. Martin Fowler, *Mocks Aren’t Stubs* ([martinfowler.com][2])
* **험블 오브젝트 패턴**: 테스트 어려운 요소(UI/외부의존)에서 로직을 분리해 순수부를 테스트. Fowler 블로그 & 설명 자료 ([martinfowler.com][3], [steven-giesel.com][4], [Stack Overflow][5])
* **시간 다루기(Clock/Instant)**: 전역 시간 대신 **의존성 주입**(서비스→값) 규칙을 권장. Khorikov 글, Java `Clock` 사용 가이드(baeldung) ([Enterprise Craftsmanship][6], [Baeldung on Kotlin][7])
* **테스트에서 시간 고정하기**: Java에서 시스템 시간을 제어하는 실무 팁(고정/오프셋 클록) ([Baeldung on Kotlin][8], [Mincong Huang][9])

---

## 요약(압축)

* **11.4**: 테스트 전용 분기(스위치/플래그)는 **코드 오염**. 인터페이스 도입으로 운영/테스트 구현을 **분리**해 유지보수성을 높여라 \[p.381‑382] .
* **11.5**: 구체 클래스를 부분 목으로 쓰고 싶다면 **SRP 위반 신호**. **게이트웨이(입력 수집)** 와 **순수 계산**을 나눠 험블 오브젝트 패턴을 적용하라 \[p.385‑386]  .
* **11.6**: 시간은 전역으로 두지 말고 **명시적 의존성**으로 주입. 시작점(서비스)은 `Clock`, 도메인은 `Instant` 같은 **값**으로 받아 순수성과 재현성을 확보하라 \[p.387‑389]  .

---


[1]: https://enterprisecraftsmanship.com/posts/code-pollution/?utm_source=chatgpt.com "Code pollution"
[2]: https://martinfowler.com/articles/mocksArentStubs.html?utm_source=chatgpt.com "Mocks Aren't Stubs"
[3]: https://martinfowler.com/bliki/HumbleObject.html?utm_source=chatgpt.com "Humble Object"
[4]: https://steven-giesel.com/blogPost/47acad0a-255c-489b-a805-d0f46bde23e5?utm_source=chatgpt.com "The Humble Object Pattern"
[5]: https://stackoverflow.com/questions/5324049/what-is-the-humble-object-pattern-and-when-is-it-useful?utm_source=chatgpt.com "What is the Humble Object pattern and when is it useful?"
[6]: https://enterprisecraftsmanship.com/posts/domain-model-purity-current-time/?utm_source=chatgpt.com "Domain model purity and the current time"
[7]: https://www.baeldung.com/java-clock?utm_source=chatgpt.com "Guide to the Java Clock Class"
[8]: https://www.baeldung.com/java-override-system-time?utm_source=chatgpt.com "Overriding System Time for Testing in Java"
[9]: https://mincong.io/2020/05/24/java-clock/?utm_source=chatgpt.com "Controlling Time with Java Clock"
