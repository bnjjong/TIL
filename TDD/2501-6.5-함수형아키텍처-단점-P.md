## 6.5 함수형 아키텍처의 단점 이해하기 상세정리


#### 6.5 함수형 아키텍처의 단점 이해하기 (p.220~225)

함수형 아키텍처는 유지보수성과 테스트 용이성이 탁월하지만, 현실에서 모든 시스템에 적용할 수 없거나 적용할 때 여러 단점/비용이 발생함.  
이 하위 챕터에서는 함수형 아키텍처의 적용 한계, 성능 저하, 코드베이스 크기 증가 등의 단점을 구체적으로 살핀다.

### 6.5.1 함수형 아키텍처 적용 가능성 (p.220~221)
- **함수형 아키텍처**는 "모든 입력을 미리 수집할 수 있을 때" 훌륭히 동작
  - 감사 시스템 등에는 적합
- 하지만 **실행 흐름이 단순하지 않은 경우**,
  - 예컨대 처리 중간에 외부 데이터(프로세스 외부 의존성, DB 등)를 질의해야 하거나,
  - 중간 결과에 따라 외부 호출이 달라지는 경우,
  - 함수형 아키텍처 적용이 쉽지 않음

**예시:**
- 방문자 접근 레벨을 DB에서 읽어와야 할 때,  
  `AddRecord()` 등 도메인 로직이 DB 클래스를 받게 되면 숨은 입출력이 생기면서 더 이상 "순수 함수"가 아님
- 이는 출력 기반 테스트가 어렵게 된다.

#### 대응방안 (p.221)
1. **모든 데이터를 사전 조회해서 함수형 코어에 넘김**
    - ex) AddRecord에 필요/불필요 상관없이 항상 접근 레벨을 전달
    - 장점: 완전한 분리 유지
    - 단점: (불필요한 경우에도) 외부 시스템 질의 → 성능 저하
2. **"접근 레벨 필요 여부"를 미리 코어에서 판단 → 필요할 때만 서비스 계층이 조회**
    - 더 나은 성능, 하지만 의사결정이 서비스 계층으로 이동 (분리 약화)

**결론:**  
`도메인 모델이 외부 시스템에 직접 의존`하도록 하는 것은 지양해야 하며,  
"철저한 **분리**" or "실용적 **성능** 트레이드오프" 중 상황에 따라 택함

### 6.5.2 성능 단점 (p.222)
- 함수형 아키텍처는 외부 시스템 호출을 "가변 셸"이 모두 담당하도록 함 →  
  코어가 실제로 모든 데이터를 받아들여야 하므로, 주기적으로 전체 데이터 파일/DB 스캔 필요
- 이와 달리 전통적 아키텍처(혹은 일부 트레이드오프 버전)은 필요할 때만 외부 질의를 수행 가능
- **즉, 성능과 유지보수성 간의 균형 필요**
  - 일부 시스템(성능 민감하지 않음): 함수형 아키텍처로 유지보수 최적화
  - 성능 중시 시스템: 일부는 전통적 방식 혼용 필요
- 보편 해결책은 없으며, 프로젝트마다 결정해야 함

### 6.5.3 코드베이스 크기 증가 (p.223)
- 함수형 코어/가변 셸 명확 분리 → **초기 구현 비용 및 코드량 증가**
- 코드 복잡도 높지 않거나, 비즈니스 중요성이 적은 시스템은 초기투자 대비 효과 적음
- 모든 도메인 모델을 완전히 "불변"으로 만들기는 어렵고(특히 C#/Java 등 객체지향 언어)
  - 실제로는 출력기반/상태기반/통신기반 테스트를 섞어쓰게 됨
- 순수함수/함수형 아키텍처에 집착하지 말고 "**가능한 만큼**" 적용

### 추가 정리 (p.224-225)

#### **단위 테스트 스타일 비교 - 표 직접 작성**

| 스타일        | 개념/특징    | 장점                          | 단점                         | 대표 사례              |
|---------------|------------|------------------------------|-----------------------------|-----------------------|
| 출력 기반     | 입력→출력만 확인 | 리팩터링 내성, 품질↑, 생산성↑   | 숨은 입/출력 있으면 부적합   | 함수형 코어 테스트         |
| 상태 기반     | 작업 후 상태 확인 | 적용범위 넓음                   | 상태 노출 필요, 유지보수 ↓   | Entity CRUD 검증 등    |
| 통신 기반     | 협력자와 통신 검증 | 외부 사이드이펙트 추적          | 목 남용시 유지보수 ↓, 복잡   | 외부 API/DB 호출 테스트 |

> 함수형 아키텍처는 출력 기반 테스트를 최대화하고, 사이드이펙트(외부 시스템 변경)를 별도 '가변 셸'로 분리함.

## 요약 (완전 압축 버전)

- 함수형 아키텍처는 "비즈니스 로직-사이드이펙트"를 분리해 유지보수성과 테스트 용이성을 높임
- 하지만,
  - 외부 데이터에 실시간으로 의존하거나,
  - 지나친 데이터 I/O로 성능이 떨어지거나,
  - 초기 구현 비용이 큰 경우,
  - 적용이 적절하지 않을 수 있음
- 모든 시스템에 100% 고집하기보단, 상황별로 일부 혼용/트레이드오프가 필요.
- 결론적으로, "출력 기반 테스트/함수형 프로그래밍"을 최대한 적용하되 실용적 한계를 잘 고려할 것.

## 예제 코드 (as-is / to-be, 비즈니스 도메인, Kotlin, kotest 포함)

### **도메인 예시: 출석(Attendance) 기록 관리**

아래 예시는 "출석 기록"을 관리하는 시스템에서  
**최근 24시간 내 출석 횟수** 초과시 **학생 등급**을 확인해 특수 처리를 해야 한다는 비즈니스 규칙이 있다는 가정입니다.

#### 1. **As-Is: 순수함수/분리 없는 버전**

```kotlin
// 도메인 로직이 직접 외부(Repository)에 의존하여, 순수함수가 아님

class AttendanceRepository {
    fun getAttendanceCount(studentId: String, since: Instant): Int { /* ... */ return 0 }
    fun getStudentGrade(studentId: String): String { /* ... */ return "A" }
}

class AttendanceManager(private val repository: AttendanceRepository) {
    fun addAttendance(studentId: String, time: Instant) {
        val count = repository.getAttendanceCount(studentId, time.minus(1, ChronoUnit.DAYS))
        if (count > 3) {
            val grade = repository.getStudentGrade(studentId)
            if (grade == "PREMIUM") {
                // 특수처리
            }
        }
        // 출석 저장
    }
}
```
> 코어 도메인이 DB/외부 시스템에 강결합 → 함수형 아키텍처 원칙X  
> 출력 기반 테스트 어려움, 테스트에서 목 남발 필요

#### 2. **To-Be: 함수형 코어/가변 셸 분리**

```kotlin
// 1) 비즈니스 의사결정은 모두 순수 함수
data class AttendanceDecision(
    val requiresSpecialHandling: Boolean
)

class AttendancePolicy(
    private val premiumThreshold: Int = 3
) {
    // 순수 함수: 외부 I/O 없음
    fun decide(
        attendanceCount: Int,
        studentGrade: String
    ): AttendanceDecision {
        return AttendanceDecision(
            requiresSpecialHandling = attendanceCount > premiumThreshold && studentGrade == "PREMIUM"
        )
    }
}

// 2) 셸: I/O를 수행해서 모든 필요한 입력을 Policy에 제공
class AttendanceService(
    private val repository: AttendanceRepository,
    private val policy: AttendancePolicy
) {
    fun addAttendance(studentId: String, time: Instant) {
        val count = repository.getAttendanceCount(studentId, time.minus(1, ChronoUnit.DAYS))
        val grade = repository.getStudentGrade(studentId)
        val decision = policy.decide(count, grade)
        if (decision.requiresSpecialHandling) {
            // 특수처리만, 실제 저장 등 I/O
        }
        // 출석 저장
    }
}
```

> 도메인 정책은 순수 함수로, I/O는 껍데기(서비스)에서 담당  
> 출력 기반 테스트/단순성↑  
> 단, 매 호출마다 불필요 데이터 로딩 가능 (성능 트레이드오프)

#### 3. **중간 트레이드오프: "특수처리 필요 여부" 먼저 판단, 조건부 I/O**

```kotlin
class AttendancePolicy(
    private val premiumThreshold: Int = 3
) {
    fun isSpecialHandlingNeeded(attendanceCount: Int): Boolean =
        attendanceCount > premiumThreshold

    fun decideWithGrade(attendanceCount: Int, studentGrade: String): AttendanceDecision {
        return AttendanceDecision(
            requiresSpecialHandling = attendanceCount > premiumThreshold && studentGrade == "PREMIUM"
        )
    }
}

class AttendanceService(
    private val repository: AttendanceRepository,
    private val policy: AttendancePolicy
) {
    fun addAttendance(studentId: String, time: Instant) {
        val count = repository.getAttendanceCount(studentId, time.minus(1, ChronoUnit.DAYS))
        if (policy.isSpecialHandlingNeeded(count)) {
            val grade = repository.getStudentGrade(studentId)
            val decision = policy.decideWithGrade(count, grade)
            // ...
        } else {
            // 일반 저장
        }
    }
}
```
> "특수처리 필요"할 때만 추가 I/O → 최적화  
> 대신, 일부 의사결정이 서비스 계층(껍데기)로 이동

### **테스트 코드 예시 (kotest)**

```kotlin
import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.shouldBe

class AttendancePolicyTest : StringSpec({
    "특수처리 조건일 때 true를 반환" {
        val policy = AttendancePolicy(premiumThreshold = 3)
        val result = policy.decide(4, "PREMIUM")
        result.requiresSpecialHandling shouldBe true
    }
    "특수처리 조건이 아니면 false를 반환" {
        val policy = AttendancePolicy(premiumThreshold = 3)
        val result = policy.decide(2, "PREMIUM")
        result.requiresSpecialHandling shouldBe false
    }
    "일반 등급은 특수처리 안 함" {
        val policy = AttendancePolicy(premiumThreshold = 3)
        val result = policy.decide(5, "NORMAL")
        result.requiresSpecialHandling shouldBe false
    }
})
```

> **설명:**  
> 이 테스트는 함수형 코어(AttendancePolicy)에만 집중, 외부 I/O 필요 없음 → 출력기반 테스트  
> 유지보수가 쉽고, 리팩터링에도 영향 없음

### **참고할 만한 도식(표): 함수형 아키텍처와 테스트 스타일 관계**

| 구분           | 함수형 코어           | 가변 셸                |
|----------------|----------------------|-----------------------|
| 역할           | 비즈니스 로직(불변,순수) | I/O 및 사이드이펙트 담당     |
| 테스트 스타일   | 출력 기반             | 통신/상태 기반          |
| 장점           | 품질, 리팩터링 내성      | 분리도↑, 버그 감소        |
| 주요 문제점     | 모든 로직 분리 어려움,   | 성능 부담, 코드 증가       |
|                | 외부 의존성 요구시 한계 |                       |

## 참고자료 요약 및 링크

(아래는 인터넷에서 함수형 아키텍처 단점/적용에 관한 주요 자료의 일부 요약입니다.)

- [마틴 파울러 - Functional Architecture](https://martinfowler.com/architecture/)
    - 함수형/불변/순수 함수의 이점과 한계
    - "IO, 외부 상태 없는 순수 로직 분리가 이상적이지만, 현실 비즈니스에서 모든 요구에 이상적으로 적용하기 어려움"
- [effective unit testing - output based, state based, interaction based 테스트 비교](https://www.baeldung.com/java-unit-test-outcomes)
    - 출력/상태/통신 기반 테스트 장단점 테이블 요약

# 결론 요약 (마지막 압축)

- 함수형 아키텍처는 테스트·유지보수성에서 큰 이점이 있으나, 모든 곳에 적용할 수 없고 성능·초기투자·외부 의존성 분리에서 현실적 한계가 있음.
- 가능한 한 "함수형 코어+가변 셸" 스타일로 짜되, 엄격함이 필요할 때만 고집하고 트레이드오프를 고려
- 외부 시스템·성능 문제에선 일부 전통 방식 혼용 가능
- 테스트 스타일(출력/상태/통신 기반)도 혼합적으로 똑똑하게 선택하자.