## 7.3 최적의 단위 테스트 커버리지 분석

* 험블 객체(=비즈니스 로직과 오케스트레이션 분리)로 리팩터링한 뒤, “무엇을 어디에서 어떻게 테스트할지”를 사분면으로 정리한다. 표 7.1이 대표 예다 \[p.248] .
* 핵심 메시지: **복잡도와 도메인 유의성이 높은 코드**를 **협력자(외부 의존)** 거의 없이 두면, 회귀 방지 효과가 크고 유지비가 낮다 \[p.248] .

### 표 7.1 코드 유형(사분면) – 직접 재작성

|                   | 협력자 적음                                                                          | 협력자 많음                                                                   |
| ----------------- | ------------------------------------------------------------------------------- | ------------------------------------------------------------------------ |
| **복잡도·도메인 유의성 ↑** | `User.ChangeEmail(newEmail, company)`, `Company.ChangeNumberOfEmployees(delta)` | (리팩터링으로 제거됨) `UserController.ChangeEmail(userId,newEmail)`은 오케스트레이션으로 이동 |
| **복잡도·도메인 유의성 ↓** | `IsEmailCorporate(email)`, `CompanyFactory.Create(data)`, `User/Company` 생성자    | (테스트 대상 아님 또는 다음 장에서 통합 관점)                                              |

> 비즈니스 로직과 오케스트레이션을 분리하면 “단위 테스트 단위”가 명확해진다 \[p.248] .

### 7.3.1 도메인/유틸리티를 테스트하는 법

* **가장 가치 높은 테스트 지점** = *복잡도↑·도메인 유의성↑·협력자↓* (예: `User.ChangeEmail`) \[p.248] .
* `Company.IsEmailCorporate()` 같은 유틸 메서드는 **매개변수화 테스트**로 묶어 간결하게 커버 \[p.249] .

### 7.3.2 나머지 사분면의 테스트 전략

* **단순 생성자** 등은 테스트 가치가 낮음(회귀 방지 효과 미미) \[p.249] .
* **협력자 많은 복잡 코드**는 리팩터링으로 제거했고, **컨트롤러 사분면**은 다음 장에서 통합 관점으로 다룬다 \[p.249] .

### 7.3.3 전제 조건(Precondition)을 테스트해야 하는가?

* **도메인 유의성 있는 전제 조건**(예: 직원 수는 음수 불가)은 테스트 가치가 크다. 클래스 불변성의 일부이기 때문 \[p.250] .
* 반대로 **도메인 의미 없는 보호 장치**(예: 팩토리 인자 길이 체크)는 굳이 테스트하지 않아도 된다 \[p.250] .
> 🤔 도메인 의미 없는 보호 장치란 무엇일까? 도메인의 해당하지 않는 기술적, 스펙적 테스트를 의미하는 듯 하다.
#### 도메인 의미 없는 보호 장치의 예
여기서 말하는 \*\*"도메인 의미 없는 보호 장치"\*\*는
전제 조건(Precondition) 중에서 **업무 규칙과 직접적인 연관이 없는 단순한 안전 장치**를 뜻해요.

* **도메인 의미 있는 전제 조건**

  * **업무 규칙**에 해당하는 조건
  * 예: "회사의 직원 수는 음수가 될 수 없다"

    * 회사라는 도메인에서 `직원 수 ≥ 0`은 필수 불변식
    * 이 규칙이 깨지면 업무 로직이 잘못된 것이므로 테스트 가치가 큼

* **도메인 의미 없는 전제 조건**

  * 업무 규칙이 아니라, **단순한 코드 안전성**을 위한 조건
  * 예: `UserFactory.Create()`에서 `data.length >= 3` 체크

    * 단순히 배열 인덱스 에러를 방지하는 수준
    * "왜 3이어야 하는지"는 도메인 규칙이 아니라 구현 방식에서 나온 제약
    * 이런 건 테스트할 가치가 낮음 (대부분 개발자가 실수하지 않는 한 버그로 이어질 가능성이 낮고, 테스트 유지보수 비용만 늘어남)


---

## 7.4 컨트롤러에서 조건부 로직 처리

* **읽기→결정→쓰기**의 3단계 구조일 때, 외부 의존성(DB, 메시지 버스 등)은 연산의 **가장자리**로 밀어내는 게 이상적이다(육각형/함수형 아키텍처) \[p.251] .
> 🤔 out adapter로 분리를 의미함.
* 하지만 현실에선 중간 의사결정 결과에 따라 *추가 조회/쓰기*가 필요해지며(그림 7.11), 세 가지 절충이 생긴다 \[p.252-253]  .
> 이런 경우는 빈번하다. 특히 조회.

### (그림 7.12) 세 특성의 절충 — 직접 표로 재구성

| 방법                  | 컨트롤러 단순성 | 도메인 모델 테스트 유의성 | 성능           |
| ------------------- | -------- | -------------- | ------------ |
| **읽기/쓰기를 가장자리로 몰기** | ● 좋음     | ● 좋음           | ○ 나쁨(불필요 호출) |
| **도메인에 외부 의존 주입**   | ● 좋음     | ○ 나쁨(협력자↑)     | ● 좋음         |
| **결정 단계를 세분화**      | ○ 복잡↑    | ● 좋음           | ● 좋음         |

> 현실적으로 1안(성능 저하)은 배제, 2안(의존 주입)은 테스트성 악화 → **3안(세분화)** 을 택하되, 복잡도 상승을 관리해야 한다 \[p.253] .

- 3안의 경우 아래 플로우를 참조하자.
> 😎 보통 핵사고날에서는 서비스 레이어에서 아래 단계를 수행한다.
```
Step 1: 기본 데이터 읽기 (DB 조회)
Step 2: 1차 판단 (도메인 로직)
Step 3: 필요하면 외부 API 호출 (추가 데이터 가져오기)
Step 4: 2차 판단 (도메인 로직)
Step 5: 결과 저장 (DB 저장)
```

### 7.4.1 CanExecute/Execute 패턴

* 비즈니스 결정을 **도메인 모델 내부에 유지**하면서도 컨트롤러의 분기 난립을 막는 방법.
* `User.CanChangeEmail()`로 **사전 질의** → `User.ChangeEmail()`의 **전제 조건**으로 강제 \[p.256-257]  .
* 이 패턴의 효과:

  1. 컨트롤러는 “가능한가?”만 물음 → 내부 검증은 캡슐화 \[p.257] .
  2. 사전 확인 없이 수행 불가(전제조건) → 일관성 확보 \[p.257] .

### 7.4.2 도메인 이벤트로 변경 사항 추적

* “무엇이 *실제로 일어났는지*”를 **도메인 이벤트**로 기록 → 연산이 끝난 뒤 컨트롤러가 이벤트를 외부 메시지로 변환 \[p.258-261]  .
* 예: 이메일이 실제로 바뀌었을 때만 `EmailChangedEvent` 추가 → 컨트롤러는 해당 이벤트들을 메시지 버스로 발행한다 \[p.260-261]  .
* DB 저장은 항상 하되(ORM은 변경 없으면 no-op일 수 있음), **메시지 발행은 이벤트 유무로 제어**한다. 외부 계약을 지키기 위함이다 \[p.261] .

---

## ✍️ Kotlin 예제 (as-is → to-be, 도메인 포함)

### 도메인 시나리오

* **광고 플랫폼 CRM**: 사용자의 이메일 변경 정책

  * 회사 도메인 이메일이면 `Employee`, 아니면 `Customer`.
  * 이메일이 \*\*확인(confirmed)\*\*된 후에는 변경 불가.
  * 실제로 **바뀐 경우에만** 외부 메시지(`EmailChanged`) 전송.

---

### (AS-IS) 컨트롤러 분기 많음 + 이벤트 미사용

```kotlin
// 도메인 (의존 캡슐화 미흡)
data class Company(val domain: String, var numberOfEmployees: Int) {
    fun isCorporate(email: String) = email.endsWith("@$domain")
    fun changeNumberOfEmployees(delta: Int) {
        require(numberOfEmployees + delta >= 0) { "employees cannot be negative" } // 도메인 전제조건
        numberOfEmployees += delta
    }
}

enum class UserType { Customer, Employee }

data class User(
    val id: Long,
    var email: String,
    var type: UserType,
    var isEmailConfirmed: Boolean
) {
    // 도메인 내부에 결정 로직이 있긴 하나, 컨트롤러와 분산될 여지 높음
    fun changeEmail(newEmail: String, company: Company) {
        if (email == newEmail) return
        val newType = if (company.isCorporate(newEmail)) UserType.Employee else UserType.Customer
        if (type != newType) {
            val delta = if (newType == UserType.Employee) 1 else -1
            company.changeNumberOfEmployees(delta)
        }
        email = newEmail
        type = newType
    }
}

// 외부 포트
interface MessageBus { fun sendEmailChanged(userId: Long, newEmail: String) }
interface UserRepository { fun findById(id: Long): User; fun save(user: User) }
interface CompanyRepository { fun get(): Company; fun save(company: Company) }

// AS-IS 컨트롤러: 분기·외부 호출 섞임(테스트 취약)
class UserController(
    private val users: UserRepository,
    private val companies: CompanyRepository,
    private val bus: MessageBus
) {
    fun changeEmail(userId: Long, newEmail: String): String {
        val user = users.findById(userId)
        if (user.isEmailConfirmed) return "Can't change a confirmed email" // 컨트롤러 분기

        val company = companies.get()
        val oldEmail = user.email
        user.changeEmail(newEmail, company)

        companies.save(company)
        users.save(user)
        bus.sendEmailChanged(userId, newEmail) // 바뀌지 않아도 전송될 위험

        return if (oldEmail == newEmail) "OK (no-op)" else "OK"
    }
}
```

### (TO-BE) CanExecute/Execute + 도메인 이벤트 + 컨트롤러 단순화

```kotlin
// 도메인 이벤트
data class EmailChangedEvent(val userId: Long, val newEmail: String)

// 도메인
data class Company(val domain: String, var numberOfEmployees: Int) {
    fun isCorporate(email: String) = email.endsWith("@$domain")
    fun changeNumberOfEmployees(delta: Int) {
        require(numberOfEmployees + delta >= 0) { "employees cannot be negative" } // 전제조건(도메인 유의성 有) [테스트 대상]
        numberOfEmployees += delta
    }
}

enum class UserType { Customer, Employee }

class User(
    val id: Long,
    email: String,
    type: UserType,
    private var emailConfirmed: Boolean
) {
    var email: String = email; private set
    var type: UserType = type; private set

    // 연산 결과(사이드이펙트)를 메모리에 보류
    private val _domainEvents = mutableListOf<EmailChangedEvent>()
    val domainEvents: List<EmailChangedEvent> get() = _domainEvents

    // CanExecute: 컨트롤러 분기 제거용 질의
    fun canChangeEmail(): String? =
        if (emailConfirmed) "Can't change a confirmed email" else null

    // Execute: 전제조건으로 Can을 강제하여 오용 방지
    fun changeEmail(newEmail: String, company: Company) {
        require(canChangeEmail() == null) { "Precondition failed: cannot change confirmed email" }

        if (email == newEmail) return // 실제 변경 없으면 이벤트 X

        val newType = if (company.isCorporate(newEmail)) UserType.Employee else UserType.Customer
        if (type != newType) {
            val delta = if (newType == UserType.Employee) 1 else -1
            company.changeNumberOfEmployees(delta)
        }
        email = newEmail
        type = newType
        _domainEvents += EmailChangedEvent(id, newEmail) // 실제 변경시에만 이벤트 추가
    }
}

// 포트
interface MessageBus { fun sendEmailChanged(userId: Long, newEmail: String) }
interface UserRepository { fun findById(id: Long): User; fun save(user: User) }
interface CompanyRepository { fun get(): Company; fun save(company: Company) }

// 컨트롤러: 의사결정 제거, 이벤트 변환만 담당
class UserController(
    private val users: UserRepository,
    private val companies: CompanyRepository,
    private val bus: MessageBus
) {
    fun changeEmail(userId: Long, newEmail: String): String {
        val user = users.findById(userId)
        user.canChangeEmail()?.let { return it } // 도메인 결정 사용

        val company = companies.get()
        user.changeEmail(newEmail, company)

        companies.save(company)
        users.save(user)

        // 도메인 이벤트 → 외부 메시지
        user.domainEvents.forEach { ev ->
            bus.sendEmailChanged(ev.userId, ev.newEmail)
        }
        return "OK"
    }
}
```

#### Kotest 예시(핵심 시나리오)

```kotlin
import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.collections.shouldContainExactly

class UserDomainTest : StringSpec({

    "회사 이메일로 변경하면 직원 수 +1, 타입 변경, 이벤트 1건 생성" {
        val company = Company(domain = "mycorp.com", numberOfEmployees = 1)
        val user = User(id = 1, email = "user@gmail.com", type = UserType.Customer, emailConfirmed = false)

        user.changeEmail("user@mycorp.com", company)

        company.numberOfEmployees shouldBe 2
        user.email shouldBe "user@mycorp.com"
        user.type shouldBe UserType.Employee
        user.domainEvents.shouldContainExactly(EmailChangedEvent(1, "user@mycorp.com"))
    }

    "같은 이메일로 변경하면 no-op: 직원 수/타입/이벤트 변화 없음" {
        val company = Company("mycorp.com", 1)
        val user = User(1, "user@mycorp.com", UserType.Employee, emailConfirmed = false)

        user.changeEmail("user@mycorp.com", company)

        company.numberOfEmployees shouldBe 1
        user.type shouldBe UserType.Employee
        user.domainEvents.size shouldBe 0
    }

    "확인된 이메일은 변경 불가(CanExecute 전제조건 위반)" {
        val company = Company("mycorp.com", 1)
        val user = User(1, "user@gmail.com", UserType.Customer, emailConfirmed = true)

        user.canChangeEmail() shouldBe "Can't change a confirmed email"
    }

    "도메인 전제조건: 직원 수 음수 불가" {
        val company = Company("mycorp.com", 0)
        val ex = kotlin.runCatching { company.changeNumberOfEmployees(-1) }.exceptionOrNull()
        require(ex is IllegalArgumentException) { "should fail with precondition" }
    }
})
```

> 위 **to-be** 구성은 책의 CanExecute/Execute 패턴과 **도메인 이벤트** 운용을 Kotlin으로 옮긴 것이다. 컨트롤러 테스트의 부담을 도메인 단위테스트로 크게 옮겨온다 \[p.257-261]  .

---

## 빠른 레퍼런스 표/이미지 요약 (본문 반영)

### “읽기–결정–쓰기” 3단계 & 외부 의존성 가장자리 배치

* 외부 의존 호출은 연산의 **가장자리**로 밀어내면 테스트 용이성이 증가한다(육각형/함수형 아키텍처) \[p.251] .

### 세 가지 절충(그림 7.12 재구성)

* **단순성 vs 테스트 유의성 vs 성능** — 세 가지 모두를 동시에 만족하는 해법은 없고, **두 가지를 선택**해야 한다 \[p.253] .

---

## 인터넷 참고자료 (간략 정리 + 링크)

* **도메인 이벤트(DDD)**: 상태 변화 사실을 일급 객체로 모델링. 이벤트 소싱과도 밀접. 컨텍스트 간 결합을 낮추고 외부 통지에 적합. Martin Fowler 글 추천. ([martinfowler.com][1])
* **육각형 아키텍처(Ports & Adapters)**: 앱을 외부로부터 격리해 **테스트 독립성**과 **기술 선택 자유** 확보. Cockburn 원글·발표 자료 추천. ([Alistair Cockburn][2], [Alistair Cockburn][3], [AWS Documentation][4])
* **전제조건/설계 계약(Design by Contract)**: 전제조건·불변식·사후조건을 명시해 “빠르게 실패”하게 만들고, *도메인 유의성 있는* 전제조건은 테스트 대상. MS Code Contracts·DbC 개요 참고. ([Microsoft Learn][5], [위키백과][6])
* **무엇을 단위 테스트할까?** 컨트롤러는 대개 통합 테스트가 적합, 도메인 모델·알고리즘 쪽이 단위테스트의 단맛. (현 글과 동일한 방향성) ([Julio Casal][7])
* **저자 블로그**(V. Khorikov): 책 배경과 원칙들 정리. 테스트가 좋은 아키텍처를 유도한다. ([Khorikov][8], [Enterprise Craftsmanship][9], [Manning Publications][10], [Barnes & Noble][11])

---

## 요약

* **7.3**: 단위 테스트 가치는 **도메인 유의성·복잡도↑ + 협력자↓** 영역에서 최대. 도메인 전제조건 중 **업무 의미가 있는 것**을 테스트하라(예: 직원 수 음수 금지) \[p.248-250]  .
* **7.4**: 외부 의존이 얽힌 조건부 로직은 **세 가지 절충**(단순성/테스트성/성능) 중 선택. 실무에선 **의사결정 단계 세분화** + **CanExecute/Execute**로 결정을 도메인에 모으고, **도메인 이벤트**로 실제 변화만 외부에 통지하라 \[p.253, 257-261]   .

---

### 추천 파일명

`2501-7.3~7.4-단위테스트-커버리지와컨트롤러조건부로직-P.MD`

[1]: https://martinfowler.com/eaaDev/DomainEvent.html?utm_source=chatgpt.com "Domain Event"
[2]: https://alistair.cockburn.us/hexagonal-architecture?utm_source=chatgpt.com "hexagonal-architecture - Alistair Cockburn"
[3]: https://alistaircockburn.com/Hexagonal%20Budapest%2023-05-18.pdf?utm_source=chatgpt.com "Hexagonal Architecture ( Ports & Adapters )"
[4]: https://docs.aws.amazon.com/prescriptive-guidance/latest/cloud-design-patterns/hexagonal-architecture.html?utm_source=chatgpt.com "Hexagonal architecture pattern - AWS Prescriptive Guidance"
[5]: https://learn.microsoft.com/en-us/dotnet/framework/debug-trace-profile/code-contracts?utm_source=chatgpt.com "Code Contracts - .NET Framework"
[6]: https://en.wikipedia.org/wiki/Design_by_contract?utm_source=chatgpt.com "Design by contract"
[7]: https://juliocasal.com/blog/What-To-Unit-Test?utm_source=chatgpt.com "What Should I Unit Test?"
[8]: https://khorikov.org/posts/2019-09-30-book-is-sent-to-production/?utm_source=chatgpt.com "The Unit Testing book is sent to production! - Vladimir Khorikov"
[9]: https://enterprisecraftsmanship.com/book/?utm_source=chatgpt.com "Unit Testing book"
[10]: https://manning.com/books/unit-testing?utm_source=chatgpt.com "Unit Testing Principles, Practices, and Patterns"
[11]: https://www.barnesandnoble.com/w/unit-testing-principles-practices-and-patterns-vladimir-khorikov/1137832071?utm_source=chatgpt.com "Unit Testing Principles, Practices, and Patterns"
