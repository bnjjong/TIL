## 10.3 테스트 데이터 생명 주기

### 핵심 아이디어

* 운영 환경을 닮게: 통합 테스트는 준비/실행/검증 각각에서 **별도의 DB 컨텍스트(트랜잭션)** 를 써야 한다. 한 컨텍스트를 공유하면 1차 캐시 등으로 일관성이 깨진다. 준비·검증은 각각 자신의 컨텍스트로 DB 상태를 조회하고, 실행 구절의 컨텍스트는 다른 어떤 것과도 공유하지 말 것\[p.350] &#x20;
* 테스트는 **DB의 현재 상태에 의존하지 않도록**, 원하는 상태를 스스로 만든다\[p.350] .
> 테스트를 진행하기 위해서 필요한 셋업 데이터는 코드로 만들던, sql로 미리 셋팅을 하던, 논리적으로 준비를 해두어야 함. 근데 이게 비용이 만만치 않다. 특히 엔터프라이즈급에서는 특정 케이스를 확인하기 위해 이런 셋업 코드량이 더 많을 수 있음. 

### 10.3.1 병렬 실행 vs 순차 실행

* 병렬 실행은 “모든 테스트 데이터의 고유성 보장·잔여 데이터 정리·제약조건 충돌 회피” 등 유지 비용이 큼. 보통 **순차 실행이 실용적**이며, 단위/통합 테스트 스위트를 분리해 **통합 테스트군만 병렬 비활성화**를 권장\[p.351] .
> 병렬처리는 한번도 실무에서 해본적은 없다. 된다는 것은 알고 있지만 언급한대로 상태를 관리하지 않아야 하므로 pure function 형태나 내 외부 의존도가 없는 기능에만 사용할수 있을것 같은데 이렇게 프로그래밍 하기가 쉽지 않음.
* 컨테이너를 테스트마다 띄우는 방식은 이미지/수명 주기 관리가 번거롭다. **개발자당 하나의 DB 인스턴스**(원한다면 도커 1개)로 운영하는 편이 현실적\[p.351]  .
> 테스트 컨테이너를 실무에서 사용하긴 하는데 비용이 너무 크긴 함. -> 뭔가 다른 방법이 있는지도 궁금함.
> 하나의 도커를 사용하는것 이게 물론 개발할때나 테스트할때는 편하지만 상태가 디비에 개별적으로 저장되는것이 있음. 만약 이것을 강제 하려면 **스트릭한 프로토콜**이 있어야 할것 같다.

### 10.3.2 실행 사이의 데이터 정리(4가지 방법 비교)

* 백업 복원(느림), 테스트 종료 시 정리(종료 누락 위험), 테스트를 트랜잭션으로 감싸고 롤백(운영과 다른 설정을 초래), **테스트 시작 시 정리(권장)** — 빠르고, 일관적이며, 누락 위험이 없음\[p.351-352] .
* 시작 시 정리는 **FK 순서를 고려한 수동 SQL 삭제 스크립트**로 간단히 제어하는 게 낫다. 모든 테스트의 **기초 클래스**에서 자동 실행되게 하라\[p.352]  .
* 샘플(기초 클래스 + 삭제 스크립트) \[p.352]   .
> 이것을 잘하는게 아마도 노하우가 아닐까? 생각보다 저 스크립트를 유지하는게 굉장히 번거롭다.

#### 표: 테스트 데이터 정리 전략 비교 (권장 순)

| 전략              | 속도 | 운영 환경과의 유사성     | 위험/단점          | 권장도   |
| --------------- | -- | --------------- | -------------- | ----- |
| 시작 시 정리(수동 SQL) | 빠름 | 동일              | FK 순서 고려 필요    | ★★★★☆ |
| 종료 시 정리         | 빠름 | 동일              | 중단·디버깅 시 누락 위험 | ★★☆☆☆ |
| 트랜잭션 감싸고 롤백     | 보통 | **다름**(추가 트랜잭션) | 운영과 불일치        | ★☆☆☆☆ |
| 백업 복원           | 느림 | 동일              | 전체 스위트 시간 급증   | ★☆☆☆☆ |

### 10.3.3 인메모리 DB 피하기

* 장점(빠름, 분리, 인스턴스화 쉬움)이 있지만 **기능 불일치로 거짓 양/음성**을 유발, 보호 수준이 낮고 회귀 테스트를 많이 남긴다. **운영과 같은 DBMS**(버전은 달라도 공급사 동일)를 사용하라\[p.353] .
> 완전 동의함. 인메모리 디비는 mvp개발 외에서는 사용하지 않음.

#### 내 생각

* “운영과 닮게” 원칙이 전부를 설명합니다. 트랜잭션 3개(준비/실행/검증), 시작 시 정리, 인메모리 회피—모두 일관성·신뢰도에 직결됩니다.

---

## 10.4 테스트 구절에서 코드 재사용하기

### 개요

* 통합 테스트는 **짧고 독립적**이어야 한다. 비즈니스와 무관한 기술 요소를 **비공개 메서드나 헬퍼**로 추출해 재사용하라\[p.354] .

### 10.4.1 준비(Arrange) 구절 재사용

* 팩토리 메서드(Object Mother)로 준비 상용구 제거. **기본 인수**로 관련 없는 값을 감추면 가독성이 좋아진다\[p.355-357]  . -> 기본값을 제공하거나, 필요한 값만 노출하라는 의미군.
> fixture 객체가 대표적일것 같은데, 이것도 관리비용이 제법 든다.. ㅠㅠ
* Test Data Builder도 가능하나 상용구가 많아 **Object Mother 권장**\[p.357] .
* 위치: **테스트 클래스 안**부터 시작하고, 중복이 심해질 때만 별도 헬퍼로 옮겨라. **기초 클래스엔 넣지 말 것**(기초 클래스는 정리 등 공통 훅 전용)\[p.357-358] .
> 중복이 심해진다는 의미가 뭘까? 헬퍼 클래스? 예를 들면 사용자 생성의 경우 사용자 테스트 외 다른 통합테스트를 위해 사용될수도 있으니 이렇게 다른 컨텍스트에서 사용될 경우에는 헬퍼 클래스를 사용하란 의미.

### 10.4.2 실행(Act) 구절 재사용

* 컨트롤러/서비스 호출을 감싸는 **데코레이터 메서드**로 실행 구절을 1\~2줄로 축약\[p.358] .
> 함수형 코드로 데코레이트 코드로 실행구절을 요약.

### 10.4.3 검증(Assert) 구절 재사용

* `QueryUser`, `QueryCompany` 같은 **조회 헬퍼**로 검증 로직을 정리\[p.358-359] .
* **플루언트 검증 인터페이스**(확장 메서드 등)로 읽기 쉬운 Assert 체이닝 구현\[p.359] .
```kotlin
User userFromDb = QueryUser(user.Userld); 
userFromDb
    .ShouldExist()
    .WithEmail("new@gniail.com" )
    .WithType(UserType.Customer);

Company companyFromDb = QueryCompany(); 
companyFromDb
    .ShouldExist()
    .WithNumberOfEmployees(0);
```

### 10.4.4 “트랜잭션이 늘어나 느려지지 않나?”

* 재사용으로 트랜잭션 수가 증가(예: 5개)하지만, **유지보수성을 위해 성능을 일부 양보**하라. 특히 로컬 DB면 영향이 작다\[p.360-361]  .
> 테스트 환경에서는 완전 동의함. 근데 글로만 보니 이해가 안되네.

#### 내 생각

* 테스트 가독성과 유지보수성은 `“언제든 고쳐 쓰기 쉬움”`입니다. 실행/검증 축약과 플루언트 검증은 향후 리팩터링 비용을 확 줄여줍니다.

---

## 10.5 데이터베이스 테스트 FAQ

### 10.5.1 “읽기”도 테스트해야 하나?

* **쓰기는 위험도가 높아 최우선 보호 대상**. 반면 읽기 버그는 피해가 적고, 도메인 모델 캡슐화도 **주로 쓰기 변경 일관성**을 위한 것이라 읽기엔 큰 의미가 없다. 중요/복잡한 읽기만 선별 테스트하고, 읽기는 **ORM 대신 SQL이 더 낫다**(추상화 줄이기)\[p.362].
> 왜지? SQL이 더 낫다니.. 추상화 계층이 없어서? 이건 좀 논쟁이 필요해 보임.

### 10.5.2 리포지터리를 따로 테스트할까?

* 리포지터리는 **복잡도가 낮고 외부 의존성(DB)** 을 다루어 유지비가 높은데, **회귀 방지 가치는 통합 테스트와 겹침**.
* 권장: 리포지터리 자체 테스트 대신, **매핑 복잡도는 별도 알고리즘/팩토리로 추출해 단위 테스트**, 리포지터리는 **통합 테스트 스위트의 일부**로 다룬다\[p.363-365]   .

#### 내 생각

* 리포지터리를 “독립 모듈처럼” 테스트하기보다, **도메인 로직은 단위 테스트, 저장·조회는 통합 테스트**로 역할을 가르는 편이 비용 대비 효과가 큽니다.

---

## 샘플 코드 (Kotlin, Spring Boot 3.x, JPA, Kotest)

> 목표: ① 운영과 닮게(동일 DBMS) ② 시작 시 정리 ③ 준비/실행/검증 **각각 다른 트랜잭션** ④ Object Mother/플루언트 검증 ⑤ 메시지버스/로거는 더블.

### 도메인 & 포트

```kotlin
// domain/User.kt
enum class UserType { Employee, Customer }

@Entity
@Table(name = "users")
class User(
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    var email: String,
    @Enumerated(EnumType.STRING)
    var type: UserType,
    var emailConfirmed: Boolean = false
)

@Entity
@Table(name = "companies")
class Company(
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(unique = true) val domain: String,
    var numberOfEmployees: Int
)

// ports
interface MessageBus { fun sendEmailChanged(userId: Long, newEmail: String) }
interface DomainLogger { fun userTypeChanged(userId: Long, from: UserType, to: UserType) }
```

```kotlin
// infrastructure/repos
interface UserRepository : JpaRepository<User, Long> {
    fun findByEmail(email: String): User?
}
interface CompanyRepository : JpaRepository<Company, Long> {
    fun findByDomain(domain: String): Company?
}
```

```kotlin
// application/UserService.kt
@Service
class UserService(
    private val users: UserRepository,
    private val companies: CompanyRepository,
    private val bus: MessageBus,
    private val logger: DomainLogger
) {
    @Transactional
    fun changeEmail(userId: Long, newEmail: String): String {
        val user = users.findById(userId).orElseThrow()
        val oldType = user.type

        val newDomain = newEmail.substringAfter("@")
        val company = companies.findByDomain(newDomain)

        // 도메인 정책: 회사 도메인이면 Employee, 아니면 Customer
        user.email = newEmail
        if (company != null && user.type != UserType.Employee) {
            user.type = UserType.Employee
            company.numberOfEmployees += 1
        } else if (company == null && user.type == UserType.Employee) {
            user.type = UserType.Customer
            // 직원 수 감소 (바깥으로 이동)
            // 실제에선 이전 회사 탐색 로직이 필요하지만 샘플에서는 단일 회사라고 가정
            companies.findAll().firstOrNull()?.let { it.numberOfEmployees -= 1 }
        }

        bus.sendEmailChanged(user.id!!, newEmail)
        if (oldType != user.type) logger.userTypeChanged(user.id!!, oldType, user.type)
        return "OK"
    }
}
```

#### 테스트 더블

```kotlin
// test-doubles
class BusSpy : MessageBus {
    private val messages = mutableListOf<Pair<Long, String>>()
    override fun sendEmailChanged(userId: Long, newEmail: String) { messages += userId to newEmail }
    fun shouldSendExactly(n: Int) = apply { require(messages.size == n) { "expected $n but ${messages.size}" } }
    fun withEmailChanged(userId: Long, newEmail: String) = apply {
        require(messages.any { it.first == userId && it.second == newEmail }) { "missing message" }
    }
}

class LoggerMock : DomainLogger {
    data class Change(val id: Long, val from: UserType, val to: UserType)
    val changes = mutableListOf<Change>()
    override fun userTypeChanged(userId: Long, from: UserType, to: UserType) { changes += Change(userId, from, to) }
    fun verifyChangedOnce(id: Long, from: UserType, to: UserType) = apply {
        require(changes.count { it.id == id && it.from == from && it.to == to } == 1)
    }
}
```

### 공통 테스트 베이스(시작 시 정리)

```kotlin
// test/IntegrationBase.kt
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
@SpringBootTest
abstract class IntegrationBase(
    @Autowired private val jdbc: JdbcTemplate
) {
    @BeforeEach
    fun clear() {
        // FK 순서 고려: 자식 → 부모
        jdbc.update("DELETE FROM users")
        jdbc.update("DELETE FROM companies")
    }
}
```

> 시작 시 정리를 공통 베이스에 둔다. 종료 시 정리/트랜잭션 롤백 대신 **준비 구절에서 정리**를 수행(권장)\[p.351-352] .

### Object Mother & 조회 헬퍼(준비/검증 축약)

```kotlin
// test/ObjectMothers.kt
@Component
class Mothers(
    private val users: UserRepository,
    private val companies: CompanyRepository
) {
    @Transactional
    fun user(
        email: String = "user@mycorp.com",
        type: UserType = UserType.Employee,
        emailConfirmed: Boolean = false
    ): User = users.save(User(email = email, type = type, emailConfirmed = emailConfirmed))

    @Transactional
    fun company(domain: String = "mycorp.com", employees: Int = 1): Company =
        companies.save(Company(domain = domain, numberOfEmployees = employees))
}

@Component
class Queries(
    private val users: UserRepository,
    private val companies: CompanyRepository
) {
    @Transactional(readOnly = true)
    fun user(id: Long) = users.findById(id).orElseThrow()
    @Transactional(readOnly = true)
    fun company(domain: String) = companies.findByDomain(domain)!!
}

// 플루언트 검증(읽기 쉬운 Assert)
fun User.shouldHaveEmail(email: String) = apply { require(this.email == email) }
fun User.shouldHaveType(type: UserType) = apply { require(this.type == type) }
fun Company.shouldHaveEmployees(n: Int) = apply { require(this.numberOfEmployees == n) }
```

> Object Mother/선택적 인수·조회 헬퍼·플루언트 검증은 책의 10.4 절 권고를 Kotlin으로 옮긴 것\[p.355-359]    .

---

### 샘플 테스트 1 — **as-is(문제 있는 예)**

> 한 트랜잭션으로 준비/실행/검증을 몰아넣고 H2를 사용(운영과 불일치, 캐시로 인해 상태 왜곡).

```kotlin
// test/UserServiceAsIsTest.kt
// build.gradle: testRuntimeOnly("com.h2database:h2")  <-- (나쁜 예) 운영은 PostgreSQL이라고 가정
@Transactional // <-- 테스트 전체 트랜잭션(권장 X)
class UserServiceAsIsTest(
    @Autowired private val mothers: Mothers,
    @Autowired private val queries: Queries,
    @Autowired private val service: UserService,
) : StringSpec({

    "회사 도메인에서 벗어나면 고객이 된다 - as-is" {
        val u = mothers.user(email = "user@mycorp.com", type = UserType.Employee)
        mothers.company(domain = "mycorp.com", employees = 1)

        // 실행
        service.changeEmail(u.id!!, "new@gmail.com")

        // 검증(같은 컨텍스트 캐시 영향 가능)
        queries.user(u.id!!).shouldHaveEmail("new@gmail.com").shouldHaveType(UserType.Customer)
        queries.company("mycorp.com").shouldHaveEmployees(0)
    }
})
```

* 문제점: (1) **같은 트랜잭션/컨텍스트 공유**로 1차 캐시 영향, (2) **H2**로 운영 DB와 기능 불일치 가능\[p.350, p.353]  .

---

### 샘플 테스트 2 — **to-be(권장 예)**

> 시작 시 정리 + 준비/실행/검증 **각각 별도 트랜잭션** + 운영 DBMS(예: PostgreSQL). 실행 구절은 데코레이터로 감싼다.

```kotlin
// test/UserServiceToBeTest.kt
// build.gradle: testRuntimeOnly("org.postgresql:postgresql")
// (프로젝트 전반에는 로컬 PostgreSQL 또는 클래스 단위 Testcontainers 1개를 사용)
class UserServiceToBeTest(
    @Autowired private val mothers: Mothers,
    @Autowired private val queries: Queries,
    @Autowired private val service: UserService,
    @Autowired private val txManager: PlatformTransactionManager
) : IntegrationBase(jdbc = JdbcTemplate(/* injected by Spring */)) , StringSpec({

    fun <T> inTx(block: () -> T): T =
        TransactionTemplate(txManager).execute { block() }!!

    fun <T> act(block: () -> T): T = inTx(block) // 실행 데코레이터(p.358)
    // ↑ 실행 구절 전용 트랜잭션

    "회사 도메인에서 벗어나면 고객이 된다 - to-be" {
        // 준비(별도 트랜잭션)
        val (userId) = inTx {
            val u = mothers.user(email = "user@mycorp.com", type = UserType.Employee)
            mothers.company(domain = "mycorp.com", employees = 1)
            u.id!!
        }

        val bus = BusSpy()
        val log = LoggerMock()
        // (테스트용 서비스 빈을 교체해야 한다면 @TestConfiguration으로 교체 가능)

        // 실행(별도 트랜잭션)
        act { service.changeEmail(userId, "new@gmail.com") } shouldBe "OK"

        // 검증(별도 트랜잭션)
        inTx {
            queries.user(userId).shouldHaveEmail("new@gmail.com").shouldHaveType(UserType.Customer)
            queries.company("mycorp.com").shouldHaveEmployees(0)
        }

        // 메시지/로그 검증
        bus.shouldSendExactly(1).withEmailChanged(userId, "new@gmail.com")
        log.verifyChangedOnce(userId, UserType.Employee, UserType.Customer)
    }
})
```

* 포인트: **준비/실행/검증 구절당 최소 1 트랜잭션**(3개 이상) 사용\[p.350] , 실행 구절 **데코레이터**로 축약\[p.358] . 시작 시 **수동 SQL 정리**는 `IntegrationBase`에서 자동 수행\[p.352] . 운영과 같은 **DBMS 사용** 권장\[p.353] .

---

## (참고) 읽기 쿼리 테스트 판단 가이드

* 쓰기(상태 변화)는 **항상** 보호.
* 읽기는 비용 대비 가치가 낮으므로 **복잡/핵심 조회만 선택적으로 통합 테스트**, 나머지는 모니터링/계측으로 커버\[p.362] .

---

## 외부 참고 자료(간략 정리+링크)

* **운영과 같은 DB로 테스트해야 하는 이유** — *V. Mihalcea*
  인메모리 DB(H2/HSQL)로는 벤더 고유 기능(윈도우 함수, 스토어드 함수 등)을 검증할 수 없다. **실제 DB 엔진**으로 통합 테스트하라. Testcontainers는 같은 버전을 손쉽게 쓸 수 있는 장점이 있다. ([Vlad Mihalcea][1])
* **Spring 테스트 트랜잭션 롤백 기본값** — *Spring Docs*
  `@Transactional` 테스트는 기본 **롤백=true**. 필요 시 `@Commit`/`@Rollback(false)`로 제어. (통합 테스트 전체를 트랜잭션으로 감싸는 습관은 운영과 불일치 유발) ([Home][2])
* **Test Data Builder vs Object Mother** — *Nat Pryce / Martin Fowler*
  Object Mother: 표준 픽스처 생성용 팩토리. Test Data Builder: 플루언트하게 필요한 속성만 강조. 두 패턴을 적절히 혼용해 **준비 상용구 최소화**. ([martinfowler.com][3], [natpryce.com][4])
* **AAA(Arrange–Act–Assert) 패턴 요약** — *Automation Panda / Semaphore*
  테스트를 세 구절로 명확히 분리해 단일 동작만 검증. 우리 “3 트랜잭션 원칙”과 잘 맞물림. ([Automation Panda][5], [Semaphore][6])
* **H2 ↔ Postgres 불일치 사례** — *Hibernate Types/StackOverflow*
  enum/JSON 등에서 호환성 이슈 다수. “테스트는 그저 통과했을 뿐”이 되는 전형적인 함정. ([Lightrun][7], [Stack Overflow][8])

---

## 요약

* **운영과 닮게**: 준비/실행/검증 **각 구절마다 다른 트랜잭션/컨텍스트** 사용, 시작 시 **수동 SQL 정리**, **인메모리 DB 회피**.&#x20;
* **코드 재사용**: Object Mother·조회 헬퍼·플루언트 검증·실행 데코레이터로 **테스트를 짧고 독립적**으로.   &#x20;
* **테스트 전략**: 쓰기는 **항상** 보호, 읽기는 **선택적으로**. 리포지터리는 **별도 테스트보다** 통합 테스트에 포함, 매핑 로직은 **분리하여 단위 테스트**. &#x20;

---

### 내 생각(한 줄 코멘트)

* **10.3**: “순차 실행 + 시작 시 정리”는 팀 스케일이 커질수록 체감 이득이 큽니다.
* **10.4**: 재사용의 목적은 “짧고 읽히는 테스트”. 도메인 의미만 남기고 기술은 숨기세요.
* **10.5**: 쓰기-읽기 위험 차등이 명확합니다. **가치가 큰 부분만** 읽기 테스트로 잡아도 충분합니다.

---

[1]: https://vladmihalcea.com/testcontainers-database-integration-testing/?utm_source=chatgpt.com "Testcontainers Database Integration Testing"
[2]: https://docs.spring.io/spring-framework/reference/testing/testcontext-framework/tx.html?utm_source=chatgpt.com "Transaction Management :: Spring Framework"
[3]: https://martinfowler.com/bliki/ObjectMother.html?utm_source=chatgpt.com "Object Mother"
[4]: https://www.natpryce.com/articles/000714.html?utm_source=chatgpt.com "Test Data Builders: an alternative to the Object Mother pattern"
[5]: https://automationpanda.com/2020/07/07/arrange-act-assert-a-pattern-for-writing-good-tests/?utm_source=chatgpt.com "Arrange-Act-Assert: A Pattern for Writing Good Tests"
[6]: https://semaphore.io/blog/aaa-pattern-test-automation?utm_source=chatgpt.com "The Arrange, Act, and Assert (AAA) Pattern in Unit Test ..."
[7]: https://lightrun.com/answers/vladmihalcea-hibernate-types-how-to-use-the-postgresqlenumtype-with-both-postgresql-and-h2?utm_source=chatgpt.com "How to use the PostgreSQLEnumType with both ..."
[8]: https://stackoverflow.com/questions/39620317/how-to-map-a-json-column-with-h2-jpa-and-hibernate?utm_source=chatgpt.com "How to map a JSON column with H2, JPA, and Hibernate"
