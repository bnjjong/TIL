## 11장 안티 패턴 (11.1 \~ 11.3) 정리

> 이번 장은 “겉보기에는 좋아 보이나, 장기적으로 문제를 키우는” 패턴들을 모아 설명합니다. 핵심 메시지는 **구현 세부가 아닌 ‘식별할 수 있는 동작’을 테스트하라**는 원칙을 다시 못 박는 것입니다. \[p.371]&#x20;

---

## 11.1 비공개 메서드 단위 테스트 (테스트 대상 아님)

### 핵심 개념

* “비공개 메서드를 어떻게 테스트하나요?”에 대한 짧은 답은 **“테스트하지 않는다”** 입니다. 그 이유는 비공개 메서드를 노출하거나 직접 테스트하면 **구현 세부 사항과 결합**되어 **리팩터링 내성**이 약해지기 때문입니다. 테스트는 **식별할 수 있는 동작**을 통해 **간접적으로** 검증해야 합니다. \[p.371];
> 동작을 통해서 간접 증명. 예를 들면 **공개된 광고를 생성하는 로직**을 통해서 **공개되지 않은 검증 로직**을 같이 검증.
* 비공개 메서드가 너무 복잡해 “공개 API를 통해 테스트하기에 커버리지가 불충분”하다면 보통 두 가지 신호입니다.

  1. **죽은 코드**일 수 있다 → 삭제 고려.
  2. **추상화 누락**이다 → 별도 클래스로 **로직을 추출**하라. \[p.372]&#x20;

### 예시 (책 흐름 요약)

* `Order.GenerateDescription()`은 간단하지만, 가격 계산을 담당하는 `GetPrice()`(private)가 복잡하다면 **`PriceCalculator`** 같은 별도 컴포넌트로 추출하여, 해당 컴포넌트를 독립적으로 테스트한다. \[p.372\~373] &#x20;

### “예외”가 되는 경우

* **ORM이 요구하는 비공개 생성자**처럼, 비공개이지만 \*\*식별할 수 있는 동작(계약)\*\*인 경우가 드물게 있습니다. 이때는

  * 생성자를 공개해도 테스트가 쉽게 깨지지 않을 수 있고(계약이 분명하면),
  * 또는 **리플렉션으로 인스턴스화**하여 노출 범위를 최소화할 수 있습니다. \[p.375]&#x20;

### 표 11.1 (재구성)

**코드 공개 여부 × 목적(식별할 수 있는 동작 vs 구현 세부 사항)**

| 목적 \ 공개수준   | 공개(Public) | 비공개(Private)  |
| ----------- | ---------- | ------------- |
| 식별할 수 있는 동작 | ✅ 좋음       | — (원칙상 해당 없음) |
| 구현 세부 사항    | ❌ 나쁨(유출)   | ✅ 좋음(캡슐화)     |

> 요지: **동작은 공개 API로, 구현은 비공개로**. 구현을 테스트에 노출시키지 말 것. \[맥락]&#x20;

### 내 생각 (짧게)

* 비공개를 테스트하고 싶다는 욕구는 “로직이 거기 있기 때문”인데, 그 자체가 **추상화 경고등**입니다. 추출/분리로 **모듈 경계**를 정리하면 테스트도 자연히 좋아집니다.

---

## 11.2 비공개 상태 노출 (상태를 테스트에 노출하지 말 것)

### 핵심 개념

* 테스트 편의를 이유로 **비공개 필드/상태를 공개**하는 것은 안티 패턴입니다. SUT(테스트 대상)는 **제품 코드와 동일한 방식**으로 사용되어야 하며, 테스트에만 특권을 주면 구현 결합이 됩니다. \[p.377]&#x20;
* 예: `Customer`의 `status`(private). `Promote()` 호출 후 **할인율**이 바뀌는 **외부 가시 동작**을 검증해야 합니다. 상태 그 자체를 들여다보지 말고 \*\*효과(할인 5%)\*\*를 확인하세요. \[p.377]&#x20;
* 나중에 제품 코드가 정말 해당 상태를 사용하기 시작하면, 그때는 **식별 가능한 동작**이 되므로 테스트에서 결합할 수 있습니다(시점의 문제). \[p.377]&#x20;

### 내 생각 (짧게)

* “상태를 까보면 마음은 편”하지만, 그 순간부터 테스트는 깨지기 쉬워집니다. \*\*입력→출력(효과)\*\*를 보는 습관이 유지보수성을 지켜줍니다.

---

## 11.3 테스트로 유출된 도메인 지식 (알고리즘 재구현 금지)

### 핵심 개념

* 테스트에서 제품 코드의 **알고리즘을 그대로 재구현**(복붙/수식 반복)하는 것은 안티 패턴입니다. 이렇게 하면 **구현 결합**으로 인해 리팩터링 내성이 0에 수렴합니다. \[p.378]&#x20;
* 올바른 접근: **예상 결과를 하드코딩**(또는 신뢰 가능한 외부 근거로 계산)하고, SUT의 결과만 비교합니다. \[p.380]&#x20;

### 내 생각 (짧게)

* 테스트는 \*\*“예시 카탈로그”\*\*여야 합니다. 도메인 전문가가 승인한 **입·출력 예시**를 축적하면, 구현을 바꿔도 테스트는 살아남습니다.

---

## Kotlin 도메인 예제 (as-is → to-be)

### 시나리오 1) 가격 계산 private 로직 분리 (11.1 관련)

#### as-is: 비공개 메서드에 중요한 로직이 숨어 있음

```kotlin
// 도메인: 주문 결제
data class Customer(val id: Long, val grade: String) // "REGULAR", "VIP" 등
data class Product(val id: Long, val price: Long)
data class Order(val customer: Customer, val items: List<Product>) {

    // ❶ 공개 API: 설명 문자열 생성
    fun generateDescription(): String {
        return "customer=${customer.id}, count=${items.size}, total=${getTotalPrice()}"
    }

    // ❷ 비공개 복잡 로직(세금/할인/쿠폰 등 뒤섞임) → 테스트 접근 불가
    private fun getTotalPrice(): Long {
        val base = items.sumOf { it.price }
        val discount = if (customer.grade == "VIP") (base * 0.1).toLong() else 0L
        val tax = (base * 0.1).toLong()
        return base - discount + tax
    }
}
```

#### to-be: 가격 계산을 별도 컴포넌트로 추출

```kotlin
// ❶ 정책/규칙을 외부로 분리 → 독립적 단위 테스트 가능
class PriceCalculator {
    fun calculate(customer: Customer, items: List<Product>): Long {
        val base = items.sumOf { it.price }
        val discount = if (customer.grade == "VIP") (base * 0.1).toLong() else 0L
        val tax = (base * 0.1).toLong()
        return base - discount + tax
    }
}

data class Order2(val customer: Customer, val items: List<Product>, private val calculator: PriceCalculator) {
    fun generateDescription(): String {
        val total = calculator.calculate(customer, items) // ❷ 공개 API는 간결해짐
        return "customer=${customer.id}, count=${items.size}, total=$total"
    }
}
```

#### Kotest

```kotlin
import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.shouldBe

class PriceCalculatorTest : StringSpec({
    "VIP 고객은 10% 할인 후 10% 세금이 반영된다" {
        val calc = PriceCalculator()
        val vip = Customer(1, "VIP")
        val items = listOf(Product(1, 10_000), Product(2, 10_000)) // base=20,000
        // expected = base(20000) - discount(2000) + tax(2000) = 20000
        calc.calculate(vip, items) shouldBe 20_000
    }

    "REGULAR 고객은 할인 없이 세금만 반영된다" {
        val calc = PriceCalculator()
        val regular = Customer(2, "REGULAR")
        val items = listOf(Product(1, 10_000))
        // expected = 10000 - 0 + 1000 = 11000
        calc.calculate(regular, items) shouldBe 11_000
    }
})
```

> 포인트: 테스트가 **비공개 구현**이 아니라 **분리된 컴포넌트의 동작**을 검증합니다. \[p.372\~373]&#x20;

---

### 시나리오 2) 상태 노출 대신 ‘효과’를 검증 (11.2 관련)

#### as-is: 상태 필드를 테스트 위해 공개(안티 패턴)

```kotlin
// ❌ 테스트 때문에 상태를 공개하는 형태 (피해야 함)
class CustomerLoyalty_as_is {
    var status: String = "REGULAR" // 공개됨 (취약)
        private set

    fun promote() {
        status = "PREFERRED"
    }

    fun discountRate(): Double = if (status == "PREFERRED") 0.05 else 0.0
}
```

#### to-be: 상태는 감추고, 결과(할인율)로 검증

```kotlin
class CustomerLoyalty {
    private var status: String = "REGULAR" // 비공개 상태 유지

    fun promote() { status = "PREFERRED" }

    fun discountRate(): Double = if (status == "PREFERRED") 0.05 else 0.0
}
```

#### Kotest

```kotlin
import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.doubles.shouldBeExactly

class CustomerLoyaltyTest : StringSpec({
    "신규 고객은 할인 없음" {
        val c = CustomerLoyalty()
        c.discountRate() shouldBeExactly 0.0
    }
    "승격 후 할인 5%" {
        val c = CustomerLoyalty()
        c.promote()
        c.discountRate() shouldBeExactly 0.05
    }
})
```

> 포인트: **비공개 상태를 열어보지 않고**, \*\*가시 동작(할인율)\*\*만으로 확인합니다. \[p.377]&#x20;

---

### 시나리오 3) 알고리즘 재구현 금지 (11.3 관련)

#### as-is: 테스트가 구현을 복제(유출)

```kotlin
// ❌ 테스트에서 expected = a + b 로 ‘같은’ 구현을 다시 씀
fun add(a: Int, b: Int) = a + b
```

```kotlin
// Kotest (안티 패턴)
class CalcAsIsTest : io.kotest.core.spec.style.StringSpec({
    "덧셈" {
        val a = 11; val b = 33
        val expected = a + b  // ← 구현 재사용(유출)
        add(a, b) shouldBe expected
    }
})
```

#### to-be: 신뢰 가능한 예시값을 **하드코딩**

```kotlin
// ✅ 기대값은 도메인/업무 규칙에 따라 사전 검증된 예시로 명시
class CalcToBeTest : io.kotest.core.spec.style.StringSpec({
    listOf(
        Triple(1, 3, 4),
        Triple(11, 33, 44),
        Triple(100, 500, 600),
    ).forEach { (a, b, expected) ->
        "$a + $b = $expected" {
            add(a, b) shouldBe expected
        }
    }
})
```

> 포인트: \*\*테스트는 “예시 집합”\*\*이어야 하며, **구현을 암시하지 않는 값**으로 기대를 고정합니다. \[p.378\~380] &#x20;

---

## 외부 참고 자료 (간략 정리 + 링크)

* **Google Testing Blog – Test Behavior, Not Implementation**: 공개 API를 테스트하고 구현 상세는 숨기라는 원칙을 명료하게 설명. 리팩터링에도 테스트가 견디게 함. ([Google Testing Blog][1])
* **Testing on the Toilet – Don’t Overuse Mocks**: 목 과사용은 구현 누출을 키움. 동작 중심 테스트를 권장. ([Google Testing Blog][2])
* **Martin Fowler – Mocks Aren’t Stubs**: 모크/스텁의 차이와 테스트 스타일의 함의 정리. 구현 결합을 피해야 하는 이유를 간접적으로 뒷받침. ([martinfowler.com][3])
* **.NET Unit Testing Best Practices (MS Docs)**: 사적 메서드는 구현 세부이므로 보통 **공개 경로**를 통해 검증하라는 권고. ([Microsoft Learn][4])
* **Exposing private state… (Enterprise Craftsmanship)**: 테스트 편의를 위해 비공개 상태를 여는 것은 안티 패턴이라는 논증. 본 장 11.2와 동일한 결론. ([Enterprise Craftsmanship][5])
* **GOOS(책)**: 객체의 메시지/행동 중심 TDD를 강조(“동작 테스트” 철학의 근간). ([oreilly.com][6], [growing-object-oriented-software.com][7], [Amazon][8])

---

## 전체 요약

* **11.1 비공개 메서드**: 테스트하지 말고, 로직을 **별도 컴포넌트로 추출**하여 **동작을 통해** 검증하라. ORM 비공개 생성자처럼 **계약 자체가 식별 가능한 동작**인 특수 케이스는 예외. \[p.371\~375] &#x20;
* **11.2 비공개 상태 노출**: 테스트만을 위해 상태/필드를 공개하지 말라. \*\*효과(출력/행동)\*\*로 검증하라. \[p.377]&#x20;
* **11.3 도메인 지식 유출**: 테스트에서 **알고리즘을 재구현하지 말라**. **하드코딩된 예시값**으로 기대를 고정해 **구현-독립성**을 확보하라. \[p.378\~380] &#x20;

---

[1]: https://testing.googleblog.com/2013/08/testing-on-toilet-test-behavior-not.html?utm_source=chatgpt.com "Testing on the Toilet: Test Behavior, Not Implementation"
[2]: https://testing.googleblog.com/2013/05/testing-on-toilet-dont-overuse-mocks.html?utm_source=chatgpt.com "Testing on the Toilet: Don't Overuse Mocks"
[3]: https://martinfowler.com/articles/mocksArentStubs.html?utm_source=chatgpt.com "Mocks Aren't Stubs"
[4]: https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-best-practices?utm_source=chatgpt.com "Best practices for writing unit tests - .NET"
[5]: https://enterprisecraftsmanship.com/posts/exposing-private-state-to-enable-unit-testing/?utm_source=chatgpt.com "Exposing private state to enable unit testing"
[6]: https://www.oreilly.com/library/view/growing-object-oriented-software/9780321574442/?utm_source=chatgpt.com "Growing Object-Oriented Software, Guided by Tests [Book]"
[7]: https://www.growing-object-oriented-software.com/?utm_source=chatgpt.com "Growing Object-Oriented Software Guided by Tests: About the ..."
[8]: https://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627?utm_source=chatgpt.com "Growing Object-Oriented Software, Guided by Tests"
