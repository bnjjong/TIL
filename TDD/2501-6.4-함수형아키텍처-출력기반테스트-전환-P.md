# 6.4 함수형 아키텍처와 출력 기반 테스트로의 전환 정리

## 6.4.1 감사 시스템 소개 (p.204~207)


- 샘플 프로젝트로 ‘조직 내 방문자 정보를 감사(audit)하는 시스템’을 다룬다.
- 방문자의 이름과 방문시간을 텍스트 파일에 기록한다.
- 각 파일 최대 기록 건수(maxEntriesPerFile)에 도달하면 새 파일 생성
  - 예: audit_1.txt, audit_2.txt, ...
- 초기 `AuditManager` 클래스는 `파일 시스템과 강하게 결합`되어 테스트가 어렵고 느림
- 테스트 시 실제 `파일을 읽고 쓰고 삭제`해야 해서 유지비가 높음
- 테스트 병렬처리도 불가능(공유 파일 의존성)
- 단위 테스트의 조건(빠른 실행, 독립성 등)을 충족하지 못함
- **표 6.2**에서 초기 버전은 “빠른 피드백”, “유지 보수성” 두 요소에서 낮은 점수 기록


| 항목          | 결과   |
|--------------|--------|
| 회귀 방지     | 좋음   |
| 리팩터링 내성 | 좋음   |
| 빠른 피드백   | 나쁨   |
| 유지 보수성   | 나쁨   |

표 6.2 감사 시스템의 초기 버전 테스트 품질 평가 (p.207)


## 6.4.2 테스트를 파일 시스템에서 분리하기 위한 목 사용 (p.207~211)


- 문제 해결을 위해 파일 시스템에 의존하는 부분을 `IFileSystem` 인터페이스로 분리하고, `AuditManager`에 주입
- 테스트 시 파일 시스템 대신 목(mock) 구현체를 사용해 테스트 환경을 독립적으로 만듦
- 이렇게 하면 테스트가 빨라지고 유지보수가 개선되나, 목 설정이 복잡할 수 있음
- 예제 6.11처럼 목 설정이 복잡해지는 점이 단점
- **표 6.3** 비교: 초기 버전 대비 “빠른 피드백” 좋아지고 “유지보수성”은 중간 수준


| 항목          | 초기 버전 | 목 사용  |
|--------------|----------|---------|
| 회귀 방지     | 좋음     | 좋음    |
| 리팩터링 내성 | 좋음     | 좋음    |
| 빠른 피드백   | 나쁨     | 좋음    |
| 유지 보수성   | 나쁨     | 중간    |

표 6.3 초기 버전 VS 목 사용 버전 품질 비교 (p.210)

## 6.4.3 함수형 아키텍처로 리팩터링하기 (p.211~218)




- 사이드 이펙트를 완전히 외부로 분리하는 함수형 아키텍처 적용
- `AuditManager`는 파일 시스템 상태(파일 내용)를 직접 받는 불변의 함수형 코어로 구현
- 실질적인 파일 읽기/쓰기 책임은 `Persister`라는 가변 셸(외부 의존성 핸들러)에 위임
- `AuditManager`는 입력값(파일 목록과 내용) 받아 처리를 수행하고, 결과(변경 명령 등)를 반환
- 부수효과(파일 쓰기 등)는 반환된 명령을 `Persister`가 수행
- 애플리케이션 진입점(외부 클라이언트와 함수형 코어 연결)을 `ApplicationService`가 담당
- 테스트가 간단해지며 목 설정 불필요, 읽기 쉽게 됨
- **표 6.4**에서 “빠른 피드백”과 “유지보수성” 모두 개선
- 결과 객체(`FileUpdate`)를 값 타입으로 만들어 값 동등 비교가 가능해지는 등 테스트 가독성 추가 향상 가능

| 항목          | 초기 버전 | 목 사용  | 함수형 코어 (출력 기반) |
|--------------|----------|---------|---------------------|
| 회귀 방지     | 좋음     | 좋음    | 좋음                |
| 리팩터링 내성 | 좋음     | 좋음    | 좋음                |
| 빠른 피드백   | 나쁨     | 좋음    | 좋음                |
| 유지 보수성   | 나쁨     | 중간    | 좋음                |

표 6.4 출력 기반 테스트 적용 후 테스트 품질 비교 (p.217)

## 6.4.4 예상되는 추가 개발 (p.218~219)

- 기존 예제는 단순한 3가지 분기뿐이지만, 실제 요구사항은 복잡할 수 있음
    - 예) 특정 방문자 삭제, 여러 파일에 걸친 변경, 파일 삭제 등
- 함수형 아키텍처는 다중 명령을 반환하도록 설계 가능 (예: 여러 `FileUpdate` 또는 `FileAction` 반환)
- 오류 처리도 함수 반환값에 함께 포함 가능 `(update, error)` 형태
- 애플리케이션 서비스가 오류를 받아 사용자에게 메시지 전달 가능

## 6.5 함수형 아키텍처의 단점 이해하기 (p.219~220)

- 모든 시스템에 함수형 아키텍처가 적합한 것은 아님
- `중간에 외부 상태(예: DB 질의 등)를 동적으로 요청`하는 경우, 함수형 순수 함수 형태 유지가 어려움=> 출력 기반 테스트 어려움
- 이런 경우는 함수형 아키텍처와 출력 기반 테스트의 한계 존재

# 요약

| 내용                      | 요약                          |
|--------------------------|-------------------------------|
| 초기 감사 시스템           | 파일 시스템에 직접 의존, 테스트 어려움, 느림, 유지보수 떨어짐                |
| 목(mock) 도입             | 파일 시스템을 인터페이스로 추상화하고 목으로 테스트, 개선되나 설정 복잡        |
| 함수형 아키텍처 적용       | 부수효과를 외부에 분리, 순수 함수형 코어 구현, 명령 객체 반환, 테스트 쉬움       |
| 비즈니스 확장성 및 오류처리 | 복잡한 변경과 오류 처리도 명령 집합 및 오류 포함 형태로 표현 가능              |
| 한계점                    | 중간에 외부의 동적 데이터 요구가 있으면 함수형, 출력 기반 테스트 어려움          |

# 참고 표 및 그림

- **그림 6.14** 함수형 코어와 가변 셸 분리 다이어그램 (p.211)
- **그림 6.15** ApplicationService와 함수형 코어, 가변 셸 관계 (p.216)

# Kotlin 예제 코드: as-is 와 to-be, Kotest 테스트포함

```kotlin
// as-is (초기 버전) - 파일 시스템과 강결합되어 테스트가 어렵고 느림
// [본문 6.4.1 감사 시스템 소개 참고 p.204~207]

import java.io.File
import java.time.LocalDateTime

class AuditManagerAsIs(
    private val maxEntriesPerFile: Int, // 파일당 최대 레코드 수
    private val directoryPath: String   // 감사 파일들이 저장된 디렉터리 경로
) {
    // 방문자 기록 추가 메서드
    fun addRecord(visitorName: String, timeOfVisit: LocalDateTime) {
        // 감사 파일 목록을 읽어온다
        val files = File(directoryPath).listFiles { 
            file -> file.name.startsWith("audit_") }
                ?.toList() 
                ?: emptyList()
        // 파일 이름에서 인덱스를 추출해 정렬
        val sortedFiles = files.sortedBy { extractIndex(it.name) }

        val newRecord = "$visitorName;${timeOfVisit}" // 새로운 방문기록 생성

        if (sortedFiles.isEmpty()) {
            // 파일이 없으면 audit_1.txt 파일을 생성하고 기록 추가
            File(directoryPath, "audit_1.txt").writeText(newRecord)
            return
        }

        val currentFile = sortedFiles.last() // 가장 최근 파일 선택
        val lines = currentFile.readLines().toMutableList()

        if (lines.size < maxEntriesPerFile) {
            // 아직 파일 내 기록 수가 한도 미만이면 새 기록 추가
            lines.add(newRecord)
            currentFile.writeText(lines.joinToString("\n"))
        } else {
            // 한도 초과 시 새로운 인덱스로 새 파일 생성
            val newIndex = extractIndex(currentFile.name) + 1
            val newFile = File(directoryPath, "audit_$newIndex.txt")
            newFile.writeText(newRecord)
        }
    }

    private fun extractIndex(filename: String): Int =
        // 파일명에서 audit_숫자.txt 형태의 숫자 부분 추출
        """audit_(\d+).txt""".toRegex()
            .find(filename)
            ?.groupValues
            ?.get(1)
            ?.toInt() 
            ?: 0
}
```


```kotlin
// to-be (함수형 아키텍처 적용) - 부수 효과를 분리, 순수 함수형 코어로 리팩터링
// [본문 6.4.3 함수형 아키텍처로 리팩터링하기 참고 p.211~218]

// 파일명과 내용 리스트를 가진 불변 객체
data class FileContent(val fileName: String, val lines: List<String>)

// 파일 업데이트 명령 객체 - 변경할 파일명과 파일 내용 포함
data class FileUpdate(val fileName: String, val newContent: String)

class AuditManager(
    private val maxEntriesPerFile: Int // 한 파일에 저장할 최대 항목 수
) {
    /**
     * 감사 기록 추가 함수: 기존 파일 상태를 입력받아
     * 방문자 기록을 추가한 후, 새로 업데이트 할 파일 정보 반환
     * (순수 함수 - 부수효과 없음)
     */
    fun addRecord(
        files: List<FileContent>,      // 현재 디렉토리 내 파일과 내용 리스트
        visitorName: String,           // 신규 방문자의 이름
        timeOfVisit: LocalDateTime    // 방문 시간
    ): FileUpdate {
        // 파일이름에서 인덱스 추출 후 정렬
        val sorted = files.sortedBy { extractIndex(it.fileName) }
        val newRecord = "$visitorName;${timeOfVisit}"

        if (sorted.isEmpty()) {
            // 파일이 없으면 audit_1.txt 신규 생성과 기록 반환
            return FileUpdate("audit_1.txt", newRecord)
        }

        val (currentIndex, currentFile) = sorted.last().let { extractIndex(it.fileName) to it }
        val lines = currentFile.lines.toMutableList()

        return if (lines.size < maxEntriesPerFile) {
            // 기존 파일에 항목 여유가 있으면 추가 후 내용 반환
            lines.add(newRecord)
            FileUpdate(currentFile.fileName, lines.joinToString("\n"))
        } else {
            // 기존 파일이 가득 찼으면 인덱스 +1 파일 생성
            val newIndex = currentIndex + 1
            FileUpdate("audit_$newIndex.txt", newRecord)
        }
    }

    private fun extractIndex(filename: String): Int =
        // audit_숫자.txt에서 숫자 부분을 추출
        """audit_(\d+).txt""".toRegex()
            .find(filename)
            ?.groupValues
            ?.get(1)
            ?.toInt() 
            ?: 0
}

// 실제 파일 읽기/쓰기 담당 가변 셸 클래스
class Persister {
    // 디렉터리 내 audit_파일명으로 시작하는 파일 목록과 내용 읽기
    fun readDirectory(directoryPath: String): List<FileContent> {
        val dir = java.io.File(directoryPath)
        return dir.listFiles { f -> f.name.startsWith("audit_") }?.map {
            FileContent(it.name, it.readLines())
        } ?: emptyList()
    }

    // 파일 업데이트 명령을 실제 파일 시스템에 적용
    fun applyUpdate(directoryPath: String, update: FileUpdate) {
        val file = java.io.File(directoryPath, update.fileName)
        file.writeText(update.newContent)
    }
}

// 외부 클라이언트와 함수형 코어(Persister, AuditManager)를 연결하는 애플리케이션 서비스
class ApplicationService(
    private val directoryPath: String,
    private val maxEntriesPerFile: Int
) {
    private val auditManager = AuditManager(maxEntriesPerFile)
    private val persister = Persister()

    // 방문자 기록 추가 기능 호출
    fun addRecord(visitorName: String, timeOfVisit: LocalDateTime) {
        val files = persister.readDirectory(directoryPath)  // 현재 파일 목록 읽기
        val update = auditManager.addRecord(files, visitorName, timeOfVisit)  // 순수 함수 처리
        persister.applyUpdate(directoryPath, update)  // 부수효과 실행(파일 쓰기)
    }
}

```

# 참고할만한 인터넷 자료 (함수형 아키텍처, 테스트 디자인 관련)

- **Martin Fowler : Functional Core, Imperative Shell** (https://martinfowler.com/articles/functional-core-imperative-shell.html)  
  → 함수형 코어와 명령형 셸을 분리하는 개념 설명
- **Microsoft Docs : Clean Architecture**  
  → 함수형 아키텍처 및 육각형 아키텍처를 포함한 클린 아키텍처 관련 설명
- **Testing with Mocks: What and When to Mock?** (블로그/강의 다수 존재)  
  → Mock 객체를 현명하게 사용하는 방법 학습에 도움됨
- **Kotest 공식 문서** (https://kotest.io)  
  → Kotlin용 강력한 테스트 프레임워크로 실제 프로젝트 테스트 작성법 참고

