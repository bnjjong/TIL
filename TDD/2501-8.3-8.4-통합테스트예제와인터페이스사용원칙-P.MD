## 챕터 8.3~8.4 정리 (페이지 주석 포함)

***

### 8.3 통합 테스트: 예제와 의존성 관리
#### 8.3.1 어떤 시나리오를 테스트할까? (p281)
- CRM 시스템 사용자 이메일 변경 기능 예제.
- **가장 긴 주요 흐름**은 '기업 이메일에서 일반 이메일'로 변경하는 과정.
- 데이터베이스(User, Company) 업데이트 및 메시지 버스 전송이 동시에 발생.

#### 8.3.2 데이터베이스와 메시지 버스 분류하기 (p283)
- 통합 테스트의 프로세스 외부 의존성 분류:
    - **관리 의존성**: 실제 DB 인스턴스 사용 (ex: Database)
    - **비관리 의존성**: 목(Mock)으로 대체 (ex: MessageBus)

#### 8.3.3 엔드 투 엔드 테스트와 통합 테스트 차이 (p284)
- **엔드 투 엔드 테스트**: 실제 배포 환경에서 모든 외부 의존성과의 상호작용 테스트.
    - 모든 의존성을 실제 환경 사용.
- **통합 테스트**: 프로세스 외부 의존성 중 관리 의존성(주로 DB)은 실제로, 비관리는 목으로 대체하여 동일 프로세스 내에서 테스트.

#### 8.3.4 통합 테스트 예제 (p286)
- DB, 메시지 버스 등 프로세스 외부 의존성을 명확히 구분하여, 핵심 플로우/사이드이펙트 검증.
- 헬퍼 함수로 테스트 코드 중복 최소화.
- 데이터 검증은 DB에서 직접 읽어, 컨트롤러 내부적인 동작 역시 검토.

#### 내 생각 (8.3)
> DB/메시지버스처럼 복잡한 의존성은 “관리/비관리”로 나누면, 테스트 설계가 손쉬워집니다. 실 DB를 통한 검증이 진짜 중요한 회귀방지 효과를 줍니다. 실 환경을 흉내내는 것이 아니라, 실제 중요한 플로우를 빠짐없이 검증하는 데 집중하세요.

***

### 8.4 의존성 추상화를 위한 인터페이스 사용 (p287)
#### 8.4.1 인터페이스와 느슨한 결합
- 일반적으로 외부 의존성에 인터페이스를 쓰는 이유:
    - 느슨한 결합, OCP 실현으로 설명하지만 이는 오해!
    - 구현이 하나뿐일 때는 추상화의 가치가 거의 없음.
    - YAGNI 원칙 위배: 미래에 필요할지 모르는 기능을 미리 만들지 말 것.
    > 개인적인 생각은 어쨌든 변경의 가능성이 있는 곳에 다 인터페이스로 설계하는 것이 좋다. 생산성은 AI가 책임질 것.

#### 8.4.2 진짜 이유: 테스트 목을 위한 인터페이스
- 목(Mock) 대체를 위해서 인터페이스가 필요.
    - 관리 의존성(DB 등)은 인터페이스 불필요, 실제 클래스 주입.
    - 비관리 의존성(메시지버스 등)은 인터페이스 도입.

#### 8.4.3 프로세스 내부 의존성에 인터페이스 필요 X
- 도메인 모델 내부 상호작용은 목으로 검증하지 말 것(테스트 깨지기 쉬워지고 리팩터링 방지력 저하).
- 내부 모델에 단일 구현 인터페이스 도입은 바람직하지 않음.

#### 내 생각 (8.4)
> 불필요한 인터페이스 남발은 코드 복잡도만 증가시킵니다. 테스트 목적이 아니라면, 단일 구현에 인터페이스를 넣지 마세요. 실질적 추상화/대체 필요가 있는 경우에만 인터페이스를 도입하세요.

***

## 참고 그림 (직접 작성)

### [엔드 투 엔드 vs 통합 테스트 구조]
|                            | 엔드 투 엔드 테스트             | 통합 테스트                   |
|----------------------------|-------------------------------|------------------------------|
| 범위                       | 배포된 전체 시스템             | 동일 프로세스 내 일부        |
| 외부 의존성 (DB 등)         | 실제 환경 사용                | 관리 의존성만 실제 환경 사용 |
| 비관리 의존성 (메시지 버스) | 실제 환경 사용                | 목(Mock) 사용                |
| 검증 방식                  | 전체 플로우, 간접 DB 확인      | 주요 플로우, 직접 DB 확인    |
| 목적                       | 배포 후 시스템 점검            | 안전한 회귀방지/모듈 검증    |

***

## 예제 코드 (as-is -> to-be, 비지니스 도메인 기반, Kotlin & Kotest)

### 1. As-is: 의존성 분리 없이 한 클래스에서 모두 직접 관리
```kotlin
// (p282) Controller가 구체 클래스를 직접 생성해서 사용
class UserController {
    private val database: Database = Database()
    private val messageBus: MessageBus = MessageBus()

    fun changeEmail(userId: Int, newEmail: String): String {
        val userData = database.getUserById(userId)
        val user = UserFactory.create(userData)
        val error = user.canChangeEmail()
        if (error != null) return error

        val companyData = database.getCompany()
        val company = CompanyFactory.create(companyData)
        user.changeEmail(newEmail, company)

        database.saveCompany(company)
        database.saveUser(user)
        for (ev in user.emailChangedEvents) {
            messageBus.sendEmailChangedMessage(ev.userId, ev.newEmail)
        }
        return "OK"
    }
}
```
#### [내 생각]
> 이렇게 모든 의존성을 직접 관리하면 테스트가 어렵고 유연성이 낮아집니다.

***

### 2. To-be: 의존성 주입 & 목(Mocking) 사용 (테스트 편의성, 유연성 강화)
```kotlin
// 관리 의존성(Database)는 실제 클래스를 주입, 비관리(MessageBus)는 인터페이스 주입
class UserController(
    private val database: Database,         // 실제 DB
    private val messageBus: IMessageBus     // 목 교체 가능한 인터페이스
) {
    fun changeEmail(userId: Int, newEmail: String): String {
        val userData = database.getUserById(userId)
        val user = UserFactory.create(userData)
        val error = user.canChangeEmail()
        if (error != null) return error

        val companyData = database.getCompany()
        val company = CompanyFactory.create(companyData)
        user.changeEmail(newEmail, company)

        database.saveCompany(company)
        database.saveUser(user)
        for (ev in user.emailChangedEvents) {
            messageBus.sendEmailChangedMessage(ev.userId, ev.newEmail)
        }
        return "OK"
    }
}

// IMessageBus 인터페이스
interface IMessageBus {
    fun sendEmailChangedMessage(userId: Int, newEmail: String)
}
```
***

### 3. 통합 테스트 예제 (Kotlin, Kotest)
```kotlin
import io.mockk.mockk
import io.mockk.verify
import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.shouldBe

class UserControllerIntegrationTest : StringSpec({
    "기업 이메일에서 일반 이메일로 변경시 DB와 메시지버스 모두 검증" {
        // 실제 DB, 목(MessageBus) 준비
        val db = Database(/* connection info */)
        val messageBusMock = mockk(relaxed = true)

        // 데이터 생성
        val user = createUser("user@mycorp.com", UserType.EMPLOYEE, db)
        createCompany("mycorp.com", 1, db)

        val controller = UserController(db, messageBusMock)

        // 이메일 변경 실행
        val result = controller.changeEmail(user.userId, "new@gmail.com")
        result shouldBe "OK"

        // DB 상태 검증
        val userFromDb = db.getUserById(user.userId).let { UserFactory.create(it) }
        userFromDb.email shouldBe "new@gmail.com"
        userFromDb.type shouldBe UserType.CUSTOMER

        val companyFromDb = db.getCompany().let { CompanyFactory.create(it) }
        companyFromDb.numberOfEmployees shouldBe 0

        // 메시지버스 Mock 동작 검증
        verify(exactly = 1) { messageBusMock.sendEmailChangedMessage(user.userId, "new@gmail.com") }
    }
})
```
#### [내 생각]
> 관리/비관리 의존성을 명확히 구분 & Mock 활용하면, 실제 DB로 회귀 방지, 메시지는 Mock으로 간소화, 테스트 안정성 및 생산성을 높일 수 있습니다.

***

## 챕터별 요약 (압축)

- **8.3**: 통합 테스트에서는 관리 의존성(DB 등)은 실제로, 비관리 의존성(메시지버스 등)은 Mock으로 처리. 핵심 플로우와 회귀 방지 효과가 생명. 테스트코드는 실제 DB 상태 확인하는 것이 필수.
- **8.4**: 외부 의존성에 인터페이스를 붙이는 이유는 오로지 테스트 시 Mock 교체 때문. 단일 구현에 불필요한 추상화/인터페이스 남용하지 말 것. 내부 모델 상호작용엔 인터페이스 도입 없이 구체 클래스로.

***

## 인터넷 참고 자료 요약

- [통합 테스트 전략과 목(Mock) 사용법](https://moldstud.com/articles/p-integration-testing-strategies-for-kotlin-apps):[1]
  - 외부 의존성(Mock/Stub/Fake)으로 대체해 테스트 안정성 확보.
  - 핵심 플로우, 실제 DB를 통한 검증, 자동화된 파이프라인 통합이 중요.
  - 실제 사례와 모범 사례 다수 제시.

- [Best Practices for Integration Testing in Kotlin](https://blog.codeminer42.com/the-acceptable-way-to-integration-tests-with-spring-and-kotlin/):[2]
  - 테스트마다 DB 정리, 목(MockMvc)로 컨트롤러부터 DB까지 전체 흐름 검증.
  - Mock 활용으로 외부 API/메시지버스 간편하게 대체.

- [Integration Testing Deep Dive (Kotlin, Spock, Spring Boot)](https://www.schibsted.pl/blog/integration-testing-deep-dive-part-i/):[3]
  - 관리와 비관리 의존성을 구분, 실제 환경과 유사하게 검증하는 통합 테스트 구조 설명.

***

[1] https://moldstud.com/articles/p-integration-testing-strategies-for-kotlin-apps
[2] https://blog.codeminer42.com/the-acceptable-way-to-integration-tests-with-spring-and-kotlin/
[3] https://www.schibsted.pl/blog/integration-testing-deep-dive-part-i/
[4] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/32004849/6ffe92ae-473d-4e4b-a5e9-27c2f87daecf/2501-danwi-teseuteu-pages-273-283.pdf
[5] https://stackoverflow.com/questions/70508762/kotlin-springboot-mockito-integration-test-entitymanger
[6] https://www.reddit.com/r/Kotlin/comments/1cz2snl/ktor_unit_tests_and_mocking_exposed/
[7] https://developer.android.com/training/data-storage/room/testing-db
[8] https://docs.spring.io/spring-integration/reference/testing.html
[9] https://www.testingmind.com/system-integration-testing-best-practices-benefits-and-the-right-approach/
[10] https://stackoverflow.com/questions/60240557/android-integration-test-mocking-the-logic-method-in-within-an-activity-using
[11] https://dev.to/ruben_alapont/testing-strategies-in-domain-driven-design-ddd-2d93
[12] https://phauer.com/2019/focus-integration-tests-mock-based-tests/
[13] https://www.schibsted.pl/blog/integration-testing-deep-dive-part-ii/
[14] https://www.frugaltesting.com/blog/integration-testing-comprehensive-guide-and-best-practices
[15] https://www.baeldung.com/kotlin/spring-boot-testing
[16] https://proandroiddev.com/write-unit-tests-and-ui-tests-in-your-kotlin-multiplatform-app-472c27625b5a
[17] https://research.aimultiple.com/integration-testing-best-practices/
[18] https://slack-chats.kotlinlang.org/t/16777935/in-ktor-is-it-possible-to-make-an-integration-test-that-invo
[19] https://www.opkey.com/blog/integration-testing-a-comprehensive-guide-with-best-practices
[20] https://phauer.com/2018/best-practices-unit-testing-kotlin/
[21] https://www.qamadness.com/best-practices-for-integration-testing/