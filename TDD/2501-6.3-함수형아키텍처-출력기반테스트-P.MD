## 6.3 함수형 아키텍처 이해

### 6.3.1 함수형 프로그래밍이란?  [195~198p]
- **함수형 프로그래밍(Functional Programming)**: 수학적 함수(=순수 함수)를 이용한 프로그래밍 방법이다.
    - **수학적 함수(=순수 함수, pure function)**란?
        - 숨은 입출력이 없다 (즉, 모든 입력/출력은 메서드 시그니처에 노출됨)
        - 동일한 입력에 대해 항상 동일한 출력을 반환  
- **예시:**
    ```csharp
    public decimal CalculateDiscount(Product[] products) {
        decimal discount = products.Length * 0.01m;
        return Math.Min(discount, 0.2m);
    }
    ```
    - 입력(Product[]), 출력(decimal)이 모두 명확하다 ⇒ 순수 함수가 된다.
- **숨은 입출력의 예**
    - **사이드 이펙트:** 객체 상태 변경, 파일/DB 조작 등
    - **예외:** 예상하지 못한 경로(시그니처에 명시 안 됨)
    - **내/외부 상태 참조:** DateTime.Now, 정적 변수 등
- **참조 투명성(Referential Transparency)**
    - “메서드 호출”을 “반환값”으로 아무런 의미 변화 없이 치환할 수 있으면 수학적 함수다.

### 6.3.2 함수형 아키텍처란?  [199~201p]
- **목표:** 사이드 이펙트 제거가 아니라, “비즈니스 로직”과 “사이드 이펙트” 함수 분리!
    - *함수형 코어* (Functional Core / 불변 코어): 결정 로직(순수 함수로 만듦)
    - *가변 셸* (Mutable Shell): 실제 상태 변경, 외부 시스템과 통신 담당
- **장점:**
    - 함수형 코어는 출력 기반 테스트(단순, 빠름, 유지보수성 ↑)
    - 가변 셸은 통합/엔드투엔드 등 적은 수의 테스트에 집중
- **캡슐화 vs 불변성**
    - **캡슐화:** 변경 지점 최소화(=상태 혼선 방지)
    - **불변성:** 애초에 변경 불가 ⇒ 복잡성 감소, 테스트/이해 쉬움

### 6.3.3 함수형 아키텍처와 육각형 아키텍처 비교  [202~203p]
- **육각형 아키텍처(헥사고날/HAT):**
    - *도메인 계층*: 비즈니스 로직
    - *애플리케이션 서비스 계층*: 외부시스템 연동
- **함수형 아키텍처와의 공통점**
    - 관심사 분리(결정 vs 실행)
    - 내부 의존성은 계층 내부/단방향
    - 테스트 용이성(외부 입력 만으로 순수코어 테스트)
- **차이점**
    - 함수형 아키텍처는 **비즈니스 연산의 “가장자리”로** 사이드 이펙트를 완전히 밀어낸다.
    - 육각형 아키텍처는 도메인 계층 내에서 “상태 변경” 허용
- **정리:** 함수형 아키텍처는 육각형 아키텍처의 하위 집합 또는 좀 더 극단적으로 “분리”지향적임.

## 요약  
함수형 아키텍처는 ‘순수 함수’(입출력 명확/사이드 이펙트 없음)로 작성된 비즈니스 로직(코어)과, 실제로 외부 시스템과 통신하거나 상태를 바꾸는 코드(셸)를 명확히 분리한다. 이 덕분에 테스트가 단순·명료해지고, 유지보수성이 높아진다. 육각형 아키텍처와 유사하나, 함수형 아키텍처는 사이드 이펙트의 위치를 더 철저히 규정하며 도메인 로직 내 불변성을 강조한다. (195~203p)

## AS-IS → TO-BE 예제 코드 (Kotlin, 도메인 적용, 테스트 포함)

**도메인: 사내 방문자 기록(Visitor Audit System)**  
- AS-IS: 클래스 내부 상태(리스트, 파일 등) 조작, 사이드이펙트 O  
- TO-BE: 방문 로직은 순수 함수화! 데이터 저장은 외부에서(셸에서) 처리

### 1. AS-IS (상태 기반, 사이드 이펙트 O)
```kotlin
// AS-IS: "숨은 입출력/상태"에 의존하는 방문자 기록
class VisitorAuditService {
    private val visits = mutableListOf()

    fun addVisit(visitorName: String, visitTime: String): VisitLog {
        val log = VisitLog(visitorName, visitTime)
        visits.add(log) // 사이드 이펙트: 내부 상태 변경
        // 실제로는 파일에 저장할 수도 있음
        return log
    }

    fun getVisitCount(): Int = visits.size
}

data class VisitLog(val name: String, val time: String)
```

#### AS-IS 테스트 (상태 기반)
```kotlin
import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.shouldBe

class VisitorAuditServiceTest : StringSpec({
    "방문 기록을 추가하면 갯수가 증가한다" {
        val service = VisitorAuditService()
        service.addVisit("홍길동", "2023-10-27")
        service.addVisit("이순신", "2023-10-28")
        service.getVisitCount() shouldBe 2 // 상태를 검사!
    }
})
```
---
### 2. TO-BE (함수형 아키텍처, 순수 함수/출력 기반 테스트)

**a. 도메인 순수 함수 (코어)**

```kotlin
// TO-BE: 입력 → 출력만 있는 "방문 기록 결정" 순수 함수로 분리
data class VisitLog(val name: String, val time: String)

object VisitDecisionCore {
    // 순수 함수: side effect X
    fun decideVisitLog(visitorName: String, visitTime: String): VisitLog =
        VisitLog(visitorName, visitTime)
}
```

**b. 가변 셸 (외부 저장 및 이펙트)**
```kotlin
// 가변 셸: 순수 함수 결과를 실제 저장소로 넘김(파일, DB 등)
class VisitLogRepository {
    private val storage = mutableListOf()
    
    fun save(log: VisitLog) {
        storage.add(log)
        // 실제 환경에선 파일/DB에 저장
    }

    fun count(): Int = storage.size
}
```

**c. 서비스 조합**
```kotlin
class VisitService(private val repository: VisitLogRepository) {
    fun registerVisit(visitorName: String, visitTime: String) {
        val visitLog = VisitDecisionCore.decideVisitLog(visitorName, visitTime)
        repository.save(visitLog)
    }
}
```

**d. TO-BE 테스트 (출력 기반, 순수 함수만 테스트)**
```kotlin
import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.shouldBe

class VisitDecisionCoreTest : StringSpec({
    "방문 기록 결정은 입력에 대해 동일한 출력을 낸다" {
        val result = VisitDecisionCore.decideVisitLog("홍길동", "2023-10-27")
        result shouldBe VisitLog("홍길동", "2023-10-27")
    }
})
```
**e. 셸/리포지토리 등은 최소한의 통합 테스트만 작성**
```kotlin
class VisitServiceIntegrationTest : StringSpec({
    "방문자 등록 후 저장소에 기록된다" {
        val repository = VisitLogRepository()
        val service = VisitService(repository)

        service.registerVisit("홍길동", "2023-10-27")
        repository.count() shouldBe 1
    }
})
```
---

## 결론  
- 함수형 아키텍처로의 전환은 비즈니스 결정 로직을 **순수 함수**로 분리해 출력 기반 테스트가 가능하도록 만든다.
- 실제 사이드 이펙트(저장, 전송 등)는 따로 분리된 “가변 셸”이 담당한다.
- 기존(AS-IS)과 비교 시, 테스트가 본질적으로 단순‧명확해지고 유지보수성이 높아지는 점이 핵심적 차이이다.

## 관련 참고자료(외부)
- Scott Wlaschin, [fsharpforfunandprofit.com/books](https://fsharpforfunandprofit.com/books) (원저자 사이트)
- 마틴 파울러, [Functional Core, Imperative Shell](https://martinfowler.com/bliki/FunctionalCoreImperativeShell.html)
- Kotlin 공식 문서의 [함수형 프로그래밍 가이드]



### 내 생각
계속해서 강조하는 원칙은 몇가지 안된다는 생각이 든다.
1. Solid를 준수하라.
2. FP의 pure function은 TDD 기반에서 여러가지 이점을 준다.
    1. 단 모든 application 코드를 pure function으로 구성할 수 없으니 최대한 분리하자. 
3. 결국은 비지니스 로직에서 불변의 기능을 잘 추출하여 코드에 반영하는 것이 핵심인듯 하다.

[1] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/32004849/3a1f7e3a-f390-4447-9c24-09387db38982/tdd6-3.pdf