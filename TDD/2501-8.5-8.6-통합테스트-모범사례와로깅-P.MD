## 8.5 통합 테스트 모범 사례

### 8.5.1 도메인 모델 경계 명시하기

* 도메인 모델은 `“문제를 해결하는 지식의 모음”`이므로 코드베이스의 **명시적이고 잘 알려진 위치**에 두어라. 이렇게 해야 단위 테스트(도메인/알고리즘)와 통합 테스트(컨트롤러)의 경계를 선명하게 구분할 수 있다. \[p.291]&#x20;
* 도메인 로직이 하나의 우산 아래에 있고 여기저기 흩어지지 않게 하라(어셈블리/네임스페이스 등 구조는 자유). \[p.291–292]&#x20;

> **내 생각**: 테스트 전략(단위 vs 통합)을 결정하는 기준은 “경계”다. 도메인 경계가 선명할수록 테스트 스위트가 단단해진다.
> 🤔 일을 하다 보면 도메인 모델과 서비스 레이어서 분산 되는 부분도 있다. 최대한 도메인안으로 넣긴 하겠지만 도메인안으로 모이도록 지향해야 겠다.

---

### 8.5.2 계층 수 줄이기

* 간접 계층을 늘리면 **추론 난이도**가 급격히 올라가고, 컨트롤러↔도메인 사이의 경계도 흐려진다. 그러면 각 계층을 따로 검증하려는 유혹이 커지고, 리팩터링 내성이 낮아진다. \[p.292–294]&#x20;
* 대부분의 백엔드에선 **세 계층이면 충분**: 도메인, 애플리케이션 서비스(컨트롤러), 인프라. \[p.293]&#x20;

#### 표: 권장 계층 요약(그림 8.10 재구성)

| 계층               | 주요 책임             | 비고             |
| ---------------- | ----------------- | -------------- |
| 도메인              | 불변식, 규칙, 상태 전이    | 단위 테스트 대상      |
| 애플리케이션 서비스(컨트롤러) | 유스케이스 조정, 트랜잭션 경계 | 통합 테스트 대상      |
| 인프라              | DB, 메시지버스, 외부 API | 테스트에선 대개 목/페이크 |

> **내 생각**: “추상 계층”은 빚이다. 필요할 때 **최소한으로** 도입하자.
> 🤔 일반적으로 계층은 3개가 맞다. 근데 간접 계층이라는게 뭘 의미하는건지 모르겠다. 앞서 설명한 헥사고날은 추상계층을 적극적으로 활용하는 패턴인데.. 음..
---

### 8.5.3 순환 의존성 제거하기

* 순환 의존성(서로를 직‧간접 의존)은 코드를 이해하기 어렵게 하고, 동작 단위를 고립해 테스트하기도 어렵게 만든다. \[p.294–295]&#x20;
* **인터페이스로 가리는 건 임시방편**일 뿐, 런타임 순환은 여전하다(그림 8.11). 근본 해결은 **호출 구조를 바꿔** 결과를 반환하도록 리팩터링하는 것. \[p.295–296]&#x20;

> **내 생각**: “콜백으로 되돌아오기”는 특히 위험하다. 가능하면 **단방향 흐름**을 유지하자.
> 완벽하게 동의한다. 무조건 단방향으로 흐르도록 설계 해야 된다. 

---

### 8.5.4 테스트에서 다중 실행(when) 구절 금지

* 하나의 테스트에 실행 구절을 여러 개 두면(**등록 후 삭제** 같은 흐름) 금방 **초점이 흐려지고 거대**해진다. 유스케이스별로 **테스트를 분리**하라. \[p.297]&#x20;
* 예외적으로, 느리거나 호출 제한이 있는 외부 의존성(샌드박스 등) 때문에 상호작용 횟수를 줄여야 할 때만 다단계 통합/엔드투엔드 테스트를 고려한다. \[p.297]&#x20;

> **내 생각**: 실행 한 번, 검증 한 번. **작고 선명한 테스트**가 유지보수의 핵심이다.

---

## 8.6 로깅 기능을 테스트하는 방법

### 8.6.1 로깅을 테스트해야 하는가?

* 로깅은 **횡단 관심사**다. 하지만 테스트 대상인지 여부는 “**식별할 수 있는 동작**인가(외부 이해관계자가 본다) vs **구현 세부**인가(개발자만 본다)”로 결정하자. 전자라면 테스트, 후자(진단 로그)라면 테스트하지 않는다. \[p.299]&#x20;
* 프리먼/프라이스는 로깅을 **지원 로깅**(운영/지원용)과 **진단 로깅**(개발자용)으로 구분한다. \[p.299–300]&#x20;

> **내 생각**: “누가 이 로그를 보나?”를 먼저 묻자. 대상이 비개발자면 **테스트 대상**이다.

---

### 8.6.2 어떻게 테스트할까? (DomainLogger)

* 로깅도 결국 **프로세스 외부 의존성**(파일/DB)이므로 상호작용 검증엔 목을 쓴다. 다만 **ILogger 자체를 목**으로 하지 말고, \*\*비즈니스 용어가 드러나는 래퍼(DomainLogger)\*\*를 두고 그것과의 상호작용을 검증하라. \[p.300–301] &#x20;
* 이 래퍼는 **구조화 로깅**처럼 “메시지 템플릿 + 파라미터(데이터)”를 분리해 다룬다. JSON/CSV 등 **여러 렌더링**으로 확장 가능하다(그림 8.12). \[p.302–303] &#x20;
* 단, DomainLogger를 **도메인 엔터티에 직접 주입**하면 도메인이 외부 의존성과 결탁되어 복잡도가 증가한다. 해결책은 **도메인 이벤트**로 분리하고, 컨트롤러/디스패처에서 DomainLogger를 호출하는 것(지원 로깅 테스트는 다른 비관리 의존성과 동일하게 다루기). \[p.304–306]&#x20;

> **내 생각**: “로깅도 도메인 언어로.” 하지만 **도메인 밖**(컨트롤러/디스패처)에서 호출하자.

---

### 8.6.3 로깅은 얼마나 해야 충분한가?

* **진단 로그 남발 금지**: 코드(특히 도메인)를 혼란스럽게 하고, **신호/잡음 비율**을 나쁘게 만든다. 필요 시 **일시적**으로만 쓰고 제거하라. 처리되지 않은 예외 중심으로. \[p.307–308]&#x20;

> **내 생각**: 진단 로그는 “가로등”이 아니라 “손전등”이다. **필요할 때만 켰다가 끈다.**

---

### 8.6.4 로거 인스턴스 전달하기

* 정적 접근자/정적 필드(앰비언트 컨텍스트)로 로거를 얻는 패턴은 **안티패턴**: 의존성이 숨고, 테스트가 어려워지며, 잠재적 설계 문제를 가린다. \[p.307–308]&#x20;
* **명시적 주입**(메서드 인수/생성자)을 사용하라. \[p.308]&#x20;

> **내 생각**: “편해서 정적”은 금물. **명시적 주입**이 설계를 투명하게 한다.

---

## (참고 표) 그림 8.12 재구성: 구조화 로깅의 생각법

| 단계  | 의미                      | 예시                                                                              |
| --- | ----------------------- | ------------------------------------------------------------------------------- |
| 캡처  | 템플릿 + 파라미터로 “데이터” 수집    | `"User {id} changed type from {old} to {new}"` + `(12, "Customer", "Employee")` |
| 렌더링 | 파일/JSON/CSV 등 다양한 출력 형식 | 평문 로그 / `{"MessageTemplate":"...","id":12,...}` / `MessageTemplate,id,old,new`  |

\[p.302–303] &#x20;

---

# 샘플 코드 (도메인 포함, Kotlin)

아래 예제는 **광고 도메인**을 가정합니다. 캠페인 상태 변경 시 **지원 로깅**을 남긴다는 요구(비즈니스)가 있고, 이를 **as-is(도메인에 로거 침투)** → \*\*to-be(도메인 이벤트 + 디스패처)\*\*로 개선합니다.

## AS-IS: 도메인에 DomainLogger가 침투한 설계 (권장 X)

```kotlin
// 도메인 용어로 감싼 지원 로깅 래퍼
interface DomainLogger {
    fun campaignStatusChanged(campaignId: Long, old: CampaignStatus, new: CampaignStatus)
}

enum class CampaignStatus { DRAFT, ACTIVE, PAUSED, ENDED }

data class Campaign(
    val id: Long,
    var status: CampaignStatus,
    // ❌ 도메인에 외부 의존성 침투
    private val domainLogger: DomainLogger
) {
    fun changeStatus(to: CampaignStatus) {
        if (status == to) return
        val old = status
        status = to
        // 비즈니스(지원) 로그
        domainLogger.campaignStatusChanged(id, old, to)
    }
}
```

```kotlin
// AS-IS 통합 테스트 (목으로 상호작용 확인) — 가능하지만 도메인 결탁이 심함
class CampaignAsIsTest : io.kotest.core.spec.style.StringSpec({
    "상태 변경 시 지원 로그가 기록된다(AS-IS)" {
        val calls = mutableListOf<Triple<Long, CampaignStatus, CampaignStatus>>()
        val logger = object : DomainLogger {
            override fun campaignStatusChanged(campaignId: Long, old: CampaignStatus, new: CampaignStatus) {
                calls += Triple(campaignId, old, new)
            }
        }
        val campaign = Campaign(1L, CampaignStatus.DRAFT, logger)

        campaign.changeStatus(CampaignStatus.ACTIVE)

        calls.single() shouldBe Triple(1L, CampaignStatus.DRAFT, CampaignStatus.ACTIVE)
    }
})
```

> **문제점(책 8.6.2 지적과 동일)**: 도메인이 외부 의존성과 결탁되어 복잡해지고 테스트/유지보수가 어려워진다. → **도메인 이벤트로 분리**하자.&#x20;

---

## TO-BE: 도메인 이벤트 + 디스패처(컨트롤러/서비스에서 지원 로깅)

```kotlin
// 1) 도메인 이벤트 정의 (도메인 순수 유지)
interface DomainEvent
data class CampaignStatusChangedEvent(
    val campaignId: Long,
    val old: CampaignStatus,
    val new: CampaignStatus
) : DomainEvent

// 2) 도메인 엔터티 (외부 의존성 X)
data class Campaign(
    val id: Long,
    var status: CampaignStatus,
    val domainEvents: MutableList<DomainEvent> = mutableListOf()
) {
    fun changeStatus(to: CampaignStatus) {
        if (status == to) return
        val old = status
        status = to
        domainEvents += CampaignStatusChangedEvent(id, old, to) // 도메인 이벤트 적재
    }
}

// 3) 애플리케이션 계층: 이벤트 디스패처가 DomainLogger를 호출
class EventDispatcher(private val domainLogger: DomainLogger) {
    fun dispatch(events: List<DomainEvent>) {
        events.forEach {
            when (it) {
                is CampaignStatusChangedEvent -> domainLogger.campaignStatusChanged(it.campaignId, it.old, it.new)
                // 다른 이벤트 매핑...
            }
        }
    }
}

// 4) 애플리케이션 서비스(컨트롤러 역할)
class CampaignService(
    private val repo: CampaignRepository,
    private val dispatcher: EventDispatcher
) {
    fun activate(id: Long) {
        val c = repo.findById(id) ?: throw IllegalArgumentException("not found")
        c.changeStatus(CampaignStatus.ACTIVE)
        repo.save(c)
        dispatcher.dispatch(c.domainEvents) // ✅ 지원 로깅은 여기서
        c.domainEvents.clear()
    }
}

// 인프라/저장소 포트
interface CampaignRepository {
    fun findById(id: Long): Campaign?
    fun save(campaign: Campaign)
}
class InMemoryCampaignRepository : CampaignRepository {
    private val store = mutableMapOf<Long, Campaign>()
    override fun findById(id: Long) = store[id]
    override fun save(campaign: Campaign) { store[campaign.id] = campaign }
}
```

```kotlin
// TO-BE: 단위 테스트 — 도메인은 이벤트만 방출하면 된다
class CampaignToBeUnitTest : io.kotest.core.spec.style.StringSpec({
    "도메인은 상태 변경 이벤트만 방출한다" {
        val campaign = Campaign(1L, CampaignStatus.DRAFT)

        campaign.changeStatus(CampaignStatus.ACTIVE)

        campaign.domainEvents.single() shouldBe CampaignStatusChangedEvent(
            1L, CampaignStatus.DRAFT, CampaignStatus.ACTIVE
        )
    }
})
```

```kotlin
// TO-BE: 통합 테스트 — 컨트롤러(서비스)와 DomainLogger 상호작용 검증
class CampaignToBeIntegrationTest : io.kotest.core.spec.style.StringSpec({
    "서비스는 이벤트를 DomainLogger 호출로 변환한다(지원 로깅 테스트)" {
        val repo = InMemoryCampaignRepository().apply { save(Campaign(1L, CampaignStatus.DRAFT)) }
        val calls = mutableListOf<Triple<Long, CampaignStatus, CampaignStatus>>()
        val logger = object : DomainLogger {
            override fun campaignStatusChanged(campaignId: Long, old: CampaignStatus, new: CampaignStatus) {
                calls += Triple(campaignId, old, new)
            }
        }
        val service = CampaignService(repo, EventDispatcher(logger))

        service.activate(1L)

        calls.single() shouldBe Triple(1L, CampaignStatus.DRAFT, CampaignStatus.ACTIVE)
        repo.findById(1L)!!.status shouldBe CampaignStatus.ACTIVE
    }
})
```

> 이 구조는 책의 “도메인 이벤트→컨트롤러/디스패처에서 외부 의존성 호출” 권고와 동일하다. \[p.304–306]&#x20;

---

# 요약

* **8.5 모범 사례**: (1) 도메인 경계 명시, (2) 계층 최소화(도메인/애플리케이션/인프라 3계층), (3) 순환 의존성 제거, (4) 테스트에서 다중 실행 구절 지양. \[p.291–297]   &#x20;
* **8.6 로깅 테스트**: “누가 보나?”로 결정한다. **지원 로깅**은 테스트, **진단 로깅**은 일반적으로 비테스트. ILogger를 직접 목킹하지 말고 **DomainLogger** 같은 래퍼를 쓰되, 도메인에 주입하지 말고 **도메인 이벤트 + 디스패처**로 외부 의존성과 분리하라. **과도한 진단 로그 금지**, 로거는 **명시적 주입**. \[p.299–308]   &#x20;

---

## 추가 자료(요점 정리 + 링크)

* **지원 vs 진단 로깅**: 운영자가 추적할 메시지(지원)와 개발자 디버깅(진단)을 구분해 설계·테스트 범위를 정하라. ([principal-it.eu][1])
* **구조화 로깅(Serilog)**: 메시지 템플릿과 속성 데이터를 분리해서 캡처하고, 이후 JSON/CSV 등 다양한 렌더링으로 분석성을 높인다. 템플릿 속성 사용 권장. ([serilog.net][2], [GitHub][3], [Medium][4])
* **도메인 지향 가시성(Observability)**: 비즈니스 관점의 신호를 중심으로 수집·분석하자(이벤트/로깅를 도메인 언어로). ([martinfowler.com][5])
* **앰비언트 컨텍스트 안티패턴**: 정적 접근으로 의존성을 숨기면 변경·테스트가 어려워진다. 명시적 주입으로 전환. ([Manning Publications][6], [Stack Overflow][7])

---

## 내 생각 (짧게)

* 8.5: **테스트 친화적 설계 = 단순한 의존 그래프**. 경계를 세우고, 층을 줄이고, 순환을 끊자.
* 8.6: **로깅도 도메인 언어로**. 다만 도메인은 순수하게 두고, **이벤트→디스패처**에서 외부 세계(로그 저장소)를 만나라.

---

## 출처

* 본문 인용: 『단위 테스트(8장)』, 8.5–8.6 정리. \[p.291–309]

  * 도메인 경계/계층/순환:  &#x20;
  * 다중 실행 구절 금지:&#x20;
  * 로깅의 테스트 여부/방법/구조화/이벤트/주입:   &#x20;
* 추가 자료: Serilog, DI/앰비언트 컨텍스트, 도메인 관점 로깅 등(상단 링크 참조). ([serilog.net][2], [GitHub][3], [Medium][4], [Manning Publications][6], [martinfowler.com][5])

---

[1]: https://principal-it.eu/2020/11/unit-tests-for-logging/?utm_source=chatgpt.com "How To Write Unit Tests For Logging - Principal IT"
[2]: https://serilog.net/?utm_source=chatgpt.com "Serilog — simple .NET logging with fully-structured events"
[3]: https://github.com/serilog/serilog/wiki/Writing-Log-Events?utm_source=chatgpt.com "Writing Log Events · serilog/serilog Wiki"
[4]: https://medium.com/c-sharp-programming/serilog-advanced-formatting-from-templates-to-readable-logs-dea47402138a?utm_source=chatgpt.com "Serilog: Advanced Formatting: From Templates to ..."
[5]: https://martinfowler.com/articles/domain-oriented-observability.html?utm_source=chatgpt.com "Domain-Oriented Observability"
[6]: https://www.manning.com/books/dependency-injection-principles-practices-patterns?utm_source=chatgpt.com "Dependency Injection Principles, Practices, and Patterns"
[7]: https://stackoverflow.com/questions/66664096/is-static-domain-helper-class-ambient-context-anti-pattern?utm_source=chatgpt.com "Is \"static Domain helper class\" Ambient Context Anti-Pattern?"
