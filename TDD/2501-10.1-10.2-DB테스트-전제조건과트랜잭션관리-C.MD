## 10.1 데이터베이스 테스트를 위한 전제 조건

### 핵심 포인트

* **DB도 코드다(스키마 = 코드)**: 데이터베이스 스키마를 일반 코드처럼 **형상관리(Git)** 에 넣어 한 곳에서 이력과 변경을 추적해야 한다. `모델 DB 인스턴스`를 기준으로 삼는 방식은 원천 정보가 둘이 되어 충돌과 회귀 재현의 어려움을 낳는다.&#x20;
* **참조 데이터도 스키마다**: 애플리케이션 동작에 필수인 **참조 데이터(reference data)**(예: 사용자 유형 테이블)는 테이블/뷰 스키마와 함께 **INSERT 스크립트**로 형상관리한다. 수정 가능한 일반 데이터와 구분 플래그를 두는 것도 방법.&#x20;
* **개발자별 전용 DB 인스턴스**: 공유 DB는 테스트 상호 간섭과 하위호환성 문제를 유발하므로 **개발자마다(가능하면 로컬)** 분리된 인스턴스를 사용해 테스트를 빠르고 안정적으로 돌린다.&#x20;
* **배포 방식: 상태 기반 vs 마이그레이션 기반**

  * 상태 기반: “이상적인 최종 상태”를 정의하고 비교 도구가 업그레이드 스크립트를 자동 생성한다.&#x20;
  * 마이그레이션 기반: **명시적 마이그레이션(1->2->3 …)** 으로 버전 간 전환을 기록·적용한다. Flyway/Liquibase 같은 도구 사용. **데이터 모션(기존 데이터 변환)** 을 안전하게 처리하기 유리하다. &#x20;

### 상태 기반 vs 마이그레이션 기반 — 한눈 표

| 구분                    | 상태 기반                 | 마이그레이션 기반              |
| --------------------- | --------------------- | ---------------------- |
| 형상관리의 초점              | **최종 상태**를 명시         | **변경 단계(마이그레이션)** 를 명시 |
| 스크립트 생성               | 비교 도구가 자동 생성          | 개발자가 **명시적 스크립트** 작성   |
| 병합 충돌 처리              | 상대적으로 수월(상태 명확)       | 상대적으로 어려울 수 있음         |
| **데이터 모션**(기존 데이터 변환) | **취약**: 도구가 데이터 가정 불가 | **강함**: 도메인 규칙 반영 가능   |
| 권장시나리오                | 초기 개발(운영 전) 한정 고려     | **운영 릴리스 이후 필수 권장**    |

> 책의 결론: 운영 데이터가 생기는 순간부터는 **마이그레이션 기반**이 현실적이다. 마이그레이션은 일단 커밋되면 **수정하지 말고**, 필요 시 새 마이그레이션을 추가하라(데이터 손실 위험의 특수 예외만 허용).&#x20;

**내 생각(짧게)**
마이그레이션 기반은 “코드 리뷰 가능한 데이터 변경”을 만든다는 점이 가장 큼. CI/CD에 자연스럽게 들어가고 회귀 재현/롤백이 명확해져요. 팀 협업 관점에서 사실상 필수.

---

## 10.2 데이터베이스 트랜잭션 관리

### 10.2.1 제품 코드에서 트랜잭션 관리

* **문제 상황**: 컨트롤러가 한 비즈니스 연산에서 **여러 DB 호출**을 각각 **개별 트랜잭션**으로 수행하면, 중간 실패 시 데이터 **모순**이 발생할 수 있다(예: 회사 직원 수는 저장됐지만 사용자 저장 실패). → **원자성** 필요.&#x20;
* **해결 방향**: “어떤 데이터를 바꿀지”와 “커밋/롤백 여부” 결정을 **분리**한다.

  * **리포지토리**: 데이터 접근/수정 담당
  * **트랜잭션**: 커밋/롤백 원자성 보장
  * 리포지토리는 항상 **현재 트랜잭션 위**에서 동작하도록 만들 것.  &#x20;
* **작업 단위(Unit of Work)** 로 업그레이드

  * 비즈니스 연산 중 객체 변경을 추적해 **마지막에 한 번에 반영** → DB 트랜잭션 **짧게 유지** & 혼잡 감소, 호출 수도 절약. 많은 ORM(JPA 등)이 구현한다.&#x20;

> JPA/스프링에서는 **영속성 컨텍스트 + @Transactional** 이 사실상 Unit of Work를 구현한다. 컨텍스트 종료 시점에 flush/commit. (참고: Fowler UoW) ([martinfowler.com][1], [danielme.com][2])

### 10.2.2 통합 테스트에서 트랜잭션 관리

* 테스트의 **준비/실행/검증** 각 구절에서 **컨텍스트(또는 트랜잭션)를 재사용하지 말 것**. 운영 환경과 동일하게 **실행 구절은 독립 컨텍스트**, 준비·검증은 별도 컨텍스트를 사용하여 2차 캐시/영속성 캐시의 착시를 피한다.
  → 최소 **3개의 트랜잭션/작업 단위(준비·실행·검증)** 를 쓰는 가이드.&#x20;

**내 생각(짧게)**
실무에서 “테스트가 로컬에서는 녹색인데 CI/운영에서만 깨짐”의 다수가 컨텍스트/트랜잭션 재사용과 캐시 착시예요. 준비/실행/검증 분리는 통합 테스트의 생명줄.

---

## (표) 스프링/JPA에서의 트랜잭션 & UoW 흐름

| 단계                  | 설명                     | 비고                                                             |
| ------------------- | ---------------------- | -------------------------------------------------------------- |
| `@Transactional` 진입 | 트랜잭션 시작 + 영속성 컨텍스트 바인딩 | 선언적 트랜잭션 권장 ([Home][3], [Baeldung on Kotlin][4])               |
| 엔티티 변경              | 더티 체킹으로 변경 추적          | Unit of Work 개념과 일치 ([martinfowler.com][1], [danielme.com][2]) |
| 메서드 정상 종료           | flush → commit         | 예외 시 롤백 규칙 적용 ([Baeldung on Kotlin][4])                        |

---

## Kotlin 도메인 예제 (CRM: 이메일 변경 규칙) — as-is → to-be

### 시나리오

* 회사 도메인(`mycorp.com`) 메일을 일반 메일로 바꾸면 회사의 `numberOfEmployees` 감소.
* 한 연산에서 **사용자 저장/회사 저장/이벤트 발행**이 **원자적**이어야 함.

### ✅ AS-IS (안티 패턴: 호출마다 개별 트랜잭션/연결)

```kotlin
// AS-IS: 각 저장 호출이 자체 커넥션/트랜잭션을 열어 원자성이 깨지기 쉬움
class Database(private val ds: javax.sql.DataSource) {
    fun getUserById(id: Long): UserRow = ds.connection.use { conn ->
        conn.prepareStatement("select id,email,type,active from users where id=?").use { ps ->
            ps.setLong(1, id)
            ps.executeQuery().use { rs ->
                rs.next()
                UserRow(rs.getLong(1), rs.getString(2), rs.getString(3), rs.getBoolean(4))
            }
        }
    }

    fun getCompany(): CompanyRow = ds.connection.use { conn ->
        conn.createStatement().use { st ->
            st.executeQuery("select domain, number_of_employees from company limit 1").use { rs ->
                rs.next()
                CompanyRow(rs.getString(1), rs.getInt(2))
            }
        }
    }

    fun saveCompany(row: CompanyRow) = ds.connection.use { conn ->
        conn.prepareStatement("update company set number_of_employees=? where domain=?").use { ps ->
            ps.setInt(1, row.numberOfEmployees)
            ps.setString(2, row.domain)
            ps.executeUpdate()
        }
    }

    fun saveUser(row: UserRow) = ds.connection.use { conn ->
        conn.prepareStatement("update users set email=?, type=? where id=?").use { ps ->
            ps.setString(1, row.email)
            ps.setString(2, row.type)
            ps.setLong(3, row.id)
            ps.executeUpdate()
        }
    }
}

class UserControllerAsIs(
    private val db: Database,
    private val eventBus: EventBus,
) {
    // 문제: get/save가 서로 다른 커넥션/트랜잭션 -> 중간 실패시 데이터 모순 가능
    fun changeEmail(userId: Long, newEmail: String): String {
        val user = db.getUserById(userId).toDomain()
        val company = db.getCompany().toDomain()
        val err = user.canChangeEmail()
        if (err != null) return err

        user.changeEmail(newEmail, company)
        db.saveCompany(company.toRow()) // ← 여기 성공하고
        db.saveUser(user.toRow())       // ← 여기서 실패하면 모순 발생!
        eventBus.publish(UserEmailChanged(user.id, user.email))
        return "OK"
    }
}
```

> 책의 문제의식과 동일: **여러 트랜잭션으로 쪼개진 호출**은 하드웨어/소프트웨어 장애 시 **모순**을 남긴다. **리포지토리 + 트랜잭션(또는 UoW)** 로 책임을 분리하고 원자성 확보가 필요.&#x20;

---

### ✅ TO-BE (권장: `@Transactional` + 리포지토리 = Unit of Work)

```kotlin
// Spring Boot 3.x, Kotlin, JPA 가정
import jakarta.persistence.*
import org.springframework.stereotype.Repository
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Entity
@Table(name = "users")
class User(
    @Id val id: Long,
    var email: String,
    @Enumerated(EnumType.STRING)
    var type: UserType,
    var active: Boolean,
)

enum class UserType { Employee, Customer }

@Entity
@Table(name = "company")
class Company(
    @Id val domain: String,
    var numberOfEmployees: Int,
) {
    fun onEmployeeToCustomer() { numberOfEmployees -= 1 }
    fun onCustomerToEmployee() { numberOfEmployees += 1 }
}

// 간단한 규칙: 회사 도메인 메일이면 Employee, 아니면 Customer
fun inferType(email: String, companyDomain: String): UserType =
    if (email.endsWith("@$companyDomain")) UserType.Employee else UserType.Customer

fun User.canChangeEmail(): String? =
    if (!active) "inactive user" else null

fun User.changeEmail(newEmail: String, company: Company) {
    val oldType = type
    val newType = inferType(newEmail, company.domain)
    email = newEmail
    type = newType
    if (oldType == UserType.Employee && newType == UserType.Customer) company.onEmployeeToCustomer()
    if (oldType == UserType.Customer && newType == UserType.Employee) company.onCustomerToEmployee()
}

@Repository
class UserRepository(private val em: EntityManager) {
    fun findById(id: Long): User = em.find(User::class.java, id)
    fun save(user: User) { if (!em.contains(user)) em.persist(user) }
}

@Repository
class CompanyRepository(private val em: EntityManager) {
    fun getSingleton(): Company = em.createQuery(
        "select c from Company c", Company::class.java
    ).maxResults(1).singleResult

    fun save(company: Company) { if (!em.contains(company)) em.persist(company) }
}

interface EventBus { fun publish(evt: Any) }
data class UserEmailChanged(val userId: Long, val email: String)

@Service
class UserService(
    private val users: UserRepository,
    private val companies: CompanyRepository,
    private val eventBus: EventBus,
) {
    /**
     * 하나의 비즈니스 연산을 하나의 트랜잭션으로 감싼다.
     * JPA의 영속성 컨텍스트가 Unit of Work 역할을 수행한다.
     */
    @Transactional
    fun changeEmail(userId: Long, newEmail: String): String {
        val user = users.findById(userId)
        val company = companies.getSingleton()

        val err = user.canChangeEmail()
        if (err != null) return err

        user.changeEmail(newEmail, company)
        // 동일 트랜잭션 내 더티체킹 → flush/commit 시 한 번에 반영(원자성)
        eventBus.publish(UserEmailChanged(user.id, user.email))
        return "OK"
    }
}
```

* `@Transactional` 경계 안에서 **영속성 컨텍스트(UoW)** 가 변경을 추적하고 메서드 정상 종료 시 **한 번에 flush+commit** 된다. 원자성 확보. ([Baeldung on Kotlin][4], [martinfowler.com][1])
* 리포지토리/서비스로 **역할 분리**(데이터 접근 vs 비즈니스 규칙). 책의 “리포지토리는 항상 트랜잭션 위에서” 권고와 일치.&#x20;

---

## Kotest 통합 테스트 (준비/실행/검증 트랜잭션 분리)

> 권장: **Testcontainers(PostgreSQL)** 로 “실제에 가까운 DB”에서 검증. Kotest + Spring 확장 사용. (참고) ([Baeldung on Kotlin][5], [kotest.io][6])

```kotlin
// build.gradle.kts (요지)
// testImplementation("io.kotest:kotest-runner-junit5:5.9.1")
// testImplementation("io.kotest.extensions:kotest-extensions-spring:1.1.3")
// testImplementation("org.testcontainers:postgresql:1.20.1")

import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.shouldBe
import io.kotest.extensions.spring.SpringExtension
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.transaction.PlatformTransactionManager
import org.springframework.transaction.support.TransactionTemplate

@SpringBootTest
class ChangeEmailIntegrationSpec : StringSpec({

    extension(SpringExtension)

    lateinit var tt: TransactionTemplate
    lateinit var svc: UserService
    lateinit var users: UserRepository
    lateinit var companies: CompanyRepository

    beforeSpec {
        // 스프링 빈 주입
    }

    "회사 메일 -> 일반 메일 변경 시 직원 수 감소하고 타입이 Customer로 바뀐다" {
        // --- 준비(별도 트랜잭션)
        tt.execute {
            val company = Company(domain = "mycorp.com", numberOfEmployees = 1)
            companies.save(company)
            users.save(User(id = 1, email = "dev@mycorp.com", type = UserType.Employee, active = true))
        }

        // --- 실행(서비스 트랜잭션 내부)
        val result = svc.changeEmail(1, "dev@gmail.com")
        result shouldBe "OK"

        // --- 검증(별도 트랜잭션, 캐시 착시 방지)
        tt.execute {
            val u = users.findById(1)
            val c = companies.getSingleton()
            u.email shouldBe "dev@gmail.com"
            u.type shouldBe UserType.Customer
            c.numberOfEmployees shouldBe 0
        }
    }
}) {
    @Autowired fun setTxManager(tm: PlatformTransactionManager) { tt = TransactionTemplate(tm) }
    @Autowired fun setSvc(s: UserService) { svc = s }
    @Autowired fun setUsers(r: UserRepository) { users = r }
    @Autowired fun setCompanies(r: CompanyRepository) { companies = r }
}
```

* **포인트**: 준비/검증을 **별도 트랜잭션**(여기선 `TransactionTemplate`)으로 감싸 캐시(영속성 컨텍스트) 영향 제거. 책의 가이드 “준비·실행·검증 3 트랜잭션”을 따름.&#x20;

---

## (부록) 마이그레이션 도구 선택 자료 — 초간단 정리 + 링크

* **Liquibase vs Flyway**: 둘 다 **마이그레이션 기반** 도구. YAML/XML/SQL 등 다양한 포맷(Liquibase 강점) vs **심플한 SQL-first**(Flyway 강점). 조직 표준/팀 숙련도/DB 종류에 맞춰 선택. ([Baeldung on Kotlin][7], [liquibase.com][8])
* **스프링 트랜잭션 베스트 프랙티스**: 선언적 `@Transactional` 사용, 경계는 **서비스 계층**에. 전파/예외 정책 이해 필수. ([Baeldung on Kotlin][4], [Home][3])
* **Unit of Work 개념**: 비즈니스 트랜잭션 동안 변경 추적 → 종료 시 일괄 반영. ORM이 구현. ([martinfowler.com][1], [danielme.com][2])
* **Kotest + Testcontainers 예시**: 실 DB 유사 환경에서 리포지토리/서비스 통합 검증. ([Baeldung on Kotlin][5], [Medium][9], [kotest.io][6])

---

## 요약(초압축)

* **형상관리**: 스키마와 **참조 데이터까지** Git에. 모델 DB를 기준으로 쓰는 방식은 지양.&#x20;
* **개발자별 전용 DB**: 공유 DB로 인한 간섭/충돌 방지. 로컬 인스턴스 권장.&#x20;
* **배포 전략**: 운영 데이터가 생긴 뒤엔 **마이그레이션 기반**(데이터 모션에 강함). 상태 기반은 초기 한정.&#x20;
* **트랜잭션/UoW**: 한 비즈니스 연산은 **하나의 트랜잭션/Unit of Work** 로 원자성 보장. 리포지토리와 트랜잭션 **역할 분리**.&#x20;
* **통합 테스트**: **준비/실행/검증** 각각 **별도 트랜잭션/컨텍스트** 사용(최소 3개)으로 캐시 착시 제거.&#x20;

---

## 내 생각(챕터별 한 줄 첨언)

* **10.1**: “DB도 코드” 원칙을 지키면 테스트뿐 아니라 운영 안정성, 회귀재현, 온보딩 속도까지 좋아진다.
* **10.2**: 스프링/JPA라면 `@Transactional`을 “작고 명확한 서비스 경계”에 두는 습관이 장기적인 결함 비용을 낮춘다.

---


### 출처(원문 페이지 인용)

* 장 개요 및 전제 조건 목록, 모델 DB 안티패턴/형상관리: &#x20;
* 참조 데이터도 스키마:&#x20;
* 상태 기반 vs 마이그레이션 기반, 마이그레이션 권고:&#x20;
* 리포지토리/트랜잭션 역할 분리, 항상 트랜잭션 위에서: &#x20;
* Unit of Work로의 업그레이드와 장점:&#x20;
* 통합 테스트에서 3 트랜잭션(준비/실행/검증) 권장:&#x20;

### 외부 참고(요약 & 링크)

* Liquibase vs Flyway 비교(개념·선택 포인트): 마이그레이션 기반 도구, 포맷/에코시스템 차이. ([Baeldung on Kotlin][7], [liquibase.com][8])
* 스프링 트랜잭션 구성과 @Transactional: 선언적 경계, 전파/예외 주의점. ([Baeldung on Kotlin][4])
* Unit of Work 개념 정리: 비즈니스 트랜잭션 동안 변경 추적/일괄 반영. ([martinfowler.com][1])
* Kotest + Spring(확장) + Testcontainers 실전: 통합 테스트를 실제에 가깝게. ([kotest.io][6], [Baeldung on Kotlin][5])

---

필요하면 위 **TO-BE 코드**에 Flyway 기반 초기 마이그레이션 스크립트 예시(SQL)와 Testcontainers(PostgreSQL) 설정도 덧붙여 드릴게요.

[1]: https://martinfowler.com/eaaCatalog/unitOfWork.html?utm_source=chatgpt.com "Unit of Work"
[2]: https://danielme.com/2024/04/09/spring-data-jpa-transactions-propagations-exceptions-readonly/?utm_source=chatgpt.com "Spring Data JPA. 4. Transactions with @Transactional"
[3]: https://docs.spring.io/spring-framework/reference/data-access/transaction/declarative/annotations.html?utm_source=chatgpt.com "Using @Transactional :: Spring Framework"
[4]: https://www.baeldung.com/transaction-configuration-with-jpa-and-spring?utm_source=chatgpt.com "Transactions with Spring and JPA"
[5]: https://www.baeldung.com/spring-boot-testcontainers-integration-test?utm_source=chatgpt.com "DB Integration Tests with Spring Boot and Testcontainers"
[6]: https://kotest.io/docs/extensions/spring.html?utm_source=chatgpt.com "Spring"
[7]: https://www.baeldung.com/liquibase-vs-flyway?utm_source=chatgpt.com "Liquibase vs Flyway"
[8]: https://www.liquibase.com/liquibase-vs-flyway?utm_source=chatgpt.com "Liquibase vs. Flyway (Redgate)"
[9]: https://fabridinapoli.com/database-integration-tests-with-kotest-testcontainers-and-jdbctemplate-5c02fdde4678?utm_source=chatgpt.com "Database Integration Tests with Kotest, Testcontainers and ..."
