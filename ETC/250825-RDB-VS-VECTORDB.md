## 📌 RDBMS와 벡터 데이터베이스의 주요 차이점은 무엇인가?

RDBMS는 정형 데이터를 위한 데이터베이스로 정확한 키워드 검색과 데이터 무결성 및 일관성 보장에 효과적이며,벡터 데이터베이스는 비정형 데이터의 의미 기반 유사도 검색에 특화되어 있습니다. 

## 💡 RDBMS와 벡터 데이터베이스의 데이터 처리 방식 및 스키마 유연성 차이는?

| **항목** | **RDBMS** | **벡터 데이터베이스** |
| --- | --- | --- |
| 데이터 처리 방식 | 정형 데이터 저장   | 임베딩된 고차원 데이터 저장   |
| 스키마 유연성 | 엄격한 스키마   | 유연한 스키마   |

**목차**

rdbms와 벡터 데이터베이스의 **근본적인 차이점**과 **상호 보완적 활용법**을 명쾌하게 설명하는 콘텐츠입니다. 정형 데이터관리의 표준인 rdbms가 왜 비정형 데이터시대에 한계를 가지는지, 그리고 AI 시대의 핵심 기술인 **벡터 DB가 어떻게 의미 기반 검색을 가능하게 하는지** 구체적인 사례를 통해 이해할 수 있습니다. 특히, LLM의 환각 현상을 줄이는 **RAG(검색 증강 생성) 시스템**에서 두 데이터베이스가 어떻게 시너지를 내는지 실용적인 관점에서 제시하여, AI 애플리케이션 개발에 필요한 **데이터베이스 전략 수립**에 실질적인 도움을 줍니다.

## 1. 데이터베이스의 기본 개념 및 종류 소개

![](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/-zLGgaEsBb0/28.jpg)

1. **데이터베이스의 정의 및 역할** 
    1. 데이터베이스는 데이터를 효율적으로 저장, 관리, 검색하기 위한 체계적인 시스템이다.  
    2. 웹사이트 회원 가입, 쇼핑몰 물품 조회 및 장바구니 담기 등 다양한 활동의 데이터가 데이터베이스에 저장된다.  
2. **데이터베이스의 종류 및 본 영상의 목표** 
    1. 목적과 유형에 따라 다양한 종류의 데이터베이스가 존재한다.  
    2. 본 영상에서는 전통적인 **RDBMS**와 AI에 주로 활용되는 **벡터 DB**를 다룬다.  
    3. 벡터 DB가 RDBMS를 대체하는 것이 아니라, 서로 **보완적인 역할**로 함께 사용된다.  

## 2. RDBMS (관계형 데이터베이스 관리 시스템)의 이해

## 2.1. RDBMS의 정의 및 특징

![](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/-zLGgaEsBb0/35.jpg)

1. **RDBMS의 의미**: 기존에 주로 사용되던 **관계형 데이터베이스**를 의미한다.  
2. **데이터 저장 방식**: 데이터를 **정형화된 테이블 형태**로 저장한다.  
    1. 테이블은 행과 열로 구성된다.  
    2. 'R'은 '릴레이셔널(Relational)'을 의미하며, 테이블 간의 관계를 정의하여 데이터를 연결한다.  
    3. 예시: 쇼핑몰의 회원 테이블, 주문 테이블, 제품 테이블 등 여러 테이블 간의 관계를 정의한다.  
3. **데이터 무결성 및 일관성 유지의 중요성** 
    1. 쇼핑몰에서 물건 판매 시 금액 계산, 결제, 배송 과정에서 트랜잭션오류가 발생하면 계산이 맞지 않거나 문제가 생길 수 있다.  
    2. 따라서 데이터의 무결성과 일관성 유지가 매우 중요하다.  
4. **주요 다루는 데이터 및 스키마 정의** 
    1. 주로 **정형 데이터** (표 형태의 데이터, 엑셀과 유사한 데이터)를 다룬다.  
    2. 스키마를 정의할 때 데이터 타입을 미리 지정한다 (예: 숫자, 문자열, 날짜, 시간).  
    3. **NoSQL**은 스키마에 더 자유로운 반면, RDBMS는 스키마가 엄격하여 데이터 구조를 사전에 정의해야 한다.  
    4. 컬럼 추가 시 스키마에 먼저 추가한 후 데이터를 입력해야 한다.  

## 2.2. RDBMS의 주요 기능 및 검색 방식

![](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/-zLGgaEsBb0/309.jpg)

1. **CRUD 연산 지원**: 데이터 생성(Create), 조회(Read), 수정(Update), 삭제(Delete) 등 데이터 관리의 기본적인 연산을 지원한다.  
2. **트랜잭션 기능 및 ACID 원칙 보장** 
    1. 주문, 결제, 배송 등 일련의 과정에서 누락 없이 트랜잭션이 일어나야 한다.  
    2. **ACID 원칙**을 보장한다.  
        1. **원자성 (Atomicity)**: 트랜잭션은 전부 실행되거나 전부 실패해야 한다. (예: 카드 결제는 되었으나 주문 완료가 안 되면 문제 발생)  
        2. **일관성 (Consistency)**: 트랜잭션후에도 데이터베이스 상태가 일관적이어야 한다.  
        3. **고립성 (Isolation)**: 트랜잭션간의 영향을 최소화해야 한다.  
        4. **지속성 (Durability)**: 성공한 트랜잭션은 영구적으로 저장되어야 한다.  
3. **SQL (Structured Query Language)을 이용한 검색** 
    1. 데이터 정의, 조작, 제어로 나뉜다.  
    2. `SELECT` 문을 사용하여 데이터를 검색한다.  
    3. `WHERE` 조건을 사용하여 정확한 조건 필터링을 수행한다 (예: 특정 작성자, 나이, 가격 범위 검색).  
    4. 여러 테이블 간의 조인 연산을 통해 데이터를 조합하여 조회한다 (예: 고객 주문 정보 조회).  
4. **인덱싱을 통한 검색 성능 향상** 
    1. **B-tree 인덱스**를 사용하여 검색 속도를 향상시킨다.  
    2. **해시 인덱스**를 사용하면 특정 값에 대한 빠른 검색이 가능하다.  
5. **RDBMS 테이블 및 쿼리 예시** 
    1. **직원 테이블 예시**: 직원 ID(숫자), 직원 이름(문자), 부서(문자), 급여(숫자) 등 컬럼명과 데이터 타입을 스키마에 저장한다.  
    2. 스키마에 지정된 크기보다 큰 데이터를 입력하면 SQL오류가 발생하므로, 데이터 유효성 검증 후 입력해야 한다.  
    3. `SELECT FROM WHERE` 쿼리를 사용하여 특정 조건에 맞는 데이터를 가져온다 (예: 부서가 '세일즈'인 직원).  

## 2.3. RDBMS의 장점과 한계점

![](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/-zLGgaEsBb0/580.jpg)

1. **장점** 
    1. 데이터 무결성 및 일관성을 보장한다.  
    2. 표준화된 SQL사용으로 접근이 용이하다.  
    3. 정형 데이터(표로 된 데이터) 관리에 매우 효과적이다.  
    4. 성숙한 기술과 풍부한 생태계를 가지고 있어 복잡한 관계 표현 및 여러 테이블 연결이 가능하다.  
2. **생성형 모델 사용 시 한계점** 
    1. 비정형 데이터(텍스트, 이미지) 처리가 어렵다.  
    2. 데이터의 **의미 기반 검색**이 어렵다.  
    3. 대규모 데이터에서 **수평적 확장이 어렵다**.  
    4. 유연하지 못한 스키마변경이 아쉬운 점이다.  

## 2.4. RDBMS의 주요 활용 사례 및 제품군

![](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/-zLGgaEsBb0/627.jpg)

1. **활용 사례**: 은행 시스템, 예약 시스템, 고객 관리, ERP, 전자상거래, 인사 급여 관리 등 다양한 비즈니스에 활용된다.  
2. **주요 제품군**: 오라클, My SQL, MariaDB, Postgre SQL, MS SQLServer, SQLite 등이 있다.  
    1. MariaDB는 My SQL에서 파생된 오픈 소스이며, 개발자의 딸 이름에서 유래했다.  

## 3. 벡터 데이터베이스의 이해

## 3.1. 벡터 데이터베이스의 정의 및 필요성

![](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/-zLGgaEsBb0/675.jpg)

1. **벡터 DB의 의미**: RDBMS가 정형 데이터를 위한 데이터베이스라면, 벡터 DB는 **비정형 데이터를 위한 데이터베이스**이다.  
2. **비정형 데이터의 급증**: 텍스트, 이미지, 비디오 등 비정형 데이터가 급증하고 있다.  
3. **임베딩을 통한 벡터화**: AI 모델에서 텍스트나 이미지 데이터를 **임베딩(Embedding)**을 통해 벡터화한다.  
    1. 임베딩은 단어를 다차원 공간에 표현하여 가까운 거리에 있는 단어들이 유사한 의미를 가지도록 한다.  
    2. 임베딩된 데이터는 숫자( 밀집 벡터)들로 구성되며, 메타데이터와 함께 저장될 수 있다.  
    3. 벡터화된 데이터는 표 형태의 행렬로 볼 수 있지만, 검색 및 저장 방식이 기존 관계형 데이터베이스와는 다르다.  
4. **의미 기반 검색의 한계 극복**: 기존 RDBMS로는 의미 기반 검색에 한계가 있어, 데이터의 **유사성을 기준으로 검색**할 필요성이 증대되었다.  
5. **벡터 DB의 역할**: 임베딩 벡터를 효율적으로 저장하고 검색하는 데 특화된 데이터베이스이다.  

## 3.2. 벡터 DB의 핵심 기능 및 검색 방식

![](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/-zLGgaEsBb0/815.jpg)

1. **쿼리 벡터와 유사한 벡터 검색**: 핵심 기능은 쿼리 벡터와 유사한 벡터를 검색하는 것이다.  
    1. 고차원 공간에서 빠른 유사도 검색성능이 중요하다.  
    2. 비정형 데이터의 의미 검색에 활용된다.  
    3. 예시: '밀크'를 검색하면 그 단어와 가까운 단어들을 순서대로 찾아준다.  
2. **거리 측정 방식**: 벡터 간의 거리를 구할 때 **코사인 유사도**나 **유클리드 거리** 등을 사용한다.  
3. **데이터 구조**: 주로 **벡터 임베딩** (고차원 숫자 배열)을 사용하며, 부가 데이터로 **메타데이터**를 함께 관리한다.  
    1. 메타데이터는 대부분 유연한 구조를 지원한다.  
4. **유사도 검색**: 쿼리 벡터와 DB 내 벡터 간의 거리나 유사도를 계산하여, 거리가 가장 가까운 **상위 K개의 벡터**를 반환한다.  
5. **근사 최근접 이웃 (Approximate Nearest Neighbor, ANN) 검색**:  
    1. 고차원 벡터 공간에서 정확한 최근접 이웃 검색은 매우 느리다.  
    2. 따라서 100% 정확하지는 않지만 매우 빠른 속도로 충분히 유사한 이웃을 찾는 알고리즘을 사용한다.  

## 3.3. 벡터 DB의 인덱싱, 확장성 및 데이터 예시

![](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/-zLGgaEsBb0/995.jpg)

1. **벡터 DB 인덱싱**: 유사도 검색속도 향상을 위한 벡터 특화 인덱스를 사용한다.  
    1. 대표적인 알고리즘: 그래프 기반, 클러스터링 기반, 해싱 기반, 벡터 압축 기반.  
2. **확장성 및 일관성**:  
    1. **수평적 확장**이 용이하게 설계된다.  
    2. 강한 일관성보다는 **최종 일관성**을 허용하는 경우가 많다.  
3. **벡터 데이터 JSON 예시**: 벡터 ID, 임베딩된 밀집 벡터의 숫자 값, 메타데이터정보를 함께 가지고 있다.  
    1. 검색과 필터링에 사용할 메타데이터를 함께 저장하는 형태로 구성된다.  
4. **벡터 데이터 쿼리**: 임베딩된 이미지나 텍스트에서 유사한 데이터를 찾거나 필터링할 때, 상위 K개(예: 5개, 10개)를 찾아온다.  

## 3.4. 벡터 DB의 장점과 한계점

![](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/-zLGgaEsBb0/1069.jpg)

1. **장점** 
    1. 비정형 데이터의 **의미 기반 검색**에 탁월하다.  
    2. 대규모 데이터셋의 **고속 유사성 검색**이 가능하다.  
    3. 인공지능 모델과의 연동이 용이하다.  
    4. 수평적 확장, 추천 검색, RAG 등 다양한 AI 응용을 지원한다.  
2. **한계점** 
    1. 정확한 값 매칭에는 비효율적이다.  
    2. 복잡한 관계형 쿼리 지원이나 트랜잭션기능이 RDBMS보다 약하다.  
    3. 상대적으로 새로운 기술이며 생태계가 계속 발전 중이다.  
    4. 임베딩 모델의 의존성이 커서 모델 성능이 검색 품질에 큰 영향을 미친다.  
    5. 하지만 속도 및 유사도 검색등은 꾸준히 연구되고 있다.  

## 3.5. 벡터 DB의 주요 활용 사례 및 대표 제품

![](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/-zLGgaEsBb0/1160.jpg)

1. **주요 활용 사례** 
    1. **추천 시스템**: 유사 상품, 연관 상품, 뉴스, 비디오, 음악 추천.  
    2. **지식 검색**: 이미지, 비디오 검색, 챗봇, 가상 비서.  
    3. **이상 탐지**: 금융 사기 탐지, 이상 거래 감지.  
2. **대표적인 벡터 DB 제품**: Pinecone, Milvus, Chroma 등이 있다.  
3. **벡터 스토어 순위 (2024년 랭체인 리포트 기준)** 
    1. 1위: Chroma
    2. 2위: Faiss
    3. 3위: Pinecone
    4. 4위: PG Vector

## 4. 벡터 검색 라이브러리 Faiss와 벡터 DB의 차이점

![](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/-zLGgaEsBb0/1184.jpg)

1. **Faiss (Facebook AI Similarity Search)** 
    1. DB 자체라기보다는 **벡터 스토어**로 볼 수 있다.  
    2. 인메모리 상태로 메모리에 저장하여 사용한다.  
    3. 메타 AI에서 개발한 오픈 소스 라이브러리이다.  
    4. 밀집 벡터의 효율적인 유사성 검색이나 클러스터링에 사용되며, 대규모 데이터셋 처리에도 최적화되어 있다.  
    5. 벡터 DB 내부에서 사용되는 경우도 있다.  
    6. 고성능 C++로 구현되었고 파이썬 바인딩을 제공한다.  
    7. 다양한 인덱싱 알고리즘, GPU 지원, 메모리 효율성, 인덱스 조합 사용이 가능하다.  
2. **Faiss의 한계점 (라이브러리로서)** 
    1. 주로 인메모리로 처리하며, 데이터 **영속성이나 트랜잭션 기능이 없다**.  
    2. 메타데이터저장 및 필터링 기능이 제한적이다.  
    3. 관리형 API나 사용자 관리 기능이 없으며, 개발자가 직접 데이터를 로딩하고 인덱스를 빌드하며 API를 구축해야 한다.  
    4. 인메모리 기반이므로 파일 저장, 로드 등을 수동으로 해야 하며, 자동 저장/복원, 트랜잭션, 인덱싱 저장/로딩, API 구축 등에 한계가 있다.  
3. **벡터 DB와 Faiss의 비교** 
    1. **벡터 DB**: 영속성, 트랜잭션, 메타데이터관리, API 제공, 관리형 서비스, 사용자 관리 기능을 지원한다.  
    2. **Faiss**: 고성능 유사도 검색, 다양한 인덱싱 알고리즘, GPU 가속, 메모리 효율성, 파이썬/C++ API 제공에 강점이 있다.  
    3. **활용**: 대규모 이미지/비디오 검색, 유사도 검색, AI 모델에서의 임베딩 벡터 관리, 대규모 데이터셋 클러스터링/분류 등에 활용된다.  
    4. 관리 및 검색 효율성 측면에서 벡터 DB를 직접 사용하는 것이 더 효율적일 수 있다.  
4. **Faiss의 사용 시점**: 벡터 검색의 핵심 엔진을 직접 구현하거나, 최고 수준의 검색 성능과 튜닝, 빠른 프로토타이핑이 필요할 때 사용한다.  

## 5. Chroma DB 소개

![](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/-zLGgaEsBb0/1409.jpg)

1. **Chroma DB의 특징**: 오픈 소스 벡터 데이터베이스로, **LLM 워크플로우에 최적화**되어 있다.  
2. **설치 및 연동**: `pip install chromadb`로 간단하게 설치 가능하며, LangChain이나 LlamaIndex와 연동이 용이하다.  
3. **LangChain과의 연동**: LangChain의 벡터 스토어로 사용될 경우, 문서 임베딩 저장, 유사도 검색, LLM 응답에 활용된다.  
4. **RAG 파이프라인 구현**: 빠르고 간결한 RAG 파이프라인 구현에 사용된다.  
5. **기능 및 접근성**:  
    1. 데이터 저장, 인덱싱, 검색 기능을 제공한다.  
    2. 데이터 영속성 보장 및 트랜잭션지원 여부는 DB에 따라 차이가 있다.  
    3. REST API나 SDK를 통한 데이터 접근이 가능하며, 사용자 친화적인 인터페이스를 제공한다.  

## 6. RDBMS와 벡터 DB의 비교

![](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/-zLGgaEsBb0/1481.jpg)

1. **데이터 유형**: RDBMS는 **정형 데이터**, 벡터 DB는 **비정형 데이터**를 다룬다.  
2. **검색 방식**: RDBMS는 **정확한 키워드 검색**, 벡터 DB는 **유사도 검색**을 수행한다.  
3. **데이터 처리 방식**:  
    1. RDBMS: 정형 데이터를 저장한다.
    2. 벡터 DB: 임베딩된 고차원 데이터를 저장한다.
4. **스키마 유연성**: RDBMS는 **스키마가 엄격**하고, 벡터 DB는 **유연**하다.  
5. **데이터 관계**:  
    1. RDBMS: 명시적인 조인(Join)을 통해 관계를 정의한다.
    2. 벡터 DB: 암묵적인 유사성 거리 기반으로 관계를 파악한다.
6. **검색 메커니즘**:  
    1. RDBMS: 조건 필터링을 통해 정확한 값이나 범위를 지정한다.
    2. 벡터 DB: 유사성 기반으로 거리 기반의 가장 가까운 것을 가져온다.
7. **시스템 특성**: RDBMS는 **수직 확장 중심**, 벡터 DB는 **수평 확장이 용이**하다.  

## 7. RAG (검색 증강 생성) 시스템에서의 데이터베이스 역할

![](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/-zLGgaEsBb0/45.jpg)

1. **RAG의 필요성**: 생성형 AI의 한계점(환각 현상, 최신 정보 부족, 출처 불분명, 특정 도메인 지식 부족)을 극복하는 핵심 기술이다.  
2. **RAG의 작동 방식**: LLM이 답변을 생성하기 전에 **외부 지식 소스에서 관련 정보를 검색하고 참고**하여 정확하고 신뢰성 있는 답변을 생성한다.  
    1. 잘못된 답변, 최신 정보 부족, 근거 없는 답변 등을 방지하여 답변의 신뢰도를 높인다.  
3. **RAG의 기본 흐름** 
    1. 사용자가 질문을 입력한다.  
    2. 관련 정보를 검색한다 (DB에 요청).  
    3. 검색된 정보와 원래 질문을 함께 넣어 **프롬프트를 증강(Augmentation)**시킨다.  
    4. 증강된 프롬프트를 LLM에 넣어 신뢰성 있는 최종 답변을 생성한다.  
4. **RAG에서 데이터베이스의 핵심 역할**: **검색**이다.  
    1. 대규모 지식 소스를 효율적으로 저장하고 가장 관련성 높은 정보를 빠르고 정확하게 찾아내는 역할을 한다.  
    2. 어떤 데이터베이스를 사용하느냐가 RAG 성능에 영향을 줄 수 있다.  
5. **RAG에서 벡터 DB의 역할**: **의미 검색 엔진**이다.  
    1. 질문을 벡터로 변환(임베딩)한다.  
    2. 유사 벡터를 검색하고, 원본 정보를 반환한다.  
    3. RAG의 검색 품질을 결정하는 핵심 요소가 된다.  
    4. 예시: Q&A 챗봇 구현 시, FAQ 문서나 내부 지식 문서를 벡터 DB에 임베딩하여 저장하고, 질문과 가장 유사한 문서 조각을 검색하여 LLM이 답변을 생성하도록 한다.  

## 8. RAG 시스템에서의 RDBMS와 벡터 DB의 하이브리드 활용

## 8.1. RDBMS의 보조 및 신뢰도 강화 역할

![](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/-zLGgaEsBb0/1720.jpg)

1. **벡터 검색의 부족한 부분 보완**: RDBMS는 벡터 검색만으로는 부족한 부분을 보완하고, 벡터 DB와 함께 사용하여 RAG의 완성도를 높인다.  
2. **활용 분야**: 메타데이터필터링, 구조화된 정보 조회, 사용자 세션 관리 등에 활용된다.  
3. **메타데이터 필터링**: 정확한 조건으로 결과를 필터링하여 완전히 정확한 정보를 가져올 때 RDBMS를 사용한다.  
    1. 예시: '1년 내 기술팀'과 같은 조건을 필터링할 때 RDBMS를 사용한다.  
4. **구조화된 정보 조회**: 레거시 시스템에서 SQL쿼리를 실행하여 구체적인 숫자 정보(예: 포인트 잔액, 상품 재고 현황)를 조회할 때 RDBMS를 사용한다.  
5. **사용자 세션 로그 관리**: RDBMS를 사용하여 사용자 세션 로그를 관리한다.  

## 8.2. 하이브리드 접근 방식의 필요성 및 구현

![](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/-zLGgaEsBb0/1797.jpg)

1. **하이브리드 접근의 작동 방식**: RAG 시스템 내에서 RDBMS와 벡터 DB를 함께 사용하여, 정확한 필터링이 필요할 때는 RDBMS를, 유사한 콘텐츠를 가져와야 할 때는 벡터 DB를 사용한다.  
    1. 검색된 정보를 프롬프트에 조합하여 모델에 넣고 최종 답변을 얻는다.  
    2. 두 기술의 장점을 합쳐 신뢰성 있는 답변을 얻을 수 있다.  
2. **하이브리드 접근의 필요성**: 실제 비즈니스에서는 정형 데이터와 비정형 데이터가 혼재하므로, 정확한 조건 검색과 의미 기반의 유사성 검색이 모두 필요하다.  
3. **하이브리드 구현 방식** 
    1. **RDBMS 확장 활용**: Postgre SQL과 PG Vector 같은 확장 기능을 사용하면 하나의 DB에서 SQL쿼리와 벡터 유사도 검색을 동시에 수행할 수 있다.  
        1. **장점**: 익숙한 RDBMS환경에서 단순한 통합이 가능하다.  
        2. **단점**: 대규모 벡터 검색 및 확장성에 한계가 있다.  
    2. **별도 데이터베이스 접근**: RDBMS와 벡터 DB를 각각 구축하고, 애플리케이션 레벨에서 두 데이터베이스에 각각 접근하여 사용한다.  
        1. **장점**: 각 데이터베이스의 전문성을 활용할 수 있다.  
        2. **단점**: 시스템 구성 및 관리 복잡성이 증가한다.  
    3. **하이브리드 DB 솔루션**: 하나의 시스템에서 데이터 처리와 벡터 검색 모두 고성능으로 지원하는 솔루션들이 등장하고 있다.  
        1. **장점**: 통합 비용이 저렴하고 잠재적으로 고성능을 제공한다.  
        2. **단점**: 기술 성숙도나 벡터 종속성에 대한 우려가 있을 수 있다.  
4. **미래 전망**: 벡터 검색 기능은 점차 데이터베이스의 기본 기능으로 통합될 가능성이 높다.  
    1. RDBMS와 벡터 DB 간의 경계가 모호해질 수 있으며, 데이터 유형에 따른 최적의 저장 및 검색 전략의 중요성이 증대될 것이다.  
    2. 하이브리드 통합 솔루션이 계속 발전할 것으로 예상된다.  

## 9. RDBMS와 벡터 DB의 상호 보완적 관계 및 활용 예시

1. **RDBMS의 지속적인 중요성**: 정형 데이터를 다룰 때, 트랜잭션이 필요할 때, 정확하고 일관된 관리에 필수적으로 사용된다.  
2. **벡터 DB의 중요성**: 비정형 데이터의 의미를 이해하고 검색할 때 필요하다.  
3. **상호 보완적 관계**: 두 데이터베이스는 경쟁 관계가 아닌 **상호 보완적인 관계**로, 서로의 강점을 활용하여 시너지를 창출할 수 있다.  
    1. 최신 시스템은 두 기술을 함께 사용하여 정확성과 의미적 활용을 모두 달성한다.  
4. **긴 영상 번역 및 요약 사례를 통한 활용법** 
    1. 안드레이 카파시의 긴 강의 영상(2~3시간)을 기존 생성형 AI로 번역/요약 시 토큰 수 제한, 요약본 제공 등의 한계가 있다.  
    2. 벡터 데이터베이스를 활용하면 이러한 한계를 극복할 수 있다.  
    3. 유튜브 자막을 수집했을 때, 긴 자막을 그대로 생성형 AI에 넣으면 토큰 수 제한으로 내용이 잘리거나 전부 번역되지 않는 경우가 많다.  
    4. 최근 노트북은 긴 영상도 요약 및 번역을 어느 정도 해주지만, 직접 번역하며 RDBMS와 벡터 DB 활용법을 찾아볼 수 있다.  

## 9.1. RDBMS를 활용한 API 번역 결과 관리

![](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/-zLGgaEsBb0/2104.jpg)

1. **OpenAI API를 활용한 번역**: 수집된 자막을 OpenAI API를 활용하여 번역할 수 있다.  
2. **토큰 수 제한 처리**: 토큰 수 제한이 있으므로, 텍스트를 청크(Chunk)로 나누어 번역한다.  
    1. 청크를 나누는 기법은 다양하며, 단락 기준이나 글자 수 기준으로 나눌 수 있다.  
3. **데이터베이스를 활용한 번역 결과 관리의 필요성** 
    1. API 호출중 끊길 수 있으며, 여러 번 호출해야 하고 그 결과도 관리해야 한다.  
    2. API로 받은 답변 내용을 데이터베이스에 하나씩 업데이트하며 관리하는 것을 추천한다.  
4. **효율적인 API 호출 및 비용 관리**:  
    1. 오리지널 텍스트와 번역된 텍스트를 데이터베이스에 저장하고, API 답변을 받을 때마다 번역 컬럼을 업데이트한다.  
    2. 중간에 API 호출이 끊겨도 처음부터 다시 요청할 필요 없이, 번역되지 않은 부분부터 다시 번역을 시작할 수 있다.  
    3. 이를 통해 API 비용을 효율적으로 사용하고 호출을 관리할 수 있다.  
    4. 텍스트 형태의 자막 내용도 청크하여 API를 호출해야 한다면 데이터베이스 형태로 관리하는 것이 효율적이다.  
5. **SQLite 데이터베이스 활용 예시**: 파이썬에 내장된 SQLite 데이터베이스에 오리지널 텍스트를 먼저 넣고, API 응답 결과를 하나씩 채워나가면 API 호출진행 상황을 확실하게 파악할 수 있다.  

## 9.2. 벡터 DB를 활용한 번역 내용 검색 및 질의응답

![](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/-zLGgaEsBb0/2295.jpg)

1. **번역된 내용의 벡터 DB 저장**: RDBMS에 관리된 번역 내용을 벡터 DB(예: Chroma DB)에 벡터화하여 저장한다.  
2. **웹페이지 형태로 번역 결과 확인**: 번역된 내용을 HTML 형태로 만들어 서버를 띄워 확인할 수 있다.  
    1. 글자 수 기준으로 청크할 경우, 문맥이 잘려 번역이 어색해질 수 있다 (예: "go to Google Colab"이 끊겨 번역됨).  
    2. 나중에 원문과 번역본을 합쳐 비교할 때, 잘게 토큰화된 부분이 어색하게 느껴질 수 있다.  
    3. 원문 데이터를 정제하고, 문단이나 의미 단위로 청크하여 번역하면 훨씬 의미 있는 번역 결과를 얻을 수 있다.  
3. **벡터 DB를 활용한 질의응답**: 번역된 내용을 벡터 DB에 넣고 "토큰화란 무엇인가?"와 같은 질문을 할 수 있다.  
    1. 벡터 DB는 영상 내용에서 "토큰화란 언어 모델에서 사용되는 단어들을 작은 단위로 분리하는 과정을 말하며, 복잡하고 헷갈리며 숨겨진 문제들이 많아 이해하고 적용하는 것이 중요하다"는 답변을 찾아왔다.  
4. **RDBMS와 벡터 DB의 동시 활용**: 두 데이터베이스는 따로 사용하는 것이 아니라 함께 사용한다.  
    1. **RDBMS**: 정확한 내용을 찾을 때, 키워드 검색을 할 때 사용한다.  
    2. **벡터 DB**: 유사도 검색을 통해 비슷한 문서를 찾아올 때 사용한다.  
5. **결론**: 데이터 유형과 처리 목적에 맞는 데이터베이스를 선택하거나, 정확도와 유사도 모두 필요할 경우 **하이브리드 접근 방식**을 활용하여 다양한 비즈니스 문제 해결에 적용할 수 있다.

## 내 생각 
> 앞으로는 application 개발의 표준이 바뀔수도 있을 듯 하다. 정확한 질의와 비정형 질의, 비정형 질의가 예전에는 높은 기술 난의도로 인해서 접근 자체가 쉽지 않았지만 AI의 힘으로 이제는 좀 더 수월하게 접근이 가능하다. 또한 품질또한 매우 뛰어나므로 별다른 허들이 없이 높은 퀄리티의 결과물을 직접 만져볼수 있을듯 하다. 방향성을 이해하는데 매우 도움이 되었음.