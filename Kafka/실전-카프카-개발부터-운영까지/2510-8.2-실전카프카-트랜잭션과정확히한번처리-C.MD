# ğŸ§© Chapter 8.2 â€” íŠ¸ëœì­ì…˜ (Transactions)

## 1ï¸âƒ£ íŠ¸ëœì­ì…˜ì˜ ëª©ì ê³¼ ë“±ì¥ ë°°ê²½

Kafkaì˜ **íŠ¸ëœì­ì…˜ ê¸°ëŠ¥(Transaction)** ì€ â€œì •í™•íˆ í•œ ë²ˆ(exactly-once)â€ ì²˜ë¦¬ë¥¼ ë³´ì¥í•˜ê¸° ìœ„í•´ ë„ì…ë˜ì—ˆìŠµë‹ˆë‹¤.
ì¦‰, **ì…ë ¥ ë ˆì½”ë“œê°€ í•œ ë²ˆë§Œ ì²˜ë¦¬ë˜ê³ , ê·¸ ê²°ê³¼ê°€ ì¤‘ë³µ ì—†ì´ ì •í™•íˆ í•œ ë²ˆë§Œ ë°˜ì˜**ë˜ëŠ” ê²ƒì„ ë³´ì¥í•©ë‹ˆë‹¤.

* Kafka Streams, Spark, Flink ë“± ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬ í”„ë ˆì„ì›Œí¬ì—ì„œ ì •í™•ì„±ì„ ë†’ì´ê¸° ìœ„í•œ ê¸°ë°˜ ê¸°ëŠ¥
* ì£¼ë¡œ â€œì½ê¸° â†’ ì²˜ë¦¬ â†’ ì“°ê¸°â€ íŒ¨í„´ì—ì„œ ì›ìì„±(Atomicity)ì„ ë³´ì¥í•˜ê¸° ìœ„í•´ ì‚¬ìš©ë¨

---

## 2ï¸âƒ£ íŠ¸ëœì­ì…˜ì´ í•„ìš”í•œ ì´ìœ 

### (1) ì• í”Œë¦¬ì¼€ì´ì…˜ í¬ë˜ì‹œ

* ë©”ì‹œì§€ëŠ” ì“°ì˜€ì§€ë§Œ ì˜¤í”„ì…‹ì´ ì»¤ë°‹ë˜ì§€ ì•Šì€ ê²½ìš° â†’ ì¬ì‹œì‘ ì‹œ **ì¤‘ë³µ ì²˜ë¦¬ ë°œìƒ**

### (2) ì¢€ë¹„ ì• í”Œë¦¬ì¼€ì´ì…˜(Zombie)

* ë„¤íŠ¸ì›Œí¬ ë‹¨ì ˆ ë“±ìœ¼ë¡œ ë¸Œë¡œì»¤ì—ì„œ â€œì£½ì—ˆë‹¤â€ê³  íŒë‹¨ëœ ì»¨ìŠˆë¨¸ê°€
  ë‹¤ì‹œ ì‚´ì•„ë‚˜ ì´ì „ ë©”ì‹œì§€ë¥¼ ë‹¤ì‹œ ì“°ëŠ” ìƒí™©
* ê²°ê³¼: **ì¤‘ë³µëœ ë©”ì‹œì§€ ë°œìƒ**

---

## 3ï¸âƒ£ íŠ¸ëœì­ì…˜ì´ â€œì •í™•íˆ í•œ ë²ˆâ€ì„ ë³´ì¥í•˜ëŠ” ë°©ì‹

KafkaëŠ” ë‹¤ìŒ ë‘ ê°€ì§€ë¥¼ ë™ì‹œì— ì›ìì ìœ¼ë¡œ ì²˜ë¦¬í•©ë‹ˆë‹¤:

* **ê²°ê³¼ ë©”ì‹œì§€ â†’ ì¶œë ¥ í† í”½ì— ì“°ê¸°**
* **ì˜¤í”„ì…‹ â†’ consumer_offsets í† í”½ì— ì“°ê¸°**

> ì¦‰, ë‘˜ ì¤‘ í•˜ë‚˜ë§Œ ì„±ê³µí•˜ê±°ë‚˜ ì‹¤íŒ¨í•˜ëŠ” ì¼ì´ ì—†ë„ë¡ í•¨

### ì›ìì  ë‹¤ì¤‘ íŒŒí‹°ì…˜ ì“°ê¸° (Atomic Multi-Partition Write)

![](https://kafka.apache.org/27/images/transactions-diagram.png)

* transactional.id ì„¤ì •ì„ í†µí•´ íŠ¸ëœì­ì…˜ í”„ë¡œë“€ì„œ ì‹ë³„
* initTransactions() â†’ beginTransaction() â†’ send() â†’ commitTransaction() ìˆœì„œë¡œ ìˆ˜í–‰
* Zombie fencing: ë™ì¼í•œ transactional.id ì‚¬ìš© ì‹œ, ë‚®ì€ epoch í”„ë¡œë“€ì„œëŠ” **FencedProducer ì˜ˆì™¸ ë°œìƒ**

---

## 4ï¸âƒ£ íŠ¸ëœì­ì…˜ìœ¼ë¡œ í•´ê²°í•  ìˆ˜ ì—†ëŠ” ë¬¸ì œë“¤

| ìƒí™©                                 | ì´ìœ                         |
| ---------------------------------- | ------------------------- |
| ì´ë©”ì¼Â·ì™¸ë¶€ API í˜¸ì¶œ ë“± ë¶€ìˆ˜íš¨ê³¼ (side effect) | Kafka ë‚´ë¶€ íŠ¸ëœì­ì…˜ì— í¬í•¨ë˜ì§€ ì•ŠìŒ    |
| Kafka â†’ DB ì €ì¥                      | JDBCëŠ” Kafka íŠ¸ëœì­ì…˜ê³¼ ì—°ê²°ë˜ì§€ ì•ŠìŒ |
| DB â†’ Kafka â†’ ë‹¤ë¥¸ DB                 | íŠ¸ëœì­ì…˜ ê²½ê³„ê°€ Kafka ì™¸ë¶€ë¡œ í™•ì¥ ë¶ˆê°€  |
| í´ëŸ¬ìŠ¤í„° ê°„ ë³µì œ (MirrorMaker 2)          | ë³µì œëŠ” ê°€ëŠ¥í•˜ì§€ë§Œ íŠ¸ëœì­ì…˜ ì›ìì„±ì€ ë³´ì¥ ë¶ˆê°€ |
| Pub/Sub êµ¬ì¡°                         | êµ¬ë…ìê°€ íŠ¸ëœì­ì…˜ ê²½ê³„ë¥¼ ì™„ì „íˆ ì½ì§€ ëª»í•¨   |

ğŸ’¡ **í•´ê²°ì±…:**
ì™¸ë¶€ DB ì—°ë™ ì‹œì—” **Outbox Pattern** ì‚¬ìš©ì´ ê¶Œì¥ë©ë‹ˆë‹¤.

* ì„œë¹„ìŠ¤ê°€ Outbox í…Œì´ë¸”ì— ì´ë²¤íŠ¸ë¥¼ ì €ì¥
* ë³„ë„ Relay í”„ë¡œì„¸ìŠ¤ê°€ Kafkaë¡œ ë°œí–‰
  ğŸ‘‰ DBì™€ Kafka ì‚¬ì´ì˜ ì¼ê´€ì„± ìœ ì§€ ê°€ëŠ¥

ì°¸ê³ : [Debezium Outbox Pattern](https://debezium.io/blog/2019/02/19/reliable-microservices-data-exchange-with-the-outbox-pattern/)

---

## 5ï¸âƒ£ íŠ¸ëœì­ì…˜ ì‚¬ìš©ë²• (API ì˜ˆì‹œ)

Kafka Streamsì—ì„œëŠ” ì„¤ì • í•œ ì¤„ì´ë©´ ë:

```properties
processing.guarantee=exactly_once_v2
```

ì§ì ‘ APIë¥¼ ì‚¬ìš©í•  ê²½ìš° (Producer + Consumer):

```kotlin
val producerProps = Properties().apply {
    put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092")
    put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, "invoice-tx-producer-1")
}

val consumerProps = Properties().apply {
    put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092")
    put(ConsumerConfig.GROUP_ID_CONFIG, "invoice-processor")
    put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, "false")
    put(ConsumerConfig.ISOLATION_LEVEL_CONFIG, "read_committed")
}
```

---

# ğŸ’» ì˜ˆì œ: ë¹„ì¦ˆë‹ˆìŠ¤ ë„ë©”ì¸ ê¸°ë°˜ íŠ¸ëœì­ì…˜ ì²˜ë¦¬

## ğŸ§¾ ë„ë©”ì¸: â€œê²°ì œ ì²˜ë¦¬ ì‹œìŠ¤í…œ (InvoiceProcessor)â€

### ğŸ§© As-Is (íŠ¸ëœì­ì…˜ ë¯¸ì ìš©)

```kotlin
fun processInvoicesWithoutTx() {
    consumer.subscribe(listOf("invoice-events"))
    while (true) {
        val records = consumer.poll(Duration.ofMillis(200))
        for (record in records) {
            val invoice = deserialize(record.value())
            // âœ… ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§: ê²°ì œ ìƒíƒœ ì—…ë°ì´íŠ¸
            paymentService.process(invoice)

            // âŒ íŠ¸ëœì­ì…˜ ë¯¸ë³´ì¥: commit ì‹¤íŒ¨ ì‹œ ì¤‘ë³µ ì²˜ë¦¬ ê°€ëŠ¥
            producer.send(ProducerRecord("invoice-processed", invoice.id, invoice.toJson()))
            consumer.commitSync() 
        }
    }
}
```

ë¬¸ì œì :

* commit ì´ì „ crash â†’ **ì¤‘ë³µ ë°œìƒ**
* consumerì™€ producerì˜ ì‘ì—…ì´ **ì›ìì ì´ì§€ ì•ŠìŒ**

---

### ğŸ’¡ To-Be (íŠ¸ëœì­ì…˜ ì ìš©)

```kotlin
fun processInvoicesWithTx() {
    producer.initTransactions()
    consumer.subscribe(listOf("invoice-events"))

    while (true) {
        val records = consumer.poll(Duration.ofMillis(200))
        if (records.isEmpty) continue

        try {
            producer.beginTransaction()

            for (record in records) {
                val invoice = deserialize(record.value())
                paymentService.process(invoice)
                producer.send(ProducerRecord("invoice-processed", invoice.id, invoice.toJson()))
            }

            val offsets = records.partitions().associateWith {
                val offset = records.records(it).last().offset()
                OffsetAndMetadata(offset + 1)
            }
            // âœ… ì˜¤í”„ì…‹ì„ íŠ¸ëœì­ì…˜ì— í¬í•¨
            producer.sendOffsetsToTransaction(offsets, consumer.groupMetadata())

            producer.commitTransaction()
        } catch (e: Exception) {
            producer.abortTransaction()
            consumer.seekToCommitted(records.partitions())
        }
    }
}
```

ğŸ” ì„¤ëª…:

* `producer.beginTransaction()` â†’ íŠ¸ëœì­ì…˜ ì‹œì‘
* `sendOffsetsToTransaction()` â†’ ì˜¤í”„ì…‹ ì»¤ë°‹ë„ íŠ¸ëœì­ì…˜ì— í¬í•¨
* `commitTransaction()` â†’ ì„±ê³µ ì‹œ ì›ìì  ë°˜ì˜
* `abortTransaction()` â†’ ì‹¤íŒ¨ ì‹œ ì „ì²´ ë¡¤ë°±

---

## âœ… Kotest í…ŒìŠ¤íŠ¸ ì˜ˆì‹œ

```kotlin
class InvoiceProcessorTxTest : StringSpec({

    "íŠ¸ëœì­ì…˜ ì„±ê³µ ì‹œ ì˜¤í”„ì…‹ê³¼ ë©”ì‹œì§€ê°€ í•¨ê»˜ ì»¤ë°‹ë˜ì–´ì•¼ í•œë‹¤" {
        val txProducer = mockk<TransactionProducer>()
        val txConsumer = mockk<TransactionConsumer>()

        every { txProducer.commitTransaction() } returns Unit
        every { txConsumer.commitOffsets() } returns true

        val processor = InvoiceProcessor(txProducer, txConsumer)
        processor.processBatch(listOf(invoice("A1"), invoice("A2")))

        verify { txProducer.commitTransaction() }
        verify { txConsumer.commitOffsets() }
    }

    "íŠ¸ëœì­ì…˜ ì‹¤íŒ¨ ì‹œ ì „ì²´ê°€ ë¡¤ë°±ë˜ì–´ì•¼ í•œë‹¤" {
        val txProducer = mockk<TransactionProducer>()
        every { txProducer.commitTransaction() } throws RuntimeException("DB error")

        val processor = InvoiceProcessor(txProducer, mockk())
        shouldThrow<RuntimeException> { processor.processBatch(listOf(invoice("A1"))) }

        verify { txProducer.abortTransaction() }
    }
})
```

---

## ğŸ§­ 6ï¸âƒ£ íŠ¸ëœì­ì…˜ ë‚´ë¶€ ë™ì‘ ëª¨ë¸ (ìš”ì•½)

| ë‹¨ê³„                             | ë™ì‘                 | ì„¤ëª…                         |
| ------------------------------ | ------------------ | -------------------------- |
| 1ï¸âƒ£ initTransactions()         | íŠ¸ëœì­ì…˜ ë“±ë¡ ë° epoch ì¦ê°€ | ì¢€ë¹„ íœì‹±                      |
| 2ï¸âƒ£ beginTransaction()         | ë‚´ë¶€ ìƒíƒœ ë³€ê²½           | íŠ¸ëœì­ì…˜ ì‹œì‘                    |
| 3ï¸âƒ£ send()                     | ë©”ì‹œì§€ ì „ì†¡             | íŒŒí‹°ì…˜ ë“±ë¡ë¨                    |
| 4ï¸âƒ£ sendOffsetsToTransaction() | ì˜¤í”„ì…‹ í¬í•¨             | ì›ìì  ì»¤ë°‹ ëŒ€ìƒ                  |
| 5ï¸âƒ£ commitTransaction()        | ì»¤ë°‹ ë§ˆì»¤ ê¸°ë¡           | __transaction_state í† í”½ì— ì €ì¥ |
| 6ï¸âƒ£ abortTransaction()         | ë¡¤ë°± ìˆ˜í–‰              | ì‹¤íŒ¨ ì‹œ ì „ì²´ ì·¨ì†Œ                 |

---

## ğŸ’­ GPT í•´ì„¤ (ì±•í„°ë³„ ì²¨ì–¸)

| êµ¬ë¶„            | í•´ì„¤                                                                                                                               |
| ------------- | -------------------------------------------------------------------------------------------------------------------------------- |
| **8.2.1~2.3** | íŠ¸ëœì­ì…˜ì´ â€œì •í™•íˆ í•œ ë²ˆâ€ì„ ë§Œë“œëŠ” í•µì‹¬ì€ producer+consumer ê°„ì˜ *ì›ìì„± ì—°ê²°*ì´ë‹¤. ê°œë°œìëŠ” ì´ ë¶€ë¶„ì„ ì§ì ‘ ì‹ ê²½ì“°ê¸°ë³´ë‹¤ Kafkaê°€ ì œê³µí•˜ëŠ” ì¶”ìƒí™”ë¥¼ ì˜ ì´ìš©í•´ì•¼ í•œë‹¤.                       |
| **8.2.4**     | â€œíŠ¸ëœì­ì…˜ì´ ì „ë¶€ë¥¼ í•´ê²°í•˜ì§€ ì•ŠëŠ”ë‹¤â€ëŠ” ì ì´ ì¤‘ìš”í•˜ë‹¤. KafkaëŠ” DBë‚˜ ì™¸ë¶€ ì‹œìŠ¤í…œì˜ ACIDë¥¼ ëŒ€ì‹ í•  ìˆ˜ ì—†ìœ¼ë©°, Outbox Pattern ê°™ì€ ì™¸ë¶€ ë³´ì™„ì±…ì´ í•„ìˆ˜ë‹¤.                                |
| **8.2.5~2.7** | íŠ¸ëœì­ì…˜ì„ ì œëŒ€ë¡œ ì“°ë ¤ë©´ init â†’ begin â†’ send â†’ offset â†’ commit íŒ¨í„´ì„ ëª…í™•íˆ ì´í•´í•´ì•¼ í•œë‹¤. íŠ¹íˆ transactional.id ê´€ë¦¬ê°€ í•µì‹¬ì´ë©°, ì§§ê²Œ ìƒì„±/íŒŒê¸°í•˜ë©´ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ê¹Œì§€ ìœ ë°œí•  ìˆ˜ ìˆë‹¤. |

---

# ğŸ§¾ ìš”ì•½ ì •ë¦¬

| í•­ëª©                   | í•µì‹¬ ìš”ì•½                                       |
| -------------------- | ------------------------------------------- |
| **íŠ¸ëœì­ì…˜ ëª©ì **          | â€œì •í™•íˆ í•œ ë²ˆâ€ ì˜ë¯¸ êµ¬ì¡° ë³´ì¥ (exactly-once semantics) |
| **í•µì‹¬ ë©”ì»¤ë‹ˆì¦˜**          | ì˜¤í”„ì…‹ ì»¤ë°‹ê³¼ ë©”ì‹œì§€ ì“°ê¸°ë¥¼ ì›ìì ìœ¼ë¡œ ì²˜ë¦¬                    |
| **Zombie ë°©ì§€**        | transactional.id + epoch fencing            |
| **í•œê³„**               | ì™¸ë¶€ ì‹œìŠ¤í…œ(DB, REST ë“±)ì€ í¬í•¨ë˜ì§€ ì•ŠìŒ                 |
| **í•´ê²°ì±…**              | Outbox Pattern, ë©±ë“±ì  ì—°ì‚° ì„¤ê³„                   |
| **Kafka Streams ì„¤ì •** | `processing.guarantee=exactly_once_v2`      |
| **API í•µì‹¬ íë¦„**        | init â†’ begin â†’ send â†’ offsets â†’ commit      |
