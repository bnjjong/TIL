# 🧩 Chapter 8.2 — 트랜잭션 (Transactions)

## 1️⃣ 트랜잭션의 목적과 등장 배경

Kafka의 **트랜잭션 기능(Transaction)** 은 “정확히 한 번(exactly-once)” 처리를 보장하기 위해 도입되었습니다.
즉, **입력 레코드가 한 번만 처리되고, 그 결과가 중복 없이 정확히 한 번만 반영**되는 것을 보장합니다.

* Kafka Streams, Spark, Flink 등 스트림 처리 프레임워크에서 정확성을 높이기 위한 기반 기능
* 주로 “읽기 → 처리 → 쓰기” 패턴에서 원자성(Atomicity)을 보장하기 위해 사용됨

---

## 2️⃣ 트랜잭션이 필요한 이유

### (1) 애플리케이션 크래시

* 메시지는 쓰였지만 오프셋이 커밋되지 않은 경우 → 재시작 시 **중복 처리 발생**

### (2) 좀비 애플리케이션(Zombie)

* 네트워크 단절 등으로 브로커에서 “죽었다”고 판단된 컨슈머가
  다시 살아나 이전 메시지를 다시 쓰는 상황
* 결과: **중복된 메시지 발생**

---

## 3️⃣ 트랜잭션이 “정확히 한 번”을 보장하는 방식

Kafka는 다음 두 가지를 동시에 원자적으로 처리합니다:

* **결과 메시지 → 출력 토픽에 쓰기**
* **오프셋 → consumer_offsets 토픽에 쓰기**

> 즉, 둘 중 하나만 성공하거나 실패하는 일이 없도록 함

### 원자적 다중 파티션 쓰기 (Atomic Multi-Partition Write)

![](https://kafka.apache.org/27/images/transactions-diagram.png)

* transactional.id 설정을 통해 트랜잭션 프로듀서 식별
* initTransactions() → beginTransaction() → send() → commitTransaction() 순서로 수행
* Zombie fencing: 동일한 transactional.id 사용 시, 낮은 epoch 프로듀서는 **FencedProducer 예외 발생**

---

## 4️⃣ 트랜잭션으로 해결할 수 없는 문제들

| 상황                                 | 이유                        |
| ---------------------------------- | ------------------------- |
| 이메일·외부 API 호출 등 부수효과 (side effect) | Kafka 내부 트랜잭션에 포함되지 않음    |
| Kafka → DB 저장                      | JDBC는 Kafka 트랜잭션과 연결되지 않음 |
| DB → Kafka → 다른 DB                 | 트랜잭션 경계가 Kafka 외부로 확장 불가  |
| 클러스터 간 복제 (MirrorMaker 2)          | 복제는 가능하지만 트랜잭션 원자성은 보장 불가 |
| Pub/Sub 구조                         | 구독자가 트랜잭션 경계를 완전히 읽지 못함   |

💡 **해결책:**
외부 DB 연동 시엔 **Outbox Pattern** 사용이 권장됩니다.

* 서비스가 Outbox 테이블에 이벤트를 저장
* 별도 Relay 프로세스가 Kafka로 발행
  👉 DB와 Kafka 사이의 일관성 유지 가능

참고: [Debezium Outbox Pattern](https://debezium.io/blog/2019/02/19/reliable-microservices-data-exchange-with-the-outbox-pattern/)

---

## 5️⃣ 트랜잭션 사용법 (API 예시)

Kafka Streams에서는 설정 한 줄이면 끝:

```properties
processing.guarantee=exactly_once_v2
```

직접 API를 사용할 경우 (Producer + Consumer):

```kotlin
val producerProps = Properties().apply {
    put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092")
    put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, "invoice-tx-producer-1")
}

val consumerProps = Properties().apply {
    put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092")
    put(ConsumerConfig.GROUP_ID_CONFIG, "invoice-processor")
    put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, "false")
    put(ConsumerConfig.ISOLATION_LEVEL_CONFIG, "read_committed")
}
```

---

# 💻 예제: 비즈니스 도메인 기반 트랜잭션 처리

## 🧾 도메인: “결제 처리 시스템 (InvoiceProcessor)”

### 🧩 As-Is (트랜잭션 미적용)

```kotlin
fun processInvoicesWithoutTx() {
    consumer.subscribe(listOf("invoice-events"))
    while (true) {
        val records = consumer.poll(Duration.ofMillis(200))
        for (record in records) {
            val invoice = deserialize(record.value())
            // ✅ 비즈니스 로직: 결제 상태 업데이트
            paymentService.process(invoice)

            // ❌ 트랜잭션 미보장: commit 실패 시 중복 처리 가능
            producer.send(ProducerRecord("invoice-processed", invoice.id, invoice.toJson()))
            consumer.commitSync() 
        }
    }
}
```

문제점:

* commit 이전 crash → **중복 발생**
* consumer와 producer의 작업이 **원자적이지 않음**

---

### 💡 To-Be (트랜잭션 적용)

```kotlin
fun processInvoicesWithTx() {
    producer.initTransactions()
    consumer.subscribe(listOf("invoice-events"))

    while (true) {
        val records = consumer.poll(Duration.ofMillis(200))
        if (records.isEmpty) continue

        try {
            producer.beginTransaction()

            for (record in records) {
                val invoice = deserialize(record.value())
                paymentService.process(invoice)
                producer.send(ProducerRecord("invoice-processed", invoice.id, invoice.toJson()))
            }

            val offsets = records.partitions().associateWith {
                val offset = records.records(it).last().offset()
                OffsetAndMetadata(offset + 1)
            }
            // ✅ 오프셋을 트랜잭션에 포함
            producer.sendOffsetsToTransaction(offsets, consumer.groupMetadata())

            producer.commitTransaction()
        } catch (e: Exception) {
            producer.abortTransaction()
            consumer.seekToCommitted(records.partitions())
        }
    }
}
```

🔍 설명:

* `producer.beginTransaction()` → 트랜잭션 시작
* `sendOffsetsToTransaction()` → 오프셋 커밋도 트랜잭션에 포함
* `commitTransaction()` → 성공 시 원자적 반영
* `abortTransaction()` → 실패 시 전체 롤백

---

## ✅ Kotest 테스트 예시

```kotlin
class InvoiceProcessorTxTest : StringSpec({

    "트랜잭션 성공 시 오프셋과 메시지가 함께 커밋되어야 한다" {
        val txProducer = mockk<TransactionProducer>()
        val txConsumer = mockk<TransactionConsumer>()

        every { txProducer.commitTransaction() } returns Unit
        every { txConsumer.commitOffsets() } returns true

        val processor = InvoiceProcessor(txProducer, txConsumer)
        processor.processBatch(listOf(invoice("A1"), invoice("A2")))

        verify { txProducer.commitTransaction() }
        verify { txConsumer.commitOffsets() }
    }

    "트랜잭션 실패 시 전체가 롤백되어야 한다" {
        val txProducer = mockk<TransactionProducer>()
        every { txProducer.commitTransaction() } throws RuntimeException("DB error")

        val processor = InvoiceProcessor(txProducer, mockk())
        shouldThrow<RuntimeException> { processor.processBatch(listOf(invoice("A1"))) }

        verify { txProducer.abortTransaction() }
    }
})
```

---

## 🧭 6️⃣ 트랜잭션 내부 동작 모델 (요약)

| 단계                             | 동작                 | 설명                         |
| ------------------------------ | ------------------ | -------------------------- |
| 1️⃣ initTransactions()         | 트랜잭션 등록 및 epoch 증가 | 좀비 펜싱                      |
| 2️⃣ beginTransaction()         | 내부 상태 변경           | 트랜잭션 시작                    |
| 3️⃣ send()                     | 메시지 전송             | 파티션 등록됨                    |
| 4️⃣ sendOffsetsToTransaction() | 오프셋 포함             | 원자적 커밋 대상                  |
| 5️⃣ commitTransaction()        | 커밋 마커 기록           | __transaction_state 토픽에 저장 |
| 6️⃣ abortTransaction()         | 롤백 수행              | 실패 시 전체 취소                 |

---

## 💭 GPT 해설 (챕터별 첨언)

| 구분            | 해설                                                                                                                               |
| ------------- | -------------------------------------------------------------------------------------------------------------------------------- |
| **8.2.1~2.3** | 트랜잭션이 “정확히 한 번”을 만드는 핵심은 producer+consumer 간의 *원자성 연결*이다. 개발자는 이 부분을 직접 신경쓰기보다 Kafka가 제공하는 추상화를 잘 이용해야 한다.                       |
| **8.2.4**     | “트랜잭션이 전부를 해결하지 않는다”는 점이 중요하다. Kafka는 DB나 외부 시스템의 ACID를 대신할 수 없으며, Outbox Pattern 같은 외부 보완책이 필수다.                                |
| **8.2.5~2.7** | 트랜잭션을 제대로 쓰려면 init → begin → send → offset → commit 패턴을 명확히 이해해야 한다. 특히 transactional.id 관리가 핵심이며, 짧게 생성/파기하면 메모리 누수까지 유발할 수 있다. |

---

# 🧾 요약 정리

| 항목                   | 핵심 요약                                       |
| -------------------- | ------------------------------------------- |
| **트랜잭션 목적**          | “정확히 한 번” 의미 구조 보장 (exactly-once semantics) |
| **핵심 메커니즘**          | 오프셋 커밋과 메시지 쓰기를 원자적으로 처리                    |
| **Zombie 방지**        | transactional.id + epoch fencing            |
| **한계**               | 외부 시스템(DB, REST 등)은 포함되지 않음                 |
| **해결책**              | Outbox Pattern, 멱등적 연산 설계                   |
| **Kafka Streams 설정** | `processing.guarantee=exactly_once_v2`      |
| **API 핵심 흐름**        | init → begin → send → offsets → commit      |
