# 🧩 8장 – 정확히 한 번 의미 구조 (Exactly Once Semantics)

## 8.1 멱등적 프로듀서 (Idempotent Producer)

### 8.1.1 개념 및 배경

* **멱등성(Idempotence)**:
  동일한 작업을 여러 번 실행해도 결과가 변하지 않는 성질.
  예)

    * `UPDATE t SET X = X + 1 WHERE Y = 5` → 멱등 아님
    * `UPDATE t SET X = 18 WHERE Y = 5` → 멱등

* **Kafka에서의 필요성**:
  네트워크 오류, 브로커 장애, 타임아웃 등으로 프로듀서가 동일 메시지를 재전송할 수 있다.
  이때 멱등성이 없으면 **중복 메시지**가 저장될 위험이 있음 → 재고, 결제, 배송 등의 도메인에서는 치명적 오류.

---

### 8.1.2 작동 원리

Kafka는 **프로듀서 ID(PID)** 와 **시퀀스 넘버(sequence ID)** 를 조합해 각 메시지를 고유하게 식별한다.

| 구성요소                         | 설명                      |
| ---------------------------- | ----------------------- |
| Producer ID (PID)            | 프로듀서가 브로커로부터 부여받는 고유 ID |
| Sequence Number              | 파티션별 메시지의 순차 번호         |
| (PID + Partition + Sequence) | 메시지 고유 식별자              |

* 브로커는 각 파티션에 대해 **최근 5개의 시퀀스 넘버**를 추적함.
* 중복 메시지 수신 시 브로커는 **에러를 발생시켜 메시지를 거부**.
* `max.in.flight.requests.per.connection` ≤ 5 (기본값 5)로 유지해야 함.
    * 하나의 연결(Connection) 당 브로커로 동시에 보낼 수 있는 요청(request)의 개수
    * 나름 5라는 기본값을 심도있게 고민하여 결정함.
    * 6이 되는 순간 아래와 같은 상황이 발생할수도 있다.
        * 요청1(seq=1), 요청2(seq=2), ..., 요청6(seq=6)
        * 도착 순서: 4 → 5 → 6 → 1 → 2 → 3
        * 브로커 [4,5,6,7,8] 기억
        * 1번 도착시 브로커 메모리에 없으므로 새로운 메시지인지 중복인지 판단 불가가 될수 있음.

---

### 8.1.3 장애 상황 처리

#### ① 프로듀서 장애

* 재시작 시 **새로운 PID**를 부여받음.
* 따라서, 이전 프로듀서와 새로운 프로듀서가 동일 메시지를 전송해도 Kafka는 이를 **중복으로 인식하지 못함**.
* 즉, **프로듀서 재시작 후 멱등성은 유지되지 않음**.

#### ② 브로커 장애

* 컨트롤러가 새 리더 선출 → 팔로워가 리더가 되면 인메모리 상태(최근 5개 시퀀스 번호)를 복제하여 유지.
* 장애 브로커 복구 시 스냅샷 파일을 통해 **Producer 상태를 복원**.

> 만약 메시지가 전혀 없는 파티션이라면?
> 중복이 없으므로 바로 새 상태를 생성 가능.

---

### 8.1.4 한계점

| 구분         | 설명                            |
| ---------- | ----------------------------- |
| 프로듀서 재시작   | 새 PID로 인해 이전 메시지 중복 감지 불가     |
| 여러 인스턴스    | 여러 프로듀서가 동일 메시지 전송 시 중복 감지 불가 |
| 애플리케이션 재시도 | 애플리케이션에서 직접 재시도 시 중복 발생 가능    |

👉 **프로듀서 내부의 재시도 로직**을 사용하는 것이 가장 안전함 (`retries` 옵션 활용).

---

### 8.1.5 설정 방법

* 설정 항목:

  ```properties
  enable.idempotence=true
  acks=all
  ```

  ※ Kafka 3.0 이후는 기본적으로 `true`.

* 추가 동작 변화:

    * 프로듀서 초기화 시 PID 요청 API 추가 호출
    * 각 메시지 배치에 PID + Sequence 번호 포함 (96bit 오버헤드)
    * 장애 시에도 순서 보장 (`max.in.flight.requests.per.connection ≤ 5`)

---

### 8.1.6 개선 사항 (Kafka 2.5 이후)

* **KIP-360**: UNKNOWN_PRODUCER_ID 오류 대폭 감소.
* 시퀀스 넘버 유지 강화, 파티션 재할당 시 안정성 향상.
* **치명적 에러 시 전체 배치 거부 → 애플리케이션이 처리 결정 가능**.

---

## ✅ 요약

| 항목    | 내용                                    |
| ----- | ------------------------------------- |
| 핵심 목적 | 중복 메시지 방지 (Exactly-Once 전 단계)         |
| 주요 구성 | PID + Sequence Number                 |
| 필요 설정 | `enable.idempotence=true`, `acks=all` |
| 한계    | 재시작 시 PID 변경 → 중복 감지 불가               |
| 권장    | 프로듀서 내부 재시도 사용, 설정 안정화 확인             |
| 개선    | Kafka 2.5 이후 에러 처리 강화                 |

---

## 💡 GPT 코멘트

> 멱등성은 단순히 “한 번만 처리”의 문제가 아니라, **“비즈니스 상태의 일관성”** 을 지키는 기술이에요.
> 즉, **도메인 이벤트를 재처리해도 시스템 상태가 변하지 않아야** 합니다.

---

# 💻 Kotlin 예제 (도메인 로직 기반)

## 📍 시나리오

* 광고 클릭 이벤트(`AdClickEvent`)가 Kafka로 전송됨.
* 중복 메시지 방지를 위해 **멱등적 프로듀서 설정**을 적용.

---

### 🧩 As-Is (비멱등적 프로듀서)

```kotlin
// 중복 클릭 이벤트 발생 가능 (같은 이벤트가 여러 번 전송될 수 있음)
fun sendClickEvent(adId: String, userId: String) {
    val producer = KafkaProducer<String, String>(
        mapOf(
            "bootstrap.servers" to "localhost:9092",
            "key.serializer" to "org.apache.kafka.common.serialization.StringSerializer",
            "value.serializer" to "org.apache.kafka.common.serialization.StringSerializer"
        )
    )

    val record = ProducerRecord("ad-clicks", adId, """{"adId":"$adId","userId":"$userId"}""")
    producer.send(record)
    producer.close()
}
```

---

### ✅ To-Be (멱등적 프로듀서 적용)

```kotlin
fun sendClickEventIdempotent(adId: String, userId: String) {
    val producer = KafkaProducer<String, String>(
        mapOf(
            "bootstrap.servers" to "localhost:9092",
            "enable.idempotence" to "true",    // 멱등성 활성화
            "acks" to "all",                   // 모든 리더 복제 완료 후 응답
            "retries" to "3",                  // 내부 재시도
            "max.in.flight.requests.per.connection" to "5",
            "key.serializer" to "org.apache.kafka.common.serialization.StringSerializer",
            "value.serializer" to "org.apache.kafka.common.serialization.StringSerializer"
        )
    )

    val eventJson = """{"adId":"$adId","userId":"$userId"}"""
    val record = ProducerRecord("ad-clicks", adId, eventJson)

    // 동일 메시지 재전송에도 Kafka가 자동 중복 제거
    producer.send(record)
    producer.close()
}
```

---

### 🧪 Kotest 테스트 예시

```kotlin
class AdClickProducerTest : StringSpec({

    "멱등적 프로듀서가 동일 메시지를 중복 저장하지 않아야 한다" {
        val adId = "AD-1234"
        val userId = "USER-99"

        sendClickEventIdempotent(adId, userId)
        sendClickEventIdempotent(adId, userId) // 중복 시도

        // 실제로는 Kafka consumer group에서 consume 후 중복 key 여부 검증 가능
        // 테스트에서는 단순히 중복 key가 없는 Kafka 상태라고 가정
        val result = checkKafkaMessageCount(topic = "ad-clicks", key = adId)
        result shouldBe 1
    }
})
```

---

# 🌐 참고 자료

* [Apache Kafka Official — Idempotent Producer Guide](https://kafka.apache.org/documentation/#producerconfigs_enable.idempotence)
* [KIP-360: Improve Idempotent and Transactional Producer](https://cwiki.apache.org/confluence/display/KAFKA/KIP-360%3A+Improve+Idempotent+and+Transactional+Producer)
* [KIP-679: Producer Strongest Delivery Guarantee by Default](https://cwiki.apache.org/confluence/display/KAFKA/KIP-679%3A+Producer+will+enable+the+strongest+delivery+guarantee+by+default)

---
