## 📘 제3장: 카프카 프로듀서 — 카프카에 메시지 쓰기

### 3.1 프로듀서 개요

#### 💡 핵심 개념

* **KafkaProducer**는 데이터를 카프카 브로커로 전송하는 클라이언트다.
* 주요 사용 목적:

    * 사용자 행동 기록 (로그/이벤트 트래킹)
    * 성능 메트릭 수집
    * 비동기 시스템 간 데이터 전달
    * IoT 기기에서 수집된 데이터 스트리밍
* 사용 사례에 따라 **유실 허용 여부**, **중복 허용 여부**, **지연 시간(latency)**, **처리율(throughput)** 등의 요구사항이 달라진다.

| 사용 사례     | 메시지 손실 허용 | 지연 시간         | 처리율   |
| --------- | --------- | ------------- | ----- |
| 신용카드 트랜잭션 | ❌ 불가      | 낮음 (500ms 이내) | 매우 높음 |
| 웹 클릭 로그   | ⭕ 가능      | 높아도 무방        | 보통    |

#### ⚙️ 내부 동작 순서 (그림 3-1 요약)

1. `ProducerRecord` 객체 생성 → 토픽 / 키 / 밸류 지정
2. **직렬화(serializer)** 수행 → 바이트 배열로 변환
3. **파티셔너(partitioner)** → 전송할 파티션 결정
4. **레코드 배치(record batch)**에 추가
5. 백그라운드 스레드가 브로커로 전송
6. 성공 시 `RecordMetadata` 반환 / 실패 시 예외 발생

> ✏️ **ChatGPT 의견:**
> 이 부분은 Kafka의 핵심 설계 철학 “단순한 API, 복잡한 내부 최적화”를 잘 보여준다.
> 개발자는 단순히 `send()`만 호출하지만 내부에서는 직렬화 → 파티션 배치 → 전송 → 재시도까지 모든 과정을 자동 처리한다.

---

### 3.2 카프카 프로듀서 생성하기

#### 🔧 필수 설정 3가지

| 설정 키                | 설명                      |
| ------------------- | ----------------------- |
| `bootstrap.servers` | 브로커 주소 목록 (`host:port`) |
| `key.serializer`    | 키 직렬화 클래스               |
| `value.serializer`  | 값 직렬화 클래스               |

#### ✅ 기본 예제 (Java)

```java
Properties kafkaProps = new Properties();
kafkaProps.put("bootstrap.servers", "broker1:9092,broker2:9092");
kafkaProps.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");
kafkaProps.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");

KafkaProducer<String, String> producer = new KafkaProducer<>(kafkaProps);
```

> ✏️ **ChatGPT 의견:**
> `ProducerConfig` 상수를 직접 사용하는 것이 버전 2.x 이상에서는 더 안전함.
> 오타로 인한 설정 오류를 방지하고 IDE 자동완성도 지원됨.

---

### 3.3 카프카로 메시지 전달하기

Kafka는 메시지 전송을 **Fire-and-Forget**, **동기**, **비동기** 방식으로 지원한다.

#### 🚀 3가지 전송 방식 비교

| 전송 방식             | 설명                      | 장점         | 단점          |
| ----------------- | ----------------------- | ---------- | ----------- |
| Fire-and-Forget   | 단순히 `send()`만 호출, 결과 무시 | 빠름         | 유실 가능       |
| 동기(Synchronous)   | `send().get()`으로 결과 대기  | 신뢰성 높음     | 느림          |
| 비동기(Asynchronous) | 콜백 등록 후 응답 처리           | 성능과 신뢰성 균형 | 콜백 로직 관리 필요 |

---

#### ✅ Fire-and-Forget 예제 (Kotlin As-Is)

```kotlin
val record = ProducerRecord("CustomerCountry", "Precision Products", "France")

try {
    producer.send(record) // 결과를 기다리지 않음
} catch (e: Exception) {
    e.printStackTrace()
}
```

---

#### ✅ 동기 전송 예제 (Kotlin To-Be)

```kotlin
val record = ProducerRecord("CustomerCountry", "Precision Products", "France")

try {
    val metadata = producer.send(record).get() // 결과 대기
    println("메시지 전송 성공 - Topic: ${metadata.topic()}, Partition: ${metadata.partition()}, Offset: ${metadata.offset()}")
} catch (e: Exception) {
    println("전송 실패: ${e.message}")
}
```

> ✏️ **ChatGPT 의견:**
> 실제 서비스에서는 동기 전송을 거의 사용하지 않는다. 테스트나 초기 검증용으로만 적합하다.

---

#### ✅ 비동기 전송 예제 (Kotlin + 콜백)

```kotlin
val record = ProducerRecord("CustomerCountry", "Biomedical Materials", "USA")

producer.send(record) { metadata, exception ->
    if (exception != null) {
        println("전송 실패: ${exception.message}")
    } else {
        println("전송 성공 - ${metadata.topic()} [${metadata.partition()}] offset=${metadata.offset()}")
    }
}
```

> 💡 **주의:** 콜백 내부에서 블로킹 작업(파일 I/O, Thread.sleep 등)은 금지.
> 별도 스레드 풀로 위임해야 전송 스레드의 지연을 막을 수 있다.

---

### ✅ Kotest 기반 테스트 코드

```kotlin
class KafkaProducerTest : StringSpec({

    "비동기 메시지 전송 성공 시 콜백이 정상 호출되어야 한다" {
        val producer = mockk<KafkaProducer<String, String>>()
        val record = ProducerRecord("testTopic", "key", "value")

        every { producer.send(any(), any()) } answers {
            val callback = secondArg<Callback>()
            callback.onCompletion(mockk(relaxed = true), null)
            mockk() // Future 반환
        }

        var success = false
        producer.send(record) { _, e -> if (e == null) success = true }

        success shouldBe true
    }
})
```

---

## 🧭 요약 정리

| 구분          | 내용 요약                                                                 |
| ----------- | --------------------------------------------------------------------- |
| **3.1**     | 프로듀서의 역할, 내부 동작(직렬화 → 파티셔닝 → 배치 → 전송)                                 |
| **3.2**     | `bootstrap.servers`, `key.serializer`, `value.serializer` 필수 설정       |
| **3.3**     | Fire-and-Forget / Sync / Async 전송 방식 비교 및 예외 처리                       |
| **핵심 인사이트** | 프로듀서의 동작은 단순하지만 내부적으로 높은 병렬성과 안정성을 제공하며, 전송 방식 선택이 성능과 신뢰성의 균형을 결정한다. |

---

## 🔗 참고 링크

* Apache Kafka 공식 문서 (Producer Configs):
  [https://kafka.apache.org/documentation/#producerconfigs](https://kafka.apache.org/documentation/#producerconfigs)
* Confluent Blog – “Kafka Producer Best Practices”:
  [https://www.confluent.io/blog/kafka-producer-performance-best-practices/](https://www.confluent.io/blog/kafka-producer-performance-best-practices/)

---
