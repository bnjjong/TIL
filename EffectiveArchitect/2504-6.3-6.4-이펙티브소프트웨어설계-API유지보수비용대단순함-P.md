# 6장 API를 유지보수하기 위한 비용 대 단순함

## 6.3 의존성 라이브러리의 설정을 추상화하는 도구

### 핵심 내용

스트리밍 서비스는 **자신이 소유한 설정만 외부에 공개**하는 방식을 채택합니다. 이는 6.2절의 배치 도구와는 다른 접근 방식으로, 사용자로부터 클라우드 클라이언트의 생성과 구성을 추상화합니다.[1]

#### 주요 특징
- 스트리밍 도구의 최종 사용자는 기반 클라우드 클라이언트에 대해 알 필요가 없음
- 전용 `streaming` 절에서 모든 설정을 관리
- 사용자 이름/암호 인증 방식만 지원
- 요청 처리 시간 모니터링을 위한 `maxTimeMs` 설정 제공

#### StreamingServiceConfiguration 구조

```yaml
streaming:
  username: u
  password: p
  maxTimeMs: 100
```

### 6.3.1 스트리밍 도구 구성하기

스트리밍 서비스는 YAML 파일을 사용하며, 배치 도구와의 주요 차이점은 모든 설정을 `streaming` 절에서 공개한다는 것입니다.[1], [2]

#### 장점과 단점

**장점:**
- UX 관점에서 훨씬 더 단순함
- 클라우드 서비스의 구성이 사용자로부터 추상화됨
- 명확한 계약 정의

**단점:**
- 스트리밍 형식의 설정을 클라우드 클라이언트로 매핑하기 위한 유지보수 작업 필요
- 모든 다운스트림 라이브러리 설정을 도구 설정으로 매핑해야 함
- 많은 설정이 있는 경우 상당한 양의 코드 재작성 필요

### 개인 견해 (6.3)
설정 추상화는 마치 **어댑터 패턴**과 유사한 개념으로 보입니다. 사용자에게 깔끔한 인터페이스를 제공하지만 내부적으로는 복잡한 매핑 로직이 필요합니다. Spring Boot의 auto-configuration이 좋은 예시라고 생각합니다 - 개발자는 간단한 프로퍼티만 설정하면 되지만, 내부적으로는 많은 Bean 설정이 자동으로 이뤄집니다.

## 6.4 클라우드 클라이언트 라이브러리를 위해 새로운 설정 추가하기

클라우드 클라이언트에 새로운 타임아웃 설정이 추가되는 시나리오를 분석합니다.[1]

### 새로운 타임아웃 설정 구조

```yaml
auth:
  strategy: username-password
  username: user
  password: pass
timeouts:
  connection: 1000
```

### 6.4.1 배치 도구에 새로운 설정 추가하기

**특징:**
- 클라우드 호출자에서 클라이언트 빌더로 설정을 직접 전달
- 새로운 `timeouts` 절을 모든 클라이언트 구성에 추가해야 함
- **유지보수 비용이 거의 0에 가까움** (코드 변경 불필요)
- 원본 파일을 직접 전달하므로 CloudServiceClientBuilder가 YAML 파일에서 설정을 추출[1]

### 6.4.2 스트리밍 도구에 새로운 설정 추가하기

**특징:**
- 모든 설정을 전용 `streaming` 절 아래에서 소유
- 새로운 `connectionTimeout` 설정을 스트리밍 구성에 추가 필요
- **유지보수 비용이 발생** (코드 변경 필요)
- 프로그래밍 방식으로 클라우드 클라이언트를 생성하므로 매핑 코드 수정 필요[1], [3]

```yaml
streaming:
  username: u
  password: p
  maxTimeMs: 100
  connectionTimeout: 1000
```

### 6.4.3 UX 친화성과 유지보수성 측면에서 두 해법 비교

| 도구 이름 | 유지보수 비용 | UX |
|-----------|---------------|-----|
| 배치 도구 | 비용 없음 | 사용자가 새로운 설정을 추가할 필요가 있음 |
| 스트리밍 도구 | 비용 증가 | 사용자가 새로운 설정을 추가할 필요가 있음 |

#### 분석 결과

**배치 서비스:**
- 변경 사항을 최종 사용자에게 전파
- 유지보수 비용이 최종 사용자에게 전파됨
- 구성 파일이 직접 클라우드 클라이언트 빌더에 전달되므로 코드 변경 불필요

**스트리밍 서비스:**
- 클라우드 서비스 사용법을 추상화
- 모든 새로운 설정을 외부에 공개하고 스트리밍 서비스 형식으로 매핑 필요
- N개 서비스에서 클라우드 클라이언트를 사용한다면 N배로 유지보수 비용 증가[1], [4]

### 개인 견해 (6.4)
이는 **트레이드오프의 전형적인 사례**입니다. 마이크로서비스 아키텍처에서 자주 마주치는 문제로, Gateway 패턴과 비슷한 고민이라고 봅니다. 직접 통신 vs 중간 레이어를 두는 것의 차이점과 매우 유사합니다. 변경이 빈번하고 설정이 많다면 직접 전달 방식이, 안정적이고 사용자 경험이 중요하다면 추상화 방식이 더 적합할 것 같습니다.

## Kotlin 예제 코드

### As-Is: 직접 설정 전달 방식 (배치 도구 스타일)

```kotlin
// 도메인: 전자상거래 주문 처리 시스템
// As-Is: 클라우드 결제 서비스 설정을 직접 전달하는 방식

data class PaymentRequest(
    val orderId: String,
    val amount: BigDecimal,
    val currency: String,
    val customerId: String
)

// 클라우드 결제 서비스의 복잡한 설정 구조
data class CloudPaymentConfig(
    val authStrategy: AuthStrategy,
    val connectionTimeout: Int?,
    val readTimeout: Int?,
    val retryPolicy: RetryPolicy?
)

// As-Is: 직접 설정 전달 방식의 배치 결제 처리기
class BatchPaymentProcessor(
    private val configPath: String
) {
    private val cloudPaymentClient: CloudPaymentClient
    
    init {
        // YAML 파일을 직접 클라우드 클라이언트에 전달
        val yamlConfig = loadYamlConfig(configPath)
        cloudPaymentClient = CloudPaymentClientBuilder()
            .fromYamlConfig(yamlConfig) // 직접 전달!
            .build()
    }
    
    /**
     * 배치로 결제 요청들을 처리
     * - 설정 변경 시 사용자가 YAML 파일을 직접 수정해야 함
     * - 클라우드 서비스의 모든 설정을 알아야 함
     */
    fun processBatchPayments(requests: List<PaymentRequest>) {
        requests.chunked(getBatchSize()).forEach { batch ->
            batch.forEach { request ->
                try {
                    cloudPaymentClient.processPayment(request)
                    println("결제 처리 완료: ${request.orderId}")
                } catch (e: Exception) {
                    println("결제 처리 실패: ${request.orderId}, 오류: ${e.message}")
                }
            }
        }
    }
}
```

### To-Be: 추상화된 설정 방식 (스트리밍 도구 스타일)

```kotlin
// To-Be: 실시간 결제 처리를 위한 추상화된 설정 방식

// 사용자에게 노출되는 간단한 설정
data class StreamingPaymentConfig(
    val merchantId: String,
    val merchantSecret: String,
    val maxProcessingTimeMs: Long,
    val connectionTimeoutMs: Int = 5000 // 기본값 제공
)

// 실시간 결제 처리기 - 설정이 추상화됨
class StreamingPaymentProcessor private constructor(
    private val config: StreamingPaymentConfig,
    private val cloudPaymentClient: CloudPaymentClient
) {
    
    companion object {
        /**
         * 팩토리 메서드: 사용자 설정을 내부 클라우드 설정으로 변환
         * - 사용자는 클라우드 서비스의 세부사항을 알 필요 없음
         * - 설정 매핑 로직이 내부에 캡슐화됨
         */
        fun create(configPath: String): StreamingPaymentProcessor {
            val yamlConfig = loadYamlConfig(configPath)
            val streamingSection = yamlConfig["streaming"] as Map<String, Any>
            
            // ① 사용자 설정 추출
            val streamingConfig = StreamingPaymentConfig(...)
            
            // ② 내부 클라우드 설정으로 변환 (매핑 로직)
            val cloudConfig = CloudPaymentConfig(...)
            
            // ③ 프로그래밍 방식으로 클라우드 클라이언트 생성
            val cloudClient = CloudPaymentClientBuilder()
                .withConfig(cloudConfig)
                .build()
            
            return StreamingPaymentProcessor(streamingConfig, cloudClient)
        }
    }
    
    /**
     * 실시간 결제 처리 with 성능 모니터링
     * - 처리 시간이 설정된 임계값을 초과하면 경고 로그
     * - 낮은 대기 시간이 중요한 실시간 처리에 최적화
     */
    fun processPayment(request: PaymentRequest): PaymentResult {
        val startTime = System.currentTimeMillis()
        
        return try {
            val result = cloudPaymentClient.processPayment(request)
            val processingTime = System.currentTimeMillis() - startTime
            
            // 성능 모니터링: 처리 시간 검증
            if (processingTime > config.maxProcessingTimeMs) {
                println("⚠️ 결제 처리 시간 초과 경고!")
                println("주문 ID: ${request.orderId}")
                println("실제 처리 시간: ${processingTime}ms")
                println("허용 임계값: ${config.maxProcessingTimeMs}ms")
            }
            
            PaymentResult.success(request.orderId, processingTime)
            
        } catch (e: Exception) {
            val processingTime = System.currentTimeMillis() - startTime
            PaymentResult.failure(request.orderId, e.message ?: "Unknown error")
        }
    }
}
```

### Kotest 테스트 코드

```kotlin
import io.kotest.core.spec.style.BehaviorSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.types.shouldBeInstanceOf

class PaymentProcessorTest : BehaviorSpec({
    
    given("전자상거래 결제 처리 시스템") {
        val samplePaymentRequest = PaymentRequest(
            orderId = "ORDER-2024-001",
            amount = BigDecimal("99.99"),
            currency = "USD",
            customerId = "CUSTOMER-123"
        )
        
        `when`("As-Is: 배치 결제 처리기를 사용할 때") {
            val batchProcessor = BatchPaymentProcessor("test-config.yaml")
            
            then("배치로 결제 요청들을 처리해야 한다") {
                val requests = listOf(
                    samplePaymentRequest,
                    samplePaymentRequest.copy(orderId = "ORDER-2024-002"),
                    samplePaymentRequest.copy(orderId = "ORDER-2024-003")
                )
                
                // 실행 시간 측정하지 않음 (배치 처리는 시간보다 처리량이 중요)
                batchProcessor.processBatchPayments(requests)
                true shouldBe true
            }
        }
        
        `when`("To-Be: 스트리밍 결제 처리기를 사용할 때") {
            val streamingProcessor = StreamingPaymentProcessor.create("streaming-config.yaml")
            
            then("실시간으로 결제를 처리하고 성능을 모니터링해야 한다") {
                val result = streamingProcessor.processPayment(samplePaymentRequest)
                
                result.shouldBeInstanceOf<PaymentResult.Success>()
                
                when (result) {
                    is PaymentResult.Success -> {
                        result.orderId shouldBe "ORDER-2024-001"
                    }
                    is PaymentResult.Failure -> {
                        // 실패 케이스는 별도 테스트에서 다룸
                    }
                }
            }
        }
    }
})
```

## 요약

### 6.3 요약
의존성 라이브러리 설정 추상화는 사용자에게 단순한 UX를 제공하지만, 설정 매핑을 위한 추가적인 유지보수 비용이 발생합니다. 특히 많은 설정을 가진 다운스트림 서비스와 통합할 때는 이러한 비용이 상당히 높아질 수 있습니다.

### 6.4 요약
새로운 설정 추가 시 배치 도구는 직접 전달 방식으로 유지보수 비용이 거의 없지만 사용자에게 부담을 전가하고, 스트리밍 도구는 추상화를 통해 더 나은 UX를 제공하지만 지속적인 유지보수 비용이 발생합니다. 시스템 규모와 변경 빈도를 고려하여 적절한 접근 방식을 선택해야 합니다.

## 관련 자료

- **Google SRE Configuration Design**: 설정 관리의 모범 사례와 시맨틱 검증의 중요성을 다룹니다[2]
- **Configuration Management Best Practices**: 소프트웨어 개발에서의 체계적인 설정 관리 방법론을 제시합니다[3]
- **API Abstraction Strategy**: 대규모 엔터프라이즈 환경에서 API 추상화의 핵심 이점과 구현 방법을 설명합니다[4]

설정 추상화와 직접 전달 방식의 선택은 **시스템의 복잡도, 변경 빈도, 팀의 운영 역량**을 종합적으로 고려해야 하는 중요한 아키텍처 결정입니다.

[1]: https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/32004849/dd13acb0-3412-4992-997b-8c3faf712eda/2504-ipegtibeu-sopeuteuweeo-seolgye-pages-189-197.pdf
[2]: https://sre.google/workbook/configuration-design/
[3]: https://teamhub.com/blog/understanding-configuration-management-in-software-development/
[4]: https://www.digitalml.com/api-abstraction-is-key-to-an-api-first-strategy/
[5]: https://www.reddit.com/r/ChatGPTPro/comments/14ya6pn/how_to_get_chapter_wise_summary_of_the_novels/
[6]: https://www.atlassian.com/work-management/knowledge-sharing/documentation/software-design-document
[7]: https://arxiv.org/html/2407.13633v1
[8]: https://www.atlassian.com/microservices/microservices-architecture/configuration-management
[9]: https://www.geeksforgeeks.org/software-engineering/software-engineering-software-design-process/
[10]: https://engineering.atspotify.com/2023/05/multiple-layers-of-abstraction-in-design-systems
[11]: https://bestpractices.cd.foundation/learn/config/
[12]: https://bssw.io/items/understanding-software-configuration
[13]: https://www.linkedin.com/pulse/why-api-abstraction-api-first-match-made-heaven-digitalml
[14]: https://www.linkedin.com/pulse/configuration-management-silent-hero-modern-software-cglif
[15]: https://dev.to/somadevtoo/10-software-design-and-programming-best-practices-for-developers-ecn
[16]: https://www.nuget.org/packages/microsoft.extensions.configuration.abstractions/
[17]: https://apps.dtic.mil/sti/tr/pdf/ADA452470.pdf
[18]: https://wecode.wepay.com/posts/effective-software-design-documents
[19]: https://translate.google.com/translate?u=https%3A%2F%2Fwww.quora.com%2FWhat-is-API-Abstraction&hl=ko&sl=en&tl=ko&client=srp
[20]: https://www.ibm.com/docs/en/engineering-lifecycle-management-suite/lifecycle-management/7.0.3?topic=local-configuration-management
[21]: https://www.agileinstitute.com/articles/good-software-design-part-1
