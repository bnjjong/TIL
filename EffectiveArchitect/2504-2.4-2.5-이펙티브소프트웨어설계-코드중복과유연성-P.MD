# 이펙티브 소프트웨어 설계 2장 요약: 코드 중복 vs 유연성
## 2.4 코드 중복으로 느슨한 결합 향상시키기
### 주요 내용
이 섹션에서는 두 가지 요청 처리 유형(표준 추적 요청과 그래프 추적 요청)을 처리하는 독립적인 처리기 설계를 다룹니다. 초기 설계에서는 **TraceHandler**와 **GraphTraceHandler**가 완전히 독립적으로 구현되어 코드 중복이 존재하지만 **느슨한 결합**을 유지합니다.[1]

핵심 특징:
- 두 처리기 간 결합이 없음
- 유사한 로직이지만 데이터 타입이 다름 (String vs int)
- `createPayload()` 메서드만 차이가 있고 나머지는 동일한 복잡한 로직

### 개인 의견
독립적인 처리기 방식은 **단기적으로는 비효율적**으로 보이지만, **장기적 유지보수 관점**에서는 각 처리기가 독립적으로 진화할 수 있다는 큰 장점이 있습니다. 특히 요구사항이 불명확한 초기 단계에서는 이런 접근이 더 현명할 수 있습니다.

## 2.5 중복을 줄이기 위해 상속을 사용하는 API 설계
### 주요 내용
DRY 원칙을 적용하여 공통 부분을 `TraceRequest` 부모 클래스로 추출하고, `BaseTraceRequestHandler`를 통해 중복 코드를 제거합니다.[1]

구조 변화:
- **TraceRequest** 추상 클래스 생성 (공통 `isTraceEnabled` 속성)
- **BaseTraceRequestHandler** 제네릭 클래스로 공통 로직 구현
- 자식 클래스는 `createPayload()` 메서드만 구현

### 개인 의견
상속을 통한 중복 제거는 **코드 라인 수를 줄이고 일관성을 높이는** 명확한 이점이 있습니다. 하지만 **추상화의 복잡성**과 **미래 변화에 대한 제약**을 충분히 고려해야 합니다.

## 2.5.1 기초 요청 처리기 추출
### 주요 내용
`BaseTraceRequestHandler` 클래스를 통해 공통 `processRequest()` 로직을 구현하고, 구체적인 페이로드 생성은 추상 메서드 `createPayload()`로 자식 클래스에 위임합니다[1].

### 개인 의견
이 패턴은 **템플릿 메서드 패턴**의 전형적인 예시로, 알고리즘의 골격은 유지하면서 세부 구현만 변경할 수 있게 합니다. 하지만 과도한 추상화는 코드 이해를 어렵게 만들 수 있습니다.

## 2.5.2 상속과 강한 결합 살펴보기
### 주요 내용
새로운 비즈니스 요구사항(GraphTraceRequestHandler의 무한 버퍼 지원)이 도입되면서 상속의 한계가 드러납니다. 부모 클래스의 `processRequest()` 메서드를 한 자식을 위해 변경하면 다른 자식들에게 영향을 미치는 **강한 결합** 문제가 발생합니다.[1]

해결책의 문제점:
- `instanceof` 사용 → 부모 클래스가 구체 구현에 의존
- 캡슐화 원칙 위배
- 일반적인 추상화에서 특정 구현 로직 누출

### 개인 의견
이 사례는 **조기 최적화의 위험성**을 잘 보여줍니다. 초기에 DRY 원칙을 과도하게 적용하면 나중에 더 큰 비용을 치를 수 있습니다. "**중복은 잘못된 추상화보다 저렴하다**"는 원칙을 기억해야 합니다.[2]

## 2.5.3 상속과 합성 사이의 트레이드오프 살펴보기
### 주요 내용
상속의 한계를 극복하기 위해 **합성(Composition)** 방식을 제안합니다. 버퍼 관리와 데이터 변환을 별도 책임으로 분리하여 독립적인 컴포넌트로 구성하는 방식입니다.[1]

**상속 vs 합성 비교:**
- 상속: 코드 재사용 용이하지만 강한 결합 위험
- 합성: 책임 분리가 잘 되고 유연하지만 초기 복잡도 상승

**설계 진화 과정:**
- 중복 허용 단계 → 상속으로 추상화 → 합성으로 책임 분리

### 개인 의견
합성은 **"has-a" 관계**를 통해 더 유연한 설계를 가능하게 하지만, **추상화 계층이 증가**하여 초기 학습 비용이 높아집니다. 팀의 경험 수준과 도메인의 복잡성을 고려하여 선택해야 합니다.

## 2.5.4 내재된 중복과 우연한 중복 살펴보기
### 주요 내용
모든 중복이 제거 대상은 아닙니다. **내재된 중복(Essential Duplication)**과 **우연한 중복(Accidental Duplication)**을 구분해야 합니다.[1][3][4]

- **내재된 중복**: 동일한 비즈니스 목표를 해결하는 진짜 중복
- **우연한 중복**: 현재는 비슷하지만 다른 방향으로 진화할 가능성이 있는 중복

### 개인 의견
이는 소프트웨어 설계에서 가장 어려운 판단 중 하나입니다. **"Rule of Three"**를 적용하여 세 번째 유사한 코드가 나타날 때 추상화를 고려하는 것이 좋은 전략입니다.[4]

## Kotlin 예제 코드

### As-Is: 독립적인 두 처리기 (중복 코드 존재)
```kotlin
// E-Commerce 주문 처리 시스템 예제

data class OnlineOrder(
    private val processingEnabled: Boolean,
    private val orderData: String
) {
    fun isProcessingEnabled(): Boolean = processingEnabled
    fun getOrderData(): String = orderData
}

data class StoreOrder(
    private val processingEnabled: Boolean,
    private val orderData: Int
) {
    fun isProcessingEnabled(): Boolean = processingEnabled
    fun getOrderData(): Int = orderData
}

// 온라인 주문 처리기 - 중복 로직 존재
class OnlineOrderHandler(private val bufferSize: Int) {
    private var processed = false
    val buffer = mutableListOf<String>() // 데모를 위해 public

    fun processOrder(order: OnlineOrder) {
        if (!processed && !order.isProcessingEnabled()) return

        val payload = "${order.getOrderData()}-online-processed"
        if (buffer.size < bufferSize) buffer.add(payload)
        if (buffer.size >= bufferSize) processed = true
    }
}

// 매장 주문 처리기 - 중복 로직 존재
class StoreOrderHandler(private val bufferSize: Int) {
    private var processed = false
    val buffer = mutableListOf<String>()

    fun processOrder(order: StoreOrder) {
        if (!processed && !order.isProcessingEnabled()) return

        val payload = "${order.getOrderData()}-store-processed"
        if (buffer.size < bufferSize) buffer.add(payload)
        if (buffer.size >= bufferSize) processed = true
    }
}
```

### Alternative: 합성을 사용한 유연한 설계
```kotlin
// 페이로드 변환 전략 인터페이스
typealias PayloadTransformer<T> = (T) -> String

// 버퍼 관리 전략 인터페이스
interface Buffer {
    fun add(item: String): Boolean
    fun isFull(): Boolean
    fun size(): Int
}

class FixedSizeBuffer(private val maxSize: Int) : Buffer {
    private val items = mutableListOf<String>()
    override fun add(item: String): Boolean {
        return if (items.size < maxSize) { items.add(item); true } else { false }
    }
    override fun isFull(): Boolean = items.size >= maxSize
    override fun size(): Int = items.size
}

class UnlimitedBuffer : Buffer {
    private val items = mutableListOf<String>()
    override fun add(item: String): Boolean { items.add(item); return true }
    override fun isFull(): Boolean = false
    override fun size(): Int = items.size
}

class FlexibleOrderHandler<T>(
    private val transformer: PayloadTransformer<T>,
    private val buffer: Buffer
) {
    private var processed = false

    fun processOrder(order: T, isProcessingEnabled: Boolean) {
        if (!processed && !isProcessingEnabled) return
        val payload = transformer(order)
        val added = buffer.add(payload)
        if (!added || buffer.isFull()) processed = true
    }

    fun isProcessed(): Boolean = processed
    fun getBufferSize(): Int = buffer.size()
}

// 사용 예시
fun main() {
    val onlineHandler = FlexibleOrderHandler<OnlineOrder>(
        transformer = { o -> "${o.getOrderData()}-flexible-online" },
        buffer = FixedSizeBuffer(4)
    )

    val storeHandler = FlexibleOrderHandler<StoreOrder>(
        transformer = { s -> "${s.getOrderData()}-flexible-store" },
        buffer = UnlimitedBuffer()
    )
}
```


## 관련 참고 자료

### 코드 중복과 DRY 원칙의 한계
- [The Dark Side of Don't Repeat Yourself](https://dev.to/sharma-tech/the-dark-side-of-dont-repeat-yourself-o4k) - DRY 원칙의 과도한 적용이 가져오는 문제점들을 설명[5]
- [Think Twice Before Deduplicating Code](https://jonkuhn.com/2021/02/21/Think-Twice-Before-Deduplicating-Code.html) - 내재된 중복과 우연한 중복의 차이점 설명[3]
- [The DRY Principle: Benefits and Costs with Examples](https://thevaluable.dev/dry-principle-cost-benefit-example/) - DRY 원칙의 비용-편익 분석[2]

### 상속 vs 합성
- [Composition vs Inheritance: Which One to Choose?](https://utho.com/blog/composition-vs-inheritance/) - 상속과 합성의 성능 및 유지보수 측면 비교[6]
- [Composition Over Inheritance: A Flexible Design Principle](https://dev.to/lovestaco/composition-over-inheritance-a-flexible-design-principle-4ehh) - 합성 우선 원칙의 장점과 실제 적용 사례[7]

### 마이크로서비스에서의 코드 공유
- [Shared library for Micro-Services: Why should you have one?](https://dev.to/thesimdak/shared-library-for-micro-services-why-should-you-have-one-2jod) - 마이크로서비스에서 공유 라이브러리 사용의 장단점[8]
- [When Do Shared Libraries Complicate Microservices?](https://substack.com/home/post/p-149641178) - 공유 라이브러리가 마이크로서비스의 독립성을 해치는 상황들[9]

## 요약
**2.4 코드 중복으로 느슨한 결합 향상시키기**에서는 독립적인 처리기 설계를 통해 중복 코드가 존재하더라도 느슨한 결합의 이점을 얻을 수 있음을 보여줍니다.

**2.5 중복을 줄이기 위해 상속을 사용하는 API 설계**에서는 DRY 원칙을 적용한 상속 기반 설계를 소개하지만, 새로운 요구사항 도입 시 강한 결합 문제가 발생함을 드러냅니다.

**핵심 트레이드오프**:
- **중복 허용** → 느슨한 결합, 독립적 진화 vs 유지보수 부담
- **상속 사용** → 코드 재사용, DRY 준수 vs 유연성 제한, 강한 결합
- **합성 적용** → 높은 유연성, 런타임 변경 vs 복잡성 증가

**핵심 교훈**:
1. **모든 중복이 나쁜 것은 아니다** - 내재된 중복과 우연한 중복을 구분하라
2. **추상화는 비용이 든다** - 잘못된 추상화는 중복보다 더 큰 문제를 일으킨다
3. **컨텍스트가 중요하다** - 팀의 상황, 도메인의 안정성, 미래 변화 가능성을 고려하라

이 장은 소프트웨어 설계에서 **완벽한 솔루션은 없으며**, 각 접근법의 트레이드오프를 이해하고 상황에 맞는 최적의 선택을 하는 것이 중요함을 강조합니다.

***


[1] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/32004849/b0e2206e-207c-4d57-98f7-a169c4f8b86b/2504-ipegtibeu-sopeuteuweeo-seolgye-pages-61-74.pdf
[2] https://thevaluable.dev/dry-principle-cost-benefit-example/
[3] https://jonkuhn.com/2021/02/21/Think-Twice-Before-Deduplicating-Code.html
[4] https://www.justinweiss.com/articles/i-dry-ed-up-my-code-and-now-its-hard-to-work-with-what-happened/
[5] https://dev.to/sharma-tech/the-dark-side-of-dont-repeat-yourself-o4k
[6] https://utho.com/blog/composition-vs-inheritance/
[7] https://dev.to/lovestaco/composition-over-inheritance-a-flexible-design-principle-4ehh
[8] https://dev.to/thesimdak/shared-library-for-micro-services-why-should-you-have-one-2jod
[9] https://substack.com/home/post/p-149641178
[10] https://www.oreilly.com/library/view/software-mistakes-and/9781617299209/Text/ch02_Lelek.htm
[11] https://tjhunt.blogspot.com/2009/02/avoiding-duplication-and-increasing.html
[12] https://www.linkedin.com/pulse/inheritance-vs-composition-explained-jes%C3%BAs-v%C3%A1zquez-navarro-q4yaf
[13] https://codeconservatory.com/blog/post/dry/
[14] https://oncodedesign.com/blog/dry-vs-coupling/
[15] https://livebook.manning.com/book/software-mistakes-and-tradeoffs/chapter-2
[16] https://arxiv.org/html/2502.04073v1
[17] https://axify.io/blog/code-duplication
[18] https://www.reddit.com/r/softwarearchitecture/comments/16k76tj/microservice_architecture_shared_lib_vs_dedicated/
[19] https://anthonysciamanna.com/2018/07/28/the-dry-principle-and-incidental-duplication.html
[20] https://www.grahamlea.com/2016/04/shared-libraries-in-microservices-bad-advice/
[21] https://www.tjdraper.com/blog/incidental-duplication
[22] https://blog.bitsrc.io/differences-in-code-sharing-between-microservices-microfrontends-7803e7171952
[23] https://www.infoq.com/news/2014/09/microservices-shared-libraries/
[24] https://ppl-ai-code-interpreter-files.s3.amazonaws.com/web/direct-files/aadbe184ee40e3e6f258364b2b4c5f48/3d9eaf13-a806-492e-a5a4-63ad485dce6c/82ab706e.md