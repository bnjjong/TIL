# 6장: API를 유지보수하기 위한 비용 대 단순함 정리

## 6.1 다른 도구에서 사용되는 기본 라이브러리

### 6.1.1 클라우드 서비스 클라이언트 만들기

**핵심 개념**[1]
- 클라우드 서비스에 데이터를 로드하는 요청을 대리 수행하는 컴포넌트
- 두 가지 인증 방식 지원: 토큰 기반, 사용자명/패스워드 기반
- Request 클래스: 데이터와 인증 정보를 담는 진입점
- CloudServiceClient 인터페이스: loadData() 메서드만 공개

**개인 생각**: 단일 책임 원칙과 인터페이스 분리 원칙을 잘 적용한 설계다. 특히 @Nullable 어노테이션을 통해 null 안전성을 명시적으로 표현한 점이 좋다. 실제 광고 플랫폼에서도 이런 구조로 외부 결제 시스템과 통합할 때 활용할 수 있겠다.

### 6.1.2 인증 전략 탐색

**핵심 개념**[1]
- AuthStrategy 인터페이스를 통한 **전략 패턴** 구현
- UsernamePasswordAuthStrategy: 사용자명/패스워드 검증
- TokenAuthStrategy: 토큰 기반 인증
- 각 전략은 authenticate() 메서드를 구현하여 인증 수행

| 항목 | TokenAuthStrategy | UsernamePasswordAuthStrategy |
| --- | --- | --- |
| 인증 방식 | 토큰 기반 | 사용자명/패스워드 기반 |
| 필수 필드 | token | username, password |
| 검증 로직 | 토큰 일치 여부 | 사용자명과 패스워드 일치 여부 |
| 보안 고려사항 | 토큰 관리 필요 | 패스워드 평문 저장 위험 |
| 사용 사례 | API 키, JWT 토큰 | 기본 인증 |

**개인 생각**: 전략 패턴의 모범 사례를 보여준다. 하지만 책에서 언급한 대로 String으로 패스워드를 저장하는 것은 보안상 문제가 있다. 실제 프로젝트에서는 SecureString이나 char[]을 사용하고, 사용 후 즉시 메모리를 클리어해야 한다.

### 6.1.3 구성 메커니즘 이해하기

**핵심 개념**[1]
- YAML 파일을 통한 클라우드 서비스 구성 제공
- CloudServiceConfiguration: 인증 전략을 담는 구성 클래스
- DefaultCloudServiceClient: 구성 객체를 주입받는 구현체
- CloudServiceClientBuilder: YAML 파일을 읽어 클라이언트 생성
- **맵의 맵 구조**로 YAML 파일 해석 (외부 맵: 설정 영역, 내부 맵: 속성들)

| 구성 영역 | 키 | 값 | 설명 |
| --- | --- | --- | --- |
| auth | strategy | username-password | 사용자명/패스워드 인증 전략 |
| auth | username | user | 인증용 사용자명 |
| auth | password | pass | 인증용 패스워드 |
| auth | strategy | token | 토큰 기반 인증 전략 |
| auth | token | c8933754-30a0-11eb... | 인증용 토큰 값 |
| batch | size | 100 | 배치 크기 설정 |
| other setting | key | value | 기타 설정들 |

**개인 생각**: 유연한 구성 시스템을 제공한다는 점에서 좋다. Spring Boot의 @ConfigurationProperties와 유사한 접근법이다. 다만 YAML 파싱 과정에서의 타입 안전성을 더 강화할 필요가 있어 보인다.

## 6.2 의존성 라이브러리의 설정을 외부에 직접 공개하기

### 6.2.1 배치 도구 구성하기

**핵심 개념**[1]
- BatchService: 버퍼 크기가 배치 크기를 초과할 때까지 요청을 **배치 처리**
- BatchServiceConfiguration: batchSize 설정만 포함하는 단순한 구성
- YAML 구성 파일에서 auth 절을 클라우드 클라이언트에 **직접 전달**
- BatchServiceBuilder: batch 절 해석 + 전체 YAML 파일을 클라우드 클라이언트로 전달

| 항목 | 직접 공개 방식 | 추상화 방식 |
| --- | --- | --- |
| 구현 복잡도 | 낮음 | 높음 |
| 유지보수 비용 | 낮음 | 높음 |
| 클라이언트 결합도 | 강함 | 약함 |
| UX 친화성 | 낮음 | 높음 |
| 라이브러리 변경 용이성 | 어려움 | 쉬움 |
| 설정 개수가 많을 때 | 효과적 | 부담 |
| API 안정성 | 변경 어려움 | 변경 용이 |

**개인 생각**: 이 접근법은 단기적으로는 개발 속도를 높일 수 있지만, 장기적으로는 기술 부채가 될 수 있다. 특히 마이크로서비스 환경에서는 서비스 간 결합도를 낮추는 것이 중요한데, 이 방식은 반대 방향으로 작용한다. 하지만 AWS SDK처럼 설정이 매우 많은 경우에는 현실적인 선택일 수 있다.

## Kotlin 예제 코드 (E-commerce 광고 플랫폼)

### As-Is: 직접 의존성 생성 방식

```kotlin
// As-Is: 강결합된 광고 서비스
class AdvertisementService {
    // 의존성을 직접 생성 - 테스트 어려움, 변경 어려움
    private val paymentClient = PaymentClient("api-key-12345")
    private val analyticsClient = AnalyticsClient("analytics-token")
    
    fun processAdCampaign(campaign: AdCampaign): CampaignResult {
        val paymentResult = paymentClient.processPayment(campaign.budget)
        analyticsClient.trackCampaign(campaign.id, campaign.targetAudience)
        return CampaignResult(campaign.id, paymentResult.status)
    }
}
```

### To-Be: 의존성 주입과 구성 추상화

```kotlin
// 인터페이스를 통한 추상화
interface PaymentService {
    fun processPayment(amount: BigDecimal): PaymentResult
}

// 전략 패턴을 통한 인증 방식 추상화
interface AuthStrategy {
    fun authenticate(request: ApiRequest): Boolean
}

class TokenAuthStrategy(private val token: String) : AuthStrategy {
    override fun authenticate(request: ApiRequest): Boolean {
        return request.token == token
    }
}

// 의존성 주입을 통한 광고 서비스
class ModernAdvertisementService(
    private val paymentService: PaymentService,
    private val analyticsService: AnalyticsService
) {
    fun processAdCampaign(campaign: AdCampaign): CampaignResult {
        val paymentResult = paymentService.processPayment(campaign.budget)
        analyticsService.trackCampaign(campaign.id, campaign.targetAudience)
        return CampaignResult(campaign.id, paymentResult.status)
    }
}
```

### KoTest 테스트 코드

```kotlin
class ModernAdvertisementServiceTest : FunSpec({
    test("광고 캠페인 처리 성공 시나리오") {
        // Given: 목 객체 생성
        val mockPaymentService = mockk<PaymentService>()
        val mockAnalyticsService = mockk<AnalyticsService>()
        
        every { mockPaymentService.processPayment(any()) } returns PaymentResult("SUCCESS")
        every { mockAnalyticsService.trackCampaign(any(), any()) } returns Unit
        
        // When: 서비스 실행
        val service = ModernAdvertisementService(mockPaymentService, mockAnalyticsService)
        val result = service.processAdCampaign(campaign)
        
        // Then: 결과 검증
        result.paymentStatus shouldBe "SUCCESS"
        verify(exactly = 1) { mockPaymentService.processPayment(any()) }
    }
})
```

## 관련 자료

- **RESTful API 설계 원칙**: 일관성, 직관성, 적절한 HTTP 메서드 사용이 중요[2]
- **의존성 주입 모범 사례**: 생성자 주입이 권장되며, 테스트 용이성과 불변성 확보가 가능[3]
- **Configuration-as-Code**: 단일 소스, 모듈화, 검증 자동화가 핵심[4]

## 요약

**6.1 다른 도구에서 사용되는 기본 라이브러리**
- 클라우드 서비스 클라이언트는 전략 패턴을 활용한 인증 시스템과 YAML 기반 구성 메커니즘을 제공한다
- 인터페이스 분리와 의존성 주입을 통해 유연하고 테스트 가능한 설계를 구현한다
- Jackson ObjectMapper와 타입 안전한 맵 구조로 구성 파일을 처리한다

**6.2 의존성 라이브러리의 설정을 외부에 직접 공개하기**
- 배치 서비스는 클라우드 클라이언트 설정을 직접 노출하는 방식을 채택한다
- **트레이드오프**: 구현 단순성과 유지보수 용이성 vs 강결합과 변경의 어려움
- 설정이 많은 라이브러리에는 효과적이지만, API 계약이 되어 장기적으로는 제약사항이 발생한다

**핵심 교훈**: API 설계에서는 단순성과 유지보수성 사이의 균형을 고려해야 하며, 의존성 주입과 인터페이스 추상화를 통해 결합도를 낮추면서도 현실적인 구현 복잡도를 유지하는 것이 중요하다

[1](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/32004849/5a55c063-925a-4356-a5d9-0e493da5e707/2504-ipegtibeu-sopeuteuweeo-seolgye-pages-175-189.pdf)
[2](https://www.itdiary.co.kr/trends/6)
[3](https://dev.to/tharindufdo/understanding-dependency-injection-in-spring-boot-2ll0)
[4](https://configu.com/blog/what-is-configuration-as-code-cac-and-5-tips-for-success/)
[5](https://velog.io/@gun_123/RESTful-API-%EC%84%A4%EA%B3%84-%EC%9B%90%EC%B9%99%EA%B3%BC-%EC%98%88%EC%8B%9C)
[6](https://kim-oriental.tistory.com/32)
[7](https://kinsta.com/blog/abstract-wordpress-plugin/)
[8](https://blog.injunweb.com/post/42/)
[9](https://docs.spring.io/spring-framework/reference/core/beans/dependencies/factory-collaborators.html)
[10](https://www.cloudeagle.ai/blogs/configuration-management-best-practices)
[11](https://ian-info.tistory.com/14)
[12](https://chilling.tistory.com/47)
[13](https://sre.google/workbook/configuration-design/)
[14](https://subinto.tistory.com/302)
[15](https://velog.io/@nowod_it/Java-Spring-Dependncy-Injection-DI-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85)
[16](https://bestpractices.cd.foundation/learn/config/)
[17](https://kmkunk.tistory.com/139)
[18](https://www.baeldung.com/spring-dependency-injection)
[19](https://www.reddit.com/r/ExperiencedDevs/comments/17xwfc8/managing_overabstraction_and_overengineering/)
[20](https://velog.io/@city7310/%EB%B0%B1%EC%97%94%EB%93%9C%EA%B0%80-%EC%9D%B4%EC%A0%95%EB%8F%84%EB%8A%94-%ED%95%B4%EC%A4%98%EC%95%BC-%ED%95%A8-4.-API-%EC%84%A4%EA%B3%84-%EC%9B%90%EC%B9%99%EA%B3%BC-%EC%A7%81%EB%A0%AC%ED%99%94-%ED%8F%AC%EB%A7%B7-%EA%B2%B0%EC%A0%95)
[21](https://www.geeksforgeeks.org/advance-java/spring-dependency-injection-with-example/)