# 7장, 7.1 챕터 정리: 날짜와 시간 데이터로 효율적으로 작업하기

## 7장 개요

날짜와 시간은 거의 모든 애플리케이션에서 자연스럽게 등장하지만, 지나치게 복잡한 코드나 지구 반대편 사용자만 경험할 수 있는 버그를 야기할 수 있다. 올바른 도구를 사용하면 이런 버그를 회피할 수 있다.[1]

두 가지 종류의 도구가 필요하다:
- **개념**: 작업하고 있는 정보에 대해 명확하게 생각하고 작성하게 도와준다
- **라이브러리**: 개념을 코드로 바꾸는 작업을 도와준다

### 실습 시나리오
온라인 쇼핑 시나리오를 사용하여 모든 내용을 구체적으로 설명한다.

**초기 요구사항**: "고객은 3개월 내에 반품할 수 있다"[1]

## 7.1 날짜와 시간 정보에 대한 개념

### 7.1.1 컴퓨터 시간: 인스턴트, 에포크, 시간 간격

#### 인스턴트(Instant)
- `java.time.Instant`, `NodaTime.Instant`
- 전 세계적인 타임스탬프[1]
- 전 세계 어떤 장소에 있는 두 사람도 인스턴트가 현재 시간이 무엇을 의미하는지 동의할 수 있다
- 인간의 문화적 개념과 무관한 컴퓨터 시간
- 세분화되지 않는 타임라인을 이루는 점으로 생각할 수 있다[1]

#### 에포크(Epochs)
- 모든 인스턴트를 표현하기 위한 영점[1]
- **유닉스 에포크**: UTC 기준 1970년 1월 1일 자정[1]
- **.NET 에포크**: 서기 1년 1월 1일 자정
- **엑셀/COM 에포크**: 1900년 (윤년 버그 포함)[1]
- 대부분의 시스템이 유닉스 에포크를 사용

#### 시간 간격(Durations)
- `java.time.Duration`, `NodaTime.Duration`
- 특정 시점이 아니라 경과된 시간을 측정한 값[1]
- 타임라인에서 두 점 사이의 차이
- 항상 측정한 경과 시각 관점에서 절대적으로 고정[1]
- 가능한 산술 연산:
    - 인스턴트 - 인스턴트 = 시간 간격
    - 시간 간격 + 시간 간격 = 시간 간격
    - 인스턴트 + 시간 간격 = 인스턴트
    - 인스턴트 - 시간 간격 = 인스턴트[1]

**개인 의견**: 컴퓨터 시간 개념은 상대적으로 단순하고 명확하다. 문화적 요소를 배제한 순수한 시간 개념으로, 시스템 간 일관성을 보장할 수 있어 백엔드 개발에서 기본이 되는 개념이다.

### 7.1.2 상용 시간: 달력 시스템, 날짜, 시간, 날짜 간격

#### 달력 시스템
- `java.time.chrono.Chronology`, `java.time.LocalDate`, `NodaTime.CalendarSystem`, `NodaTime.LocalDate`
- 시간을 일, 월, 년으로 분해하는 방식[1]
- **그레고리력**: 현재 서구권에서 사용하는 달력
- **율리우스력**: 그레고리력과 거의 동일하나 윤년 규칙이 다름[1]
- **히브리력**, **이슬람력**: 완전히 다른 월과 년 체계
- **바하이력**: 19일로 구성된 19개월 + 4-5일의 특별한 기간[1]

#### 달력 시스템별 동일한 날짜 표현

| 그레고리력 | 율리우스력 | 히브리력 | 이슬람력 |
|---------|---------|--------|--------|
| 2020년 11월 16일 | 2020년 11월 3일 | 5781년 해쉬반 29일 | 1442년 라비 알 아왈 30일 |
| 2020년 11월 17일 | 2020년 11월 4일 | 5781년 키슬레브 1일 | 1442년 라비 아트 타니 1일 |
| 2020년 11월 18일 | 2020년 11월 5일 | 5781년 키슬레브 2일 | 1442년 라비 아트 타니 2일 |
| 2020년 11월 19일 | 2020년 11월 6일 | 5781년 키슬레브 3일 | 1442년 라비 아트 타니 3일 |
| 2020년 11월 20일 | 2020년 11월 7일 | 5781년 키슬레브 4일 | 1442년 라비 아트 타니 4일 |

#### 하루 중 시간
- `java.time.LocalTime`, `NodaTime.LocalTime`
- 60분과 60초로 구성된 24시간[1]
- 00:00 (포함) vs 24:00 (제외) 논란
- 밀리초, 마이크로초, 나노초까지 세분화 가능

#### 날짜 간격(Periods)
- `java.time.Period`, `NodaTime.Period`
- 상용 시간에서 산술 계산을 위한 개념[1]
- **문제점**: 명확한 정답이 없는 경우가 존재
    - 예: 2021년 5월 31일 + 1개월 = ?
    - 답: 2021년 6월 30일 또는 2021년 7월 1일[1]
- **특이한 특성**:
    1. **결합 법칙이 성립하지 않음**[1]
        - (2021년 1월 31일 + 1개월) + 2개월 ≠ 2021년 1월 31일 + (1개월 + 2개월)
    2. **가역성이 없음**[1]
        - (날짜 + 날짜간격) - 날짜간격 ≠ 원래 날짜

**개인 의견**: 상용 시간의 복잡성이 여실히 드러나는 부분이다. 특히 날짜 간격의 모호성은 비즈니스 로직 구현 시 명확한 규칙 정의가 필수임을 보여준다. 개발자는 이런 특성을 이해하고 사용자와 명확한 합의를 해야 한다.

### 7.1.3 시간대, UTC, 그리고 UTC 오프셋

#### 시간대
- `java.time.ZoneId`, `java.time.ZoneOffset`, `NodaTime.DateTimeZone`, `NodaTime.Offset`
- 기본적으로 다음 세 정보를 포함:[1]
    1. 식별자 또는 이름
    2. 해당 시간대에 있다고 간주되는 지구 표면의 영역
    3. 인스턴트를 상용 시간의 날짜와 시간으로 매핑하는 함수

#### UTC (협정 세계시)
- 다른 시간대를 기술하기 위해 사용되는 기준선[1]
- 시간대 정보 없이 인스턴트를 상용 시간으로 매핑하는 단순한 방법
- 에포크 기준으로 시간 간격만 더하면 UTC 날짜/시간 계산 가능[1]

#### UTC 오프셋
- 해당 시간대가 특정 인스턴트에서 UTC보다 얼마나 앞서거나 뒤쳐져 있는지[1]
- **예시**:
    - 샌프란시스코 (2020년 11월): UTC-8
    - 샌프란시스코 (2020년 6월): UTC-7 (서머타임)[1]
    - 인도: UTC+5:30 (1945년 이후 고정)[1]

#### 서머타임 문제
- **건너뛰는 시간**: 2020년 3월 8일 샌프란시스코에서 02:45는 존재하지 않음[1]
- **중복되는 시간**: 2020년 11월 1일 샌프란시스코에서 01:45가 두 번 발생[1]

#### 시간대가 아닌 것들
- **PST, PDT 등의 약어**: 시간대 이름이 아님 (매우 모호함)[1]
- **UTC 오프셋**: 시간대가 아님 (특정 인스턴트의 오프셋 정보만 제공)[1]
- **설명적 이름**: 실제 시간대 식별자가 아님

#### IANA 시간대 데이터베이스
- 가장 널리 사용되는 시간대 정보 출처[1]
- 대륙/도시 형식의 식별자 (예: Asia/Seoul, America/Los_Angeles)[1]
- 정치적 변경에 따른 지속적 업데이트 (2020a, 2020b 등)[1]

**개인 의견**: 시간대는 개발자가 가장 자주 실수하는 영역이다. `UTC 기준으로 저장하고 표시할 때만 변환`하는 것이 가장 안전한 패턴이다. IANA 데이터베이스를 신뢰하고 직접 구현하려 하지 않는 것이 현명하다.[2]

### 7.1.4 머리가 아파지는 날짜와 시간 개념들

#### 상대성
- GPS 등 일부 인프라는 상대성을 고려해야 함[1]
- 다행히 비즈니스 코드는 상대성을 고려할 필요 없음[1]
- '지금'이라는 개념이 상대성 이론에서는 단순하지 않을 수 있음

#### 윤초
- UTC와 관측된 태양 시각을 일치시키기 위해 삽입/제거[1]
- 1분이 61초 또는 59초가 될 수 있음[1]
- 예측 불가능 (6개월 전 발표)[1]
- 대부분 소프트웨어는 윤초를 인식하지 못함[1]

#### 달력 시스템 전환
- 로마: 1582년 10월 4일 → 10월 15일 (그레고리력 도입)[1]
- 런던: 1752년 9월 2일 → 9월 14일[1]
- 스웨덴의 특이사례: 1712년 2월 30일 존재[1]

**개인 의견**: 이런 복잡한 개념들은 대부분의 비즈니스 애플리케이션에서 고려할 필요가 없다. 하지만 이런 복잡성이 존재한다는 것을 인지하고, 표준 라이브러리를 신뢰하며, 가장 간단하고 널리 검증된 접근법을 사용하는 것이 중요하다.

## 요약

### 핵심 개념 정리

1. **컴퓨터 시간**: 문화와 무관한 절대적 시간
    - 인스턴트: 전 세계가 합의할 수 있는 특정 순간
    - 에포크: 시간 측정의 기준점 (주로 유닉스 에포크)
    - 시간 간격: 경과된 시간의 절대적 양

2. **상용 시간**: 인간이 사용하는 문화적 시간
    - 달력 시스템: 다양한 문화권별 시간 표현 방식
    - 날짜 간격: 모호성과 특이한 산술 연산 특성

3. **시간대**: 컴퓨터 시간과 상용 시간의 연결고리
    - UTC를 기준으로 한 오프셋 체계
    - 정치적 변경에 따른 동적 특성
    - 서머타임으로 인한 복잡성

4. **복잡한 개념들**: 대부분 무시 가능하지만 존재를 인지해야 함
    - 상대성, 윤초, 달력 전환 등

### 실무 적용 지침

1. **저장**: UTC 기준 인스턴트로 저장[3][2]
2. **계산**: 컴퓨터 시간(Duration) 우선 사용
3. **표시**: 사용자 시간대로 변환하여 표시[2]
4. **검증된 라이브러리**: java.time, kotlinx-datetime 등 사용[4][5]
5. **명확한 요구사항**: 날짜 간격의 모호한 경우 명확히 정의

## Kotlin 예제 코드

### As-Is: 문제가 있는 접근법

```kotlin
// ❌ 문제가 있는 날짜/시간 처리
class BadOrderService {
    fun processReturn(orderId: String): Boolean {
        // 로컬 시간으로 비교 - 시간대 문제 발생 가능
        val orderDate = getOrderDate(orderId) // LocalDateTime 반환
        val now = LocalDateTime.now()
        
        // 3개월이라는 애매한 기준 - 정확히 어떻게 계산할 것인가?
        val threeMonthsAgo = now.minusMonths(3)
        
        return orderDate.isAfter(threeMonthsAgo)
    }
    
    private fun getOrderDate(orderId: String): LocalDateTime {
        // DB에서 로컬 타임으로 저장된 데이터 조회
        return LocalDateTime.of(2024, 8, 15, 14, 30)
    }
}
```

### To-Be: 개선된 접근법

```kotlin
// ✅ 개선된 날짜/시간 처리
class GoodOrderService {
    /**
     * 주문 반품 가능 여부를 확인한다.
     * 비즈니스 규칙: 주문일로부터 정확히 90일(3개월) 이내 반품 가능
     * 
     * @param orderId 주문 ID
     * @param customerTimeZone 고객의 시간대 (표시용)
     * @return 반품 가능 여부
     */
    fun processReturn(orderId: String, customerTimeZone: ZoneId = ZoneId.systemDefault()): ReturnResult {
        // 1. UTC 기준으로 저장된 주문 시각 조회
        val orderInstant = getOrderInstant(orderId)
        val currentInstant = Instant.now()
        
        // 2. 명확한 기준: 정확히 90일 (Duration 사용)
        val returnPeriod = Duration.ofDays(90)
        val returnDeadline = orderInstant.plus(returnPeriod)
        
        val isReturnable = currentInstant.isBefore(returnDeadline)
        
        // 3. 사용자 친화적 표시를 위한 시간대 변환
        val orderLocalDateTime = orderInstant.atZone(customerTimeZone).toLocalDateTime()
        val deadlineLocalDateTime = returnDeadline.atZone(customerTimeZone).toLocalDateTime()
        
        return ReturnResult(
            isReturnable = isReturnable,
            orderDateTime = orderLocalDateTime,
            returnDeadline = deadlineLocalDateTime,
            remainingDays = if (isReturnable) {
                Duration.between(currentInstant, returnDeadline).toDays()
            } else 0
        )
    }
    
    /**
     * UTC 기준으로 저장된 주문 시각을 조회한다.
     */
    private fun getOrderInstant(orderId: String): Instant {
        // DB에서 UTC 기준으로 저장된 타임스탬프 조회
        // 예: 2024-08-15T05:30:00Z (UTC 기준)
        return Instant.parse("2024-08-15T05:30:00Z")
    }
}

/**
 * 반품 처리 결과를 담는 데이터 클래스
 */
data class ReturnResult(
    val isReturnable: Boolean,           // 반품 가능 여부
    val orderDateTime: LocalDateTime,    // 주문 일시 (고객 시간대)
    val returnDeadline: LocalDateTime,   // 반품 마감일시 (고객 시간대)  
    val remainingDays: Long             // 남은 일수
)

/**
 * 전역 시간 설정 클래스 - Spring Boot 환경
 */
@Configuration
class TimeConfiguration {
    
    @PostConstruct
    fun configureTimeZone() {
        // 애플리케이션 전체를 UTC 기준으로 설정
        TimeZone.setDefault(TimeZone.getTimeZone("UTC"))
        System.setProperty("user.timezone", "UTC")
    }
}

/**
 * 시간 유틸리티 클래스
 */
object TimeUtils {
    /**
     * 현재 시각을 UTC 기준으로 반환한다.
     */
    fun nowUtc(): Instant = Instant.now()
    
    /**
     * 특정 시간대의 현재 날짜/시간을 반환한다.
     */
    fun nowInTimeZone(zoneId: ZoneId): ZonedDateTime {
        return nowUtc().atZone(zoneId)
    }
    
    /**
     * UTC Instant를 특정 시간대의 LocalDateTime으로 변환한다.
     */
    fun toLocalDateTime(instant: Instant, zoneId: ZoneId): LocalDateTime {
        return instant.atZone(zoneId).toLocalDateTime()
    }
    
    /**
     * LocalDateTime을 특정 시간대 기준으로 UTC Instant로 변환한다.
     */
    fun toInstant(localDateTime: LocalDateTime, zoneId: ZoneId): Instant {
        return localDateTime.atZone(zoneId).toInstant()
    }
    
    /**
     * 안전한 날짜 간격 계산 - 명확한 비즈니스 규칙 필요
     */
    fun addBusinessDays(startDate: LocalDate, businessDays: Int): LocalDate {
        var result = startDate
        var daysToAdd = businessDays
        
        while (daysToAdd > 0) {
            result = result.plusDays(1)
            // 주말 제외 (토요일=6, 일요일=7)
            if (result.dayOfWeek.value < 6) {
                daysToAdd--
            }
        }
        return result
    }
}
```

### 테스트 코드 (Kotest)

```kotlin
import io.kotest.core.spec.style.BehaviorSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
import java.time.*

class GoodOrderServiceTest : BehaviorSpec({
    val orderService = GoodOrderService()
    val fixedClock = Clock.fixed(
        Instant.parse("2024-11-15T10:00:00Z"),
        ZoneOffset.UTC
    )
    
    given("주문 반품 처리 서비스") {
        `when`("주문 후 30일이 지난 경우") {
            // 30일 전 주문
            val orderInstant = Instant.parse("2024-10-15T05:30:00Z")
            val result = orderService.processReturn("ORDER-123", ZoneId.of("Asia/Seoul"))
            
            then("반품이 가능해야 한다") {
                result.isReturnable shouldBe true
                result.remainingDays shouldBe 60L // 90일 - 30일
            }
        }
        
        `when`("주문 후 91일이 지난 경우") {
            // 91일 전 주문 (반품 기간 초과)  
            val orderInstant = Instant.parse("2024-08-15T05:30:00Z")
            val result = orderService.processReturn("ORDER-456", ZoneId.of("Asia/Seoul"))
            
            then("반품이 불가능해야 한다") {
                result.isReturnable shouldBe false
                result.remainingDays shouldBe 0L
            }
        }
        
        `when`("서로 다른 시간대에서 확인하는 경우") {
            val koreanTimeZone = ZoneId.of("Asia/Seoul")  
            val usTimeZone = ZoneId.of("America/New_York")
            
            val koreanResult = orderService.processReturn("ORDER-789", koreanTimeZone)
            val usResult = orderService.processReturn("ORDER-789", usTimeZone)
            
            then("반품 가능 여부는 동일해야 하지만 표시 시간은 달라야 한다") {
                koreanResult.isReturnable shouldBe usResult.isReturnable
                koreanResult.orderDateTime shouldNotBe usResult.orderDateTime // 표시 시간은 다름
                koreanResult.remainingDays shouldBe usResult.remainingDays // 남은 일수는 동일
            }
        }
    }
    
    given("TimeUtils 유틸리티") {
        `when`("현재 시각을 UTC로 조회할 때") {
            val utcNow = TimeUtils.nowUtc()
            val seoulNow = TimeUtils.nowInTimeZone(ZoneId.of("Asia/Seoul"))
            
            then("시각은 다르지만 같은 순간이어야 한다") {
                val utcInstant = utcNow
                val seoulInstant = seoulNow.toInstant()
                
                // 같은 Instant여야 함 (오차 1초 허용)
                Duration.between(utcInstant, seoulInstant).abs().seconds shouldBe 0L
            }
        }
        
        `when`("영업일 계산을 할 때") {
            val friday = LocalDate.of(2024, 11, 15) // 금요일
            val result = TimeUtils.addBusinessDays(friday, 3)
            
            then("주말을 제외하고 계산되어야 한다") {
                result shouldBe LocalDate.of(2024, 11, 20) // 다음 주 수요일
            }
        }
    }
})
```

## 관련 자료 및 링크

이 자료들은 날짜와 시간 처리의 복잡성을 이해하고, 실무에서 안전하고 효율적인 코드를 작성하는 데 도움이 된다:

- **IANA 시간대 데이터베이스**: 가장 권위 있는 시간대 정보 출처
- **웹 개발 시간대 완벽 정복**: UTC 기준 설계와 베스트 프랙티스 가이드[2]
- **KotlinX DateTime**: Kotlin 멀티플랫폼 날짜/시간 라이브러리[5][4]
- **Spring Boot 시간대 처리 방법**: 실제 운영 환경에서의 설정 방법[6]
- **Kotlin 날짜 처리 가이드**: 실무적인 Kotlin 날짜/시간 처리 예제[7][8]


[1](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/32004849/d380835c-2fcb-41c2-9c43-c4264c1d39ad/2504-ipegtibeu-sopeuteuweeo-seolgye-pages-205-226.pdf)
[2](https://postforty.tistory.com/535)
[3](https://www.allofsoftware.net/2015/06/18.html)
[4](https://www.baeldung.com/kotlin/kotlinx-datetime)
[5](https://github.com/Kotlin/kotlinx-datetime)
[6](https://v3.leedo.me/devs/88)
[7](https://alexzh.com/date-and-time-formatting-in-kotlin-with-the-datetime-library/)
[8](https://www.youtube.com/watch?v=gzHy6wKAJh8)
[9](https://www.reddit.com/r/csharp/comments/tsiy08/datetime_datetimeoffset_postgresql_beat_practice/)
[10](https://velog.io/@devcat/Scheduled)
[11](https://umbum.tistory.com/922)
[12](https://umanking.github.io/2020/05/09/java-date-time/)
[13](https://jh-tr.tistory.com/291)
[14](https://eleunadeu.tistory.com/152)
[15](https://puddingcamp.com/topics/event-time-issues-best-practices-utc-conversion-user-errors-timezone-complexity)
[16](https://velog.io/@dankj1991/JavaTimeChronoTemporal)
[17](https://www.python.digibeatrix.com/ko/time-date/python-time-module-guide/)
[18](https://hane-1.tistory.com/90)
[19](https://365ok.co.kr/okinfo/4670)
[20](https://gift123.tistory.com/18)
[21](https://velog.io/@dankj1991/JavaTimeParseFormat)
[22](https://cross-code.github.io/posts/3rule_for_date_handling/)
[23](https://www.reddit.com/r/dotnet/comments/pwfxlw/how_do_you_prefer_to_work_with_dates_in_your_net/)
[24](https://dev.gmarket.com/49)
[25](https://meetup.nhncloud.com/posts/232)
[26](https://jeong-pro.tistory.com/163)
[27](https://bugfender.com/blog/kotlin-dates/)
[28](https://discuss.kotlinlang.org/t/date-time-best-practices-for-kotlin-native/7308)
[29](https://discuss.kotlinlang.org/t/kotlin-time-duration-and-java-reflection/17361)
[30](https://stackoverflow.com/questions/74024482/how-to-convert-datetime-string-to-utc-format-in-kotlin)
[31](https://stackoverflow.com/questions/75181397/using-kotlin-duration-with-java-time-fluently)
[32](https://stackoverflow.com/questions/59846004/what-is-the-best-way-to-operate-with-time-in-kotlin)
[33](https://kotlinlang.org/docs/java-interop.html)
[34](https://minchanyoun.tistory.com/183)
[35](https://betterprogramming.pub/date-formatting-with-kotlin-multiplatform-1329a2b75bb)
[36](https://developer.android.com/kotlin/interop?hl=ko)
[37](https://yebali.tistory.com/80)
[38](https://kotlinworld.com/80)
[39](https://kotlinworld.com/57)
[40](https://hoestory.tistory.com/58)
[41](https://growingsaja.tistory.com/987)