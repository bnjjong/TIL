# 📘 5.3 잠재적인 핫 코드 경로가 존재하는 단어 서비스

## 5.3.0 개요

* 두 개의 기능을 가진 **단어 서비스(Word Service)** 구축 예시

    1. **오늘의 단어 제공 (word-of-the-day)**
    2. **단어 존재 여부 확인 (word-exists)**

서비스는 `WordsService` 인터페이스로 정의되며, API 엔드포인트를 통해 외부에 노출된다.

---

## 5.3.1 오늘의 단어 얻기

* **핵심 아이디어**: 오늘 날짜(LocalDate)를 기반으로 인덱스를 계산 → 사전 파일에서 단어 반환

* 인덱스 계산식:

  ```
  now.getYear() + now.getDayOfYear() * MULTIPLY_FACTOR
  ```

    * `MULTIPLY_FACTOR = 100` (임의의 수 가능)
    * 단순히 `LocalDate.now()`만 쓰지 않고, 테스트 용이성을 위해 **공급자 함수(IntSupplier)** 로 분리

* 구현 로직:

    * `Scanner`를 이용해 사전 파일을 한 줄씩 읽는다.
    * 기대하는 인덱스 위치에 도달하면 단어 반환.
    * 인덱스가 파일 범위를 초과하면 `"No word today."` 반환.

📌 **저의 생각**
→ 테스트 가능성과 단순성을 고려한 설계. 실제 대용량 환경에서는 파일 전체 순회 방식은 병목이 될 수 있어 캐싱이나 인덱스화가 필요할 것 같음.

---

## 5.3.2 단어 존재 여부 확인

* `wordExists(String word)` 메서드

    * 파일 전체를 순회하면서 단어를 검색.
    * 발견 시 `true`, 끝까지 없으면 `false`.
    * 현재는 SLA, 성능 최적화 고려 X.

📌 **저의 생각**
→ 초반 단계에서 “성급한 최적화는 금물”이라는 철학이 잘 반영됨. 실제 트래픽/요구사항을 모니터링한 후 최적화해야 함.

---

## 5.3.3 HTTP 서비스 공개

* `WordsController`를 통해 두 기능을 HTTP 엔드포인트로 노출:

    * `/words/word-of-the-day` → 오늘의 단어
    * `/words/word-exists?word=xxx` → 단어 존재 여부 확인
* Dropwizard HTTP 서버를 사용하여 구동.

📌 **저의 생각**
→ API 설계의 기본기를 잘 보여주는 예시. 하지만 `word-exists` 엔드포인트는 사용 빈도가 훨씬 높을 가능성이 커서 잠재적 **핫 코드 경로(hot path)** 후보임.

---

## 5.3.x 성능 관찰 및 향후 최적화 고려

* 예상 트래픽:

    * `/word-of-the-day` : 초당 1회
    * `/word-exists` : 초당 20회
* 즉, `word-exists`가 전체 요청의 약 **95%** 차지 → 파레토 법칙에 부합.
* 따라서 **성능 테스트 (예: Gatling)** 를 통해 실제 대기 시간 및 최적화 필요성 평가.

---

# 📝 요약 (한 줄 압축)

> 5.3 절은 “성급한 최적화보다 실제 트래픽 기반의 **핫 코드 경로 최적화**”의 중요성을 단어 서비스 예제로 보여준다.

---

# 💻 Kotlin 예제 코드 (as-is / to-be)

## As-Is (단순 구현)

```kotlin
class WordService(private val dictionaryPath: Path) {
    private val multiplyFactor = 100

    fun getWordOfTheDay(): String {
        val index = getIndexForToday()
        Files.newBufferedReader(dictionaryPath).use { reader ->
            reader.lineSequence().forEachIndexed { i, line ->
                if (i == index) return line
            }
        }
        return "No word today."
    }

    fun wordExists(word: String): Boolean {
        Files.newBufferedReader(dictionaryPath).use { reader ->
            reader.lineSequence().forEach { line ->
                if (line == word) return true
            }
        }
        return false
    }

    private fun getIndexForToday(): Int {
        val now = LocalDate.now()
        return now.year + now.dayOfYear * multiplyFactor
    }
}
```

## To-Be (테스트 가능성 + 최적화 고려)

```kotlin
class WordServiceV2(
    private val dictionaryPath: Path,
    private val indexProvider: () -> Int = { defaultIndex() }
) {
    companion object {
        private const val MULTIPLY_FACTOR = 100
        fun defaultIndex(): Int {
            val now = LocalDate.now()
            return now.year + now.dayOfYear * MULTIPLY_FACTOR
        }
    }

    // 오늘의 단어 (캐싱 추가 가능)
    fun getWordOfTheDay(): String {
        val index = indexProvider()
        return Files.newBufferedReader(dictionaryPath).use { reader ->
            reader.lineSequence().elementAtOrNull(index) ?: "No word today."
        }
    }

    // 단어 존재 여부 (향후 인메모리 Set으로 최적화 가능)
    fun wordExists(word: String): Boolean {
        return Files.newBufferedReader(dictionaryPath).use { reader ->
            reader.lineSequence().any { it == word }
        }
    }
}
```

---

# ✅ Kotest 테스트 예제

```kotlin
class WordServiceTest : StringSpec({
    val testFile = Files.createTempFile("words", ".txt").apply {
        Files.write(this, listOf("apple", "banana", "cherry"))
    }

    "오늘의 단어가 올바른 인덱스로 반환된다" {
        val service = WordServiceV2(testFile) { 1 } // banana 인덱스 강제
        service.getWordOfTheDay() shouldBe "banana"
    }

    "단어가 존재하는 경우 true를 반환한다" {
        val service = WordServiceV2(testFile)
        service.wordExists("cherry") shouldBe true
    }

    "단어가 존재하지 않는 경우 false를 반환한다" {
        val service = WordServiceV2(testFile)
        service.wordExists("durian") shouldBe false
    }
})
```

---

# 🌐 참고 자료

* [Dropwizard Framework](https://www.dropwizard.io) → 경량 웹 서비스 구축용
* [Gatling](https://gatling.io/open-source/) → 성능 테스트 도구
* [파레토 법칙(80/20 Rule)](https://en.wikipedia.org/wiki/Pareto_principle)

---

