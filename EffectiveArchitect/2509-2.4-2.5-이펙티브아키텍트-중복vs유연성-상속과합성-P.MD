## 2.4 코드 중복으로 느슨한 결합 향상시키기

* 시나리오: **일반 추적 요청(Trace)** 과 **그래프 추적 요청(GraphTrace)** 을 **각각의 처리기**(TraceRequestHandler, GraphTraceRequestHandler)로 독립 처리. 두 처리기는 서로 결합되지 않음. 핵심 차이는 **payload 생성 방식만 다름**(String vs Int 기반 가공).
* **버퍼링 로직**: 처리기는 고정 크기 버퍼에 요청을 쌓되, 가득 차면 추가 요청은 무시하고 `processed=true` 로 마킹. 단위 테스트는 버퍼 크기 4에서 5번째 요청이 드롭됨을 검증. 공통 로직은 대부분 동일하고, **payload 생성만 서로 다르다**는 점이 드러남.
* **포인트**: 중복을 감수하면(**처리기 2개 유지**) 결합은 약해짐(변경 영향 적음). 하지만 공통 처리 로직이 **양쪽에 흩어져** 유지보수 비용과 오류 가능성이 증가.

### 내 생각 (2.4)

현업에선 “초기에는 중복 허용 → 변화 양상 관찰 → 진짜 공통분모가 안정화되면 추상화”가 안전합니다. 중복 제거를 서두르면 “잘못된 추상화”로 더 큰 비용을 치르게 되거든요. 이 절은 그 출발 지점을 깔끔히 보여줘요.

---

## 2.5 중복을 줄이기 위해 상속을 사용하는 API 설계

### 2.5.1 공통 상위 타입/기초 처리기 추출

* 공통 필드·행동(`isTraceEnabled`)을 **추상 부모** `TraceRequest`로 끌어올림. `Trace`와 `GraphTrace` 가 이를 상속.
* 처리기 공통 로직(`processRequest`)을 **제네릭 기반 부모** `BaseTraceRequestHandler<T extends TraceRequest>` 로 추출하고, **서브클래스는 payload 생성만 구현**(`createPayload(T)`)하도록 함. 결과적으로 DRY 달성, 코드 양 감소.

### 2.5.2 상속과 강한 결합의 문제

* 새 요구사항: **그래프 처리기만** “무한 버퍼”로 바꾸고 싶다. 하지만 `processRequest` 가 부모에 묶여 있어 **특정 자식만 다르게 바꾸기 어렵다**. 일시적으로 `instanceof` 조건 분기 같은 해법은 **부모가 자식 구현을 알게 되어 추상화 누수/결합 강화**를 초래.

### 2.5.3 상속 vs 합성(전략) 트레이드오프

* 대안: **합성(전략 패턴)** 으로 “payload 변환”과 “버퍼 관리”를 **각각 독립 전략**(인터페이스)으로 분리해 주입. 그러면 “무한 버퍼/고정 크기 버퍼/사이즈 기반 버퍼” 등 다양한 정책을 필요 시점에 교체 가능. 단, **추상화 수 증가로 이해 복잡도 상승**.

### 2.5.4 내재된 중복 vs 우연한 중복

* 겉보기 중복이라도 “**다르게 진화할 것**”이라면 **우연한 중복**이므로 성급히 합치면 안 됨. 반대로 “**실제로 동일하게 굳어진 패턴**”이면 그때 추상화하는 게 바람직. 설계는 항상 **유연성 ↔ 단순성**의 균형 문제다.

### 내 생각 (2.5)

상속은 초기엔 달콤하지만 요구사항 방향이 갈라지면 곧장 족쇄가 됩니다. 변화 축이 여러 개라면 **합성으로 축을 분리**해 각자 독립 진화를 허용하는 편이 안전합니다. 특히 광고/캠페인 도메인처럼 정책이 자주 바뀌는 곳은 합성 쪽이 유리해요.

---

## 한눈에 보는 비교표

| 항목            | **상속(추상 부모 + 자식 처리기)**        | **합성(전략 주입)**                 |
| ------------- | ----------------------------- | ----------------------------- |
| 중복 제거         | 쉽다(부모에 공통 로직 집중)              | 전략 단위로 제거(조금 더 설계 필요)         |
| 유연성(부분 요구 변경) | **약함**: 부모에 묶임, 특정 자식만 다르게 힘듦 | **강함**: 전략 교체/조합으로 세밀 조절      |
| 결합도           | **상향 결합 위험**(부모↔자식)           | 낮음(전략 인터페이스 의존)               |
| 이해 난이도        | 낮음                            | **상대적으로 높음**(추상화 수 증가)        |
| 적용 적기         | 요구사항이 **안정**, 차이가 payload 정도  | 요구 변화 축이 **다양/빈번**, 정책이 자주 바뀜 |

(직접 작성 요약표)

---

# 참고 그림 (직접 작성)

```
[상속 기반]
BaseTraceRequestHandler
 ├─ TraceRequestHandler (createPayload: Trace→String)
 └─ GraphTraceRequestHandler (createPayload: GraphTrace→String)

[합성 기반]
TraceHandler
  ├─ PayLoadTransformer (Trace|GraphTrace → String)
  └─ BufferPolicy (Fixed|Infinite|SizeBased)
```

(직접 작성 도식)

---

# 바깥 자료로 보는 맥락(초간단 정리)

* **합성 우선**: 상속은 캡슐화를 깨고(부모 구현 변화 → 자식 파급) API를 경직시킴. 합성이 대체로 더 유연. ([blogs.oracle.com][1], [sglavoie.com][2], [ekis.github.io][3])
* **전략 패턴**: 런타임에 알고리즘(정책) 바꿔끼우기. 우리 사례의 “버퍼 정책/페이로드 변환”에 딱 맞음. ([refactoring.guru][4], [One Wheel Studio][5])
* **DRY의 함정**: 모든 중복이 악은 아님. ‘우연한 중복’을 성급히 합치면 더 큰 결합/복잡성 유발. **프래그머틱 DRY**가 중요. ([anthonysciamanna.com][6], [algocademy.com][7], [eBay Inc.][8], [philosophicalhacker.com][9])
* **LSP 관점**: 특정 자식만 예외 처리하려는 순간 LSP 위반 신호. 상속 대신 합성/전략을 검토. ([tomdalling.com][10], [Software Engineering Stack Exchange][11], [Medium][12])

---

# Kotlin 예제 (도메인 있는 로직, as-is → to-be, Kotest 포함)

## 배경 도메인

* **광고 집행 로그(Trace)** 와 **그래프 지표 로그(GraphTrace)** 를 수집하여 후처리.
* 요구사항:

    1. 기본은 **버퍼 크기 N** 으로 적재.
    2. 그래프 지표 쪽은 **버퍼 무제한**으로 전환 요청 발생.

### AS-IS: 상속 기반 (부모에 공통 처리, 자식은 payload만 구현)

```kotlin
// 공통 추상 요청 (상위 타입)
abstract class TraceRequest(val traceEnabled: Boolean)

class AdTrace(traceEnabled: Boolean, val data: String) : TraceRequest(traceEnabled)
class GraphMetricTrace(traceEnabled: Boolean, val nodeId: Int) : TraceRequest(traceEnabled)

// 상속 기반 기초 처리기
abstract class BaseTraceRequestHandler<T : TraceRequest>(
    private val bufferSize: Int
) {
    private val buffer = mutableListOf<String>()
    private var processed = false

    fun process(req: T) {
        if (!processed && !req.traceEnabled) return
        if (buffer.size < bufferSize) {
            buffer += createPayload(req) // 공통 처리
            if (buffer.size == bufferSize) processed = true
        }
    }

    fun isProcessed(): Boolean = processed
    fun snapshot(): List<String> = buffer.toList()

    protected abstract fun createPayload(req: T): String
}

class AdTraceHandler(size: Int) : BaseTraceRequestHandler<AdTrace>(size) {
    override fun createPayload(req: AdTrace): String = "${req.data}-content"
}

class GraphMetricTraceHandler(size: Int) : BaseTraceRequestHandler<GraphMetricTrace>(size) {
    override fun createPayload(req: GraphMetricTrace): String = "${req.nodeId}-nodeId"
}

// ❗요구 변경: 그래프만 무한 버퍼로 바꾸고 싶다 → 부모 로직에 묶여 쉽게 못 바꿈(2.5.2 문제점)
```

### TO-BE: 합성(전략) 기반 (PayloadTransformer, BufferPolicy 분리)

```kotlin
// 전략: Payload 변환
fun interface PayloadTransformer<T : TraceRequest> {
    fun transform(req: T): String
}

// 전략: 버퍼 정책
interface BufferPolicy {
    /** @return true if entry is accepted into buffer */
    fun tryAdd(buffer: MutableList<String>, entry: String): Boolean
}
class FixedSizeBuffer(private val capacity: Int) : BufferPolicy {
    override fun tryAdd(buffer: MutableList<String>, entry: String): Boolean {
        if (buffer.size >= capacity) return false
        buffer += entry
        return true
    }
}
object InfiniteBuffer : BufferPolicy {
    override fun tryAdd(buffer: MutableList<String>, entry: String): Boolean {
        buffer += entry; return true
    }
}

// 합성 기반 처리기: 두 전략을 주입받음
class TraceHandler<T : TraceRequest>(
    private val transformer: PayloadTransformer<T>,
    private val bufferPolicy: BufferPolicy
) {
    private val buffer = mutableListOf<String>()

    fun process(req: T) {
        if (!req.traceEnabled) return
        val payload = transformer.transform(req)
        bufferPolicy.tryAdd(buffer, payload)
    }
    fun snapshot(): List<String> = buffer.toList()
}
```

### 사용 예 (도메인에 맞춘 구성)

```kotlin
// 광고 로그(고정 크기 버퍼)
val adHandler = TraceHandler(
    transformer = PayloadTransformer<AdTrace> { "${it.data}-content" },
    bufferPolicy = FixedSizeBuffer(capacity = 4)
)

// 그래프 지표 로그(무한 버퍼)
val graphHandler = TraceHandler(
    transformer = PayloadTransformer<GraphMetricTrace> { "${it.nodeId}-nodeId" },
    bufferPolicy = InfiniteBuffer
)
```

### Kotest 테스트

```kotlin
import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.collections.shouldContainExactly

class TraceHandlersTest : StringSpec({

    "AS-IS: 상속 기반 - 고정 버퍼 동작" {
        val h = AdTraceHandler(4)
        listOf("a","b","c","d","e").forEach { h.process(AdTrace(true, it)) }

        h.snapshot() shouldContainExactly listOf(
            "a-content","b-content","c-content","d-content"
        )
        assert(h.isProcessed())
    }

    "TO-BE: 합성 기반 - 광고는 고정, 그래프는 무한" {
        val ad = TraceHandler(
            transformer = PayloadTransformer<AdTrace> { "${it.data}-content" },
            bufferPolicy = FixedSizeBuffer(2)
        )
        val graph = TraceHandler(
            transformer = PayloadTransformer<GraphMetricTrace> { "${it.nodeId}-nodeId" },
            bufferPolicy = InfiniteBuffer
        )

        ad.process(AdTrace(true, "A")); ad.process(AdTrace(true, "B")); ad.process(AdTrace(true, "C"))
        graph.process(GraphMetricTrace(true, 1)); graph.process(GraphMetricTrace(true, 2)); graph.process(GraphMetricTrace(true, 3))

        ad.snapshot() shouldContainExactly listOf("A-content","B-content")     // C는 드롭
        graph.snapshot() shouldContainExactly listOf("1-nodeId","2-nodeId","3-nodeId") // 무한 수용
    }
})
```

> 주석 포인트
>
> * **AS-IS**: 부모가 버퍼 정책까지 쥐고 있어 **자식의 차별화가 어렵다**.
> * **TO-BE**: 버퍼/변환을 전략으로 쪼개 **변화 축을 분리**. 요구가 바뀌면 전략만 교체.

---

# 마지막 요약(초압축)

* 2.4는 **중복 유지 ↔ 결합 완화**의 관점 제시: 초기에 중복을 허용하면 컴포넌트 독립성이 높아진다.
* 2.5는 **상속으로 DRY 달성**하되 **유연성 상실** 위험을 보여주고, 대안으로 **합성(전략)** 을 제시한다. 중복은 ‘내재/우연’을 구분해 `나중에 추상화`해도 늦지 않다.

---

# 추천 추가 자료(간략 정리 + 링크)

* **Composition over Inheritance**: 상속은 캡슐화 위반·깨지기 쉬움 → 합성이 대체로 안전. Effective Java Item 18 요지. ([blogs.oracle.com][1], [sglavoie.com][2], [ekis.github.io][3])
* **Strategy 패턴**: 알고리즘(정책) 교체로 유연성 확보—우리의 버퍼/변환 분리에 그대로 적용. ([refactoring.guru][4], [One Wheel Studio][5])
* **Pragmatic DRY**: 모든 중복 제거가 선은 아니다. 우연한 중복은 성급한 추상화보다 관찰 후 흡수. ([anthonysciamanna.com][6], [algocademy.com][7], [eBay Inc.][8])
* **LSP**: 특정 자식만 특별취급하려 들면 상속 오남용 신호—합성으로 전환 고려. ([tomdalling.com][10], [Software Engineering Stack Exchange][11])

---


[1]: https://blogs.oracle.com/javamagazine/post/java-inheritance-composition?utm_source=chatgpt.com "You should favor composition over inheritance in Java. ..."
[2]: https://www.sglavoie.com/posts/2023/06/11/book-summary-effective-java/?utm_source=chatgpt.com "Book summary: Effective Java - sglavoie.com"
[3]: https://ekis.github.io/effective-java-3rd-edition/?utm_source=chatgpt.com "Effective Java - 3rd Edition Notes"
[4]: https://refactoring.guru/design-patterns/strategy?utm_source=chatgpt.com "Strategy"
[5]: https://onewheelstudio.com/blog/2020/8/16/strategy-pattern-composition-over-inheritance?utm_source=chatgpt.com "Strategy Pattern - Composition over Inheritance"
[6]: https://anthonysciamanna.com/2018/07/28/the-dry-principle-and-incidental-duplication.html?utm_source=chatgpt.com "The DRY Principle and Incidental Duplication"
[7]: https://algocademy.com/blog/why-your-code-duplication-isnt-always-bad-a-pragmatic-approach-to-the-dry-principle/?utm_source=chatgpt.com "Why Your Code Duplication Isn't Always Bad: A Pragmatic ..."
[8]: https://innovation.ebayinc.com/stories/is-duplication-always-a-bad-thing/?utm_source=chatgpt.com "Is Duplication Always a Bad Thing? - Innovation at eBay"
[9]: https://www.philosophicalhacker.com/post/when-to-dry/?utm_source=chatgpt.com "When should we create abstractions instead of duplication?"
[10]: https://www.tomdalling.com/blog/software-design/solid-class-design-the-liskov-substitution-principle/?utm_source=chatgpt.com "SOLID Class Design: The Liskov Substitution Principle"
[11]: https://softwareengineering.stackexchange.com/questions/170222/what-can-go-wrong-if-the-liskov-substitution-principle-is-violated?utm_source=chatgpt.com "What can go wrong if the Liskov substitution principle is ..."
[12]: https://medium.com/%40markjackmilian/whos-afraid-of-the-liskov-substitution-principle-d908a6994161?utm_source=chatgpt.com "Who's Afraid of the Liskov Substitution Principle?"
