# 이펙티브 소프트웨어 설계 - 5.4~5.5 핫 코드 경로 탐지와 최적화

## 5.4 핫 코드 경로 탐지

### 5.4.1 파레토 법칙과 트래픽 분석

**핫 코드 경로란** 전체 애플리케이션에서 대부분의 성능 부하를 차지하는 주요 실행 경로를 의미한다.[^1]

책에서 예시로 든 Words 애플리케이션의 트래픽 분석:

- `word-of-the-day` 엔드포인트: 초당 1 요청 (약 5%)
- `word-exists` 엔드포인트: 초당 20 요청 (약 95%)

계산식:

- 1 ÷ (20 + 1) = ~5%
- 20 ÷ (20 + 1) = ~95%

이는 파레토 법칙(80/20 규칙)을 넘어서는 극단적인 분포를 보여준다.[^1]

**⚡ 내 생각:** 실무에서도 이런 극단적인 트래픽 분포는 자주 발견된다. 대부분의 리소스가 소수의 API에 집중되므로, 전체 시스템을 최적화하기보다는 핫스팟을 정확히 찾아 집중하는 것이 훨씬 효율적이다.

### 5.4.2 Gatling을 활용한 성능 테스트

#### 초기 성능 벤치마크 결과

| Endpoint | p99 (ms) | Mean (ms) | 요청 수 | SLA 내 비율 |
| :-- | :-- | :-- | :-- | :-- |
| word-of-the-day | 361 | 143 | 60 | 100% |
| word-exists | 4773 | 2079 | 1200 | 0% |

word-exists 엔드포인트의 성능 문제가 명확히 드러났다. p99가 거의 5초에 달하며, 모든 요청이 SLA를 벗어난다.[^1]

#### 성능 영향도 계산

공식을 통한 성능 영향도:

- word-of-the-day: (1 × 360) = 360
- word-exists: (20 × 5,000) = 100,000

word-exists가 전체 시스템 부하의 99.7%를 차지한다는 것을 확인했다.[^1]

**⚡ 내 생각:** Gatling은 실제로 매우 강력한 성능 테스트 도구다. 스칼라 기반 DSL이지만 직관적이고, 생성되는 HTML 리포트가 훌륭하다. 특히 percentile 데이터와 시간대별 응답 시간 그래프는 성능 병목점을 찾는데 매우 유용하다.[^2]

### 5.4.3 MetricRegistry를 통한 세부 경로 측정

word-exists 메서드를 두 개의 타이머로 세분화:[^1]

1. `loadFile`: 파일 로딩 시간 측정
2. `scan`: 실제 단어 탐색 시간 측정

#### 측정 결과

| 구분 | p99 (ms) | 설명 |
| :-- | :-- | :-- |
| loadFile | 7 | 파일 로딩은 문제없음 |
| scan | 4860 | 스캔이 진짜 병목점 |

**⚡ 내 생각:** 이런 세분화된 메트릭은 정말 중요하다. 추측이 아닌 실제 데이터로 병목점을 찾을 수 있다. 드롭위저드의 MetricRegistry는 프로덕션 환경에서도 오버헤드가 적어서 실무에서도 자주 사용한다.

***

## 5.5 핫 코드 경로의 성능 개선

### 5.5.1 JMH 마이크로벤치마크 도입

고수준 Gatling 테스트 vs 저수준 JMH 마이크로벤치마크:[^1]

- Gatling: 전체 애플리케이션 성능 측정, 더 현실적이지만 느림
- JMH: 특정 코드 경로만 집중 측정, 빠른 피드백 가능


#### 기준선 벤치마크 결과

```
Benchmark                                    Mode  Score      Units
WordExistsPerformanceBenchmark.baseline     avgt  55440.923  ms/op
```

**⚡ 내 생각:** JMH는 JVM 레벨의 최적화(JIT 컴파일, 가비지 컬렉션 등)를 고려한 정확한 벤치마킹을 제공한다. 워밍업과 반복 실행으로 신뢰성 있는 결과를 얻을 수 있어서 라이브러리나 알고리즘 성능 비교에 필수다.[^3]

### 5.5.2 Guava Cache 적용을 통한 최적화

#### 캐시 전략 선택

1. **적극적 캐시**: 시작시 전체 데이터 로딩 → 메모리 과다 사용, 시작 지연
2. **지연 캐시**: 요청시 캐시 구성 → 메모리 효율적, 선택한 방식[^1]

#### 캐시 구성 정책

- **Eviction**: `expireAfterAccess(5분)`
- **Statistics**: 캐시 효율성 모니터링 활성화
- **CacheLoader**: 캐시 미스시 자동 데이터 로딩[^1]


#### 최적화 결과

| 구현 | 평균 처리 시간 (ms/op) | 성능 향상 배율 |
| :-- | :-- | :-- |
| DefaultWordsService(AS-IS) | 55440 | 1x |
| CachedWordsService(TO-BE) | 557 | 약 100배 |

#### E2E 성능 테스트 결과

캐시 적용 후 Gatling 테스트:[^1]

- word-exists p99: 4773ms → 65ms (약 73배 향상)
- 전체 시스템 부하 비율: word-exists 99.7% → 79%

**⚡ 내 생각:** 100배 성능 향상은 정말 드라마틱하다. Guava Cache의 `LoadingCache`는 단순하면서도 강력하다. `expireAfterAccess` 정책은 실제 사용 패턴을 고려한 지능적인 캐시 관리를 제공한다.[^4]

### 5.5.3 더 현실적인 성능 테스트

#### 문제점 발견

초기 테스트는 6개 단어만 사용해서 캐시 히트율이 비현실적으로 높았다.[^1]

#### 개선된 테스트

- 100개 랜덤 단어 사용
- 콜드 캐시 상황 시뮬레이션[^1]


#### 결과

더 많은 단어로 테스트시 p99가 65ms → 2860ms로 상승. 캐시 미스율이 약 10%였다.[^1]

**⚡ 내 생각:** 이 부분이 정말 중요하다. 실제 프로덕션 환경에서는 캐시 미스, 콜드 스타트, 메모리 압박 등 다양한 상황을 고려해야 한다. 너무 이상적인 테스트 조건은 오히려 잘못된 판단으로 이어질 수 있다.

***

## 예제 코드 (Kotlin 구현)

### AS-IS: 기본 단어 검증 서비스

```kotlin
import java.nio.file.Files
import java.nio.file.Path

/**
 * 기존 단어 검증 서비스 - 매번 파일을 읽어서 성능이 매우 느림
 * 도메인: 온라인 사전 서비스의 단어 존재 여부 검증
 */
class DefaultWordsService(private val wordsFilePath: Path) : WordsService {
    
    override fun wordExists(word: String): Boolean {
        // 매번 파일을 새로 읽음 - 비효율적
        Files.newBufferedReader(wordsFilePath).use { reader ->
            reader.forEachLine { line ->
                if (line.trim().equals(word, ignoreCase = true)) {
                    return true
                }
            }
        }
        return false
    }
}
```


### TO-BE: Guava Cache 적용 서비스

```kotlin
import com.google.common.cache.CacheBuilder
import com.google.common.cache.CacheLoader
import com.google.common.cache.LoadingCache
import java.nio.file.Files
import java.nio.file.Path
import java.util.concurrent.TimeUnit

/**
 * 캐시 기반 단어 검증 서비스 - Guava LoadingCache로 성능 최적화
 * 도메인: 온라인 사전 서비스의 고성능 단어 검증
 */
class CachedWordsService(
    private val wordsFilePath: Path
) : WordsService {
    
    // LoadingCache로 자동 데이터 로딩 및 캐시 관리
    private val cache: LoadingCache<String, Boolean> = CacheBuilder.newBuilder()
        .expireAfterAccess(5, TimeUnit.MINUTES) // 5분간 미접근시 자동 제거
        .recordStats() // 캐시 통계 활성화 (히트율, 미스율 모니터링)
        .build(object : CacheLoader<String, Boolean>() {
            override fun load(word: String): Boolean {
                // 캐시 미스시에만 실제 파일 검색 수행
                return checkWordInFile(word)
            }
        })

    override fun wordExists(word: String): Boolean {
        // 캐시에서 조회, 없으면 자동으로 load() 호출
        return cache.get(word)
    }
    
    /**
     * 실제 파일에서 단어 검색 수행
     * 캐시 미스시에만 호출되어 I/O 부하 최소화
     */
    private fun checkWordInFile(word: String): Boolean {
        Files.newBufferedReader(wordsFilePath).use { reader ->
            reader.forEachLine { line ->
                if (line.trim().equals(word, ignoreCase = true)) {
                    return true
                }
            }
        }
        return false
    }
    
    /**
     * 캐시 통계 조회용 메서드 (모니터링 목적)
     */
    fun getCacheStats() = cache.stats()
}
```


### Kotest 단위 테스트

```kotlin
import io.kotest.core.spec.style.FunSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldBeGreaterThan
import java.nio.file.Path

class CachedWordsServiceTest : FunSpec({
    
    test("캐시 미스 후 히트 동작 검증") {
        // given: 테스트용 단어 파일 경로 (실제로는 테스트 리소스 사용)
        val wordsPath = Path.of("src/test/resources/test-words.txt")
        val service = CachedWordsService(wordsPath)
        
        // when: 첫 번째 호출 (캐시 미스)
        val firstResult = service.wordExists("hello")
        val statsAfterMiss = service.getCacheStats()
        
        // then: 결과 확인 및 캐시 미스 통계 검증
        firstResult shouldBe true
        statsAfterMiss.missCount() shouldBe 1L
        statsAfterMiss.hitCount() shouldBe 0L
        
        // when: 두 번째 호출 (캐시 히트)
        val secondResult = service.wordExists("hello")
        val statsAfterHit = service.getCacheStats()
        
        // then: 캐시 히트 확인
        secondResult shouldBe true
        statsAfterHit.hitCount() shouldBe 1L
        statsAfterHit.hitRate() shouldBeGreaterThan 0.0
    }
    
    test("존재하지 않는 단어도 캐시되는지 확인") {
        // given
        val wordsPath = Path.of("src/test/resources/test-words.txt")
        val service = CachedWordsService(wordsPath)
        
        // when: 존재하지 않는 단어 검색
        val result1 = service.wordExists("nonexistentword")
        val result2 = service.wordExists("nonexistentword") // 캐시 히트
        
        // then: 결과는 false이지만 캐시는 동작
        result1 shouldBe false
        result2 shouldBe false
        service.getCacheStats().hitCount() shouldBe 1L
    }
})
```


***

## 관련 자료 및 링크

### 성능 테스트 도구

1. **Gatling 성능 테스트**
    - [Gatling - 또 하나의 성능 테스트 도구](https://rightnowdo.tistory.com/entry/Gatling-%EB%98%90-%ED%95%98%EB%82%98%EC%9D%98-%EC%84%B1%EB%8A%A5-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8F%84%EA%B5%AC-1%ED%83%84-%EC%9D%BC%EB%8B%A8-%ED%95%B4%EB%B3%B4%EC%9E%90)[^2]
    - Scala DSL 기반의 강력한 성능 테스트 프레임워크
    - 비동기 Non-blocking 방식으로 높은 부하 생성 가능
2. **JMH 마이크로벤치마크**
    - [JMH(Java Microbenchmark Harness) 가이드](https://wikidocs.net/294424)[^3]
    - JVM 레벨 최적화를 고려한 정확한 성능 측정
    - 워밍업, 반복 실행으로 신뢰성 있는 결과 제공

### 캐시 최적화

3. **Guava Cache 활용**
    - [Guava Cache 제대로 사용하기](https://ntalbs.github.io/2015/loading-cache/)[^4]
    - LoadingCache vs Cache 비교 및 실무 적용 사례
    - 캐시 정책 및 통계 활용 방법
4. **로컬 캐시 성능 비교**
    - [로컬 캐시 선택하기 - LG유플러스](https://techblog.uplus.co.kr/%EB%A1%9C%EC%BB%AC-%EC%BA%90%EC%8B%9C-%EC%84%A0%ED%83%9D%ED%95%98%EA%B8%B0-e394202d5c87)[^5]
    - Guava, Caffeine, EHCache 등 다양한 캐시 라이브러리 비교

***

## 요약

### 핵심 개념

- **핫 코드 경로 식별이 성능 최적화의 핵심**: 전체 시스템 중 95% 트래픽을 담당하는 경로에 집중[^1]
- **단계적 성능 진단**: Gatling (고수준) → MetricRegistry (중수준) → JMH (저수준)[^1]
- **캐시를 통한 극적 성능 향상**: 기본 구현 대비 100배 성능 개선 달성[^1]


### 실무 적용 포인트

- **실측 기반 최적화**: 추측이 아닌 실제 벤치마크 데이터로 병목점 파악
- **현실적인 테스트 환경**: 캐시 미스, 콜드 스타트 등 실제 운영 상황 고려[^1]
- **지속적인 모니터링**: 캐시 통계, 성능 메트릭을 통한 최적화 효과 검증


### 성능 최적화 공식

```
성능 영향도 = 처리량(RPS) × 응답시간(ms)
최적화 우선순위 = 성능 영향도가 높은 경로부터
```

<span style="display:none">[^10][^11][^12][^13][^14][^15][^16][^17][^18][^19][^20][^21][^22][^6][^7][^8][^9]</span>


[^1]: 2504-ipegtibeu-sopeuteuweeo-seolgye-pages-157-174.pdf

[^2]: https://rightnowdo.tistory.com/entry/Gatling-또-하나의-성능-테스트-도구-1탄-일단-해보자

[^3]: https://wikidocs.net/294424

[^4]: https://ntalbs.github.io/2015/loading-cache/

[^5]: https://techblog.uplus.co.kr/로컬-캐시-선택하기-e394202d5c87

[^6]: https://code-run.tistory.com/42

[^7]: https://stir.tistory.com/413

[^8]: https://rnesw.blog/performance-improving/

[^9]: https://junuuu.tistory.com/902

[^10]: https://developer.android.com/topic/performance/benchmarking/microbenchmark-write?hl=ko

[^11]: https://bezzang2.tistory.com/193

[^12]: https://serverwizard.tistory.com/97

[^13]: https://upcurvewave.tistory.com/607

[^14]: https://0soo.tistory.com/237

[^15]: https://helloino.tistory.com/130

[^16]: https://brocess.tistory.com/16

[^17]: https://javabom.tistory.com/75

[^18]: https://developer-nyong.tistory.com/78

[^19]: https://hoding-cloud.tistory.com/16

[^20]: https://velog.io/@songjseop/kotlin-iterable-sequence

[^21]: https://velog.io/@junho5336/그래서-그거-어떻게-하는데요-feat.-성능-테스트-도구

[^22]: https://ppl-ai-code-interpreter-files.s3.amazonaws.com/web/direct-files/59e6e70413d79c6abc93c1a7b67e7167/f9d8abe1-3943-470c-9259-f975b7ebc816/eb923103.MD

