# 2ì¥ ì½”ë“œ ì¤‘ë³µ ëŒ€ ìœ ì—°ì„± - ì½”ë“œ ì¤‘ë³µì´ í•­ìƒ ë‚˜ì˜ì§€ë§Œì€ ì•Šë‹¤

## ê°œìš” (í˜ì´ì§€ 18-19)

DRY(Don't Repeat Yourself) ì›ì¹™ì€ ê°€ì¥ ì˜ ì•Œë ¤ì§„ ì†Œí”„íŠ¸ì›¨ì–´ ê³µí•™ ê·œì¹™ì´ë‹¤. í•˜ì§€ë§Œ ê°€ëŠ¥í•œ ëª¨ë“  ì‹œìŠ¤í…œì„ êµ¬ì¶•í•˜ëŠ” ê³¼ì •ì—ì„œ DRY ì›ì¹™ì— ì§€ë‚˜ì¹˜ê²Œ ì§‘ì¤‘í•˜ëŠ” ê²ƒì€ ìœ„í—˜í•  ìˆ˜ ìˆìœ¼ë©° ë§ì€ ë³µì¡ì„±ì„ ìˆ¨ê¸¸ ìˆ˜ ìˆë‹¤.

ì˜¤ëŠ˜ë‚  ë¶„ì‚° ì‹œìŠ¤í…œì—ì„œ ì½”ë“œ ì¤‘ë³µì„ ì¤„ì´ë ¤ëŠ” ì„ íƒì€:
- ì»´í¬ë„ŒíŠ¸ ì‚¬ì´ì— ê°•í•œ ê²°í•© ì´ˆë˜
- íŒ€ì˜ ê°œë°œ ì†ë„ ì €í•˜  
- ì—¬ëŸ¬ ì¥ì†Œì—ì„œ ì‚¬ìš©ë  ì½”ë“œ ë³€ê²½ ì‹œ ë§ì€ ì¡°ì • í•„ìš”

### ğŸ’¡ ì €ìì˜ ì˜ê²¬
DRY ì›ì¹™ì„ ë§¹ëª©ì ìœ¼ë¡œ ë”°ë¥´ê¸°ë³´ë‹¤ëŠ” ìƒí™©ì— ë§ëŠ” íŠ¸ë ˆì´ë“œì˜¤í”„ë¥¼ ê³ ë ¤í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤. íŠ¹íˆ ë¶„ì‚° ì‹œìŠ¤í…œì—ì„œëŠ” ì¤‘ë³µì„ í—ˆìš©í•˜ëŠ” ê²ƒì´ ë” ë‚˜ì€ ì„ íƒì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## 2.1 ì½”ë“œë² ì´ìŠ¤ ì‚¬ì´ì˜ ê³µí†µ ì½”ë“œì™€ ì¤‘ë³µ (í˜ì´ì§€ 18-23)

### 2.1.1 ì‹œë‚˜ë¦¬ì˜¤ ì„¤ì • (í˜ì´ì§€ 18-19)

ë‘ íŒ€ì´ ë…ë¦½ì ì¸ ì„œë¹„ìŠ¤ë¥¼ ê°œë°œí•˜ëŠ” ì‹œë‚˜ë¦¬ì˜¤:
- íŒ€ A: Payment ì„œë¹„ìŠ¤ (`/payment` ì—”ë“œí¬ì¸íŠ¸)
- íŒ€ B: Person ì„œë¹„ìŠ¤ (`/person` ì—”ë“œí¬ì¸íŠ¸)

ì´ë•Œ ë†’ì€ ê°œë°œ íšŒì „ìœ¨(ì†ë„)ì„ ì–»ì„ ìˆ˜ ìˆëŠ” ì´ìœ ëŠ” **íŒ€ ì‚¬ì´ì˜ ë™ê¸°í™”ê°€ í•„ìš”í•˜ì§€ ì•Šê¸° ë•Œë¬¸**ì´ë‹¤.

### ì•”ë‹¬ì˜ ë²•ì¹™ (Amdahl's Law) ì ìš© (í˜ì´ì§€ 18-19)

ì•”ë‹¬ì˜ ë²•ì¹™ì„ ì‚¬ìš©í•´ ë™ê¸°í™”ê°€ ì†Œí”„íŠ¸ì›¨ì–´ ë°°í¬ ê³¼ì •ì˜ ì „ì²´ ì‹œê°„ì— ë¯¸ì¹˜ëŠ” ì˜í–¥ì„ ê³„ì‚°í•  ìˆ˜ ìˆë‹¤:

| ë³‘ë ¬ ë¹„ì¤‘ | ìµœëŒ€ ì„±ëŠ¥ ê°œì„  | íŠ¹ì§• |
|-----------|---------------|------|
| 50% | 2ë°° | ë™ê¸°í™” ë¶€í•˜ê°€ ë†’ì•„ ì„±ëŠ¥ ê°œì„  ì œí•œì  |
| 75% | 4ë°° | ì ë‹¹í•œ ì„±ëŠ¥ ê°œì„  ê°€ëŠ¥ |
| 90% | 10ë°° | ìƒë‹¹í•œ ì„±ëŠ¥ ê°œì„  ê°€ëŠ¥ |
| 95% | 20ë°° | ë§¤ìš° ë†’ì€ ì„±ëŠ¥ ê°œì„  ê°€ëŠ¥ |

### 2.1.2 ìƒˆë¡œìš´ ë¹„ì¦ˆë‹ˆìŠ¤ ìš”êµ¬ì‚¬í•­: ì¸ê°€ ì»´í¬ë„ŒíŠ¸ ì¶”ê°€ (í˜ì´ì§€ 20-22)

ë‘ ì„œë¹„ìŠ¤ì— ì¸ê°€(authorization) ê¸°ëŠ¥ì„ ì¶”ê°€í•´ì•¼ í•˜ëŠ” ìš”êµ¬ì‚¬í•­ì´ ìƒê²¼ì„ ë•Œ:

**AS-IS: ì¤‘ë³µ êµ¬í˜„**
```kotlin
// Payment ì„œë¹„ìŠ¤ì˜ ì¸ê°€ ì»´í¬ë„ŒíŠ¸
class PaymentAuthService {
    fun isTokenValid(token: String): Boolean {
        return token == "secret"
    }
}

// Person ì„œë¹„ìŠ¤ì˜ ì¸ê°€ ì»´í¬ë„ŒíŠ¸  
class PersonAuthService {
    fun isTokenValid(token: String): Boolean {
        return token == "secret" // ë™ì¼í•œ```ì´ ì¤‘ë³µë¨
    }
}
```

### 2.1.3 ê²°ê³¼ í‰ê°€ (í˜ì´ì§€ 22-23)

**ì¥ì :**
- íŒ€ ê°„ ë…ë¦½ì  ê°œë°œ ê°€ëŠ¥
- ì¡°ì • ì—†ëŠ” ë¹ ë¥¸ ì‘ì—… ì§„í–‰

**ë‹¨ì :**
- ë” ë§ì€ ë²„ê·¸ì™€ ì‹¤ìˆ˜ ìœ ë°œ ê°€ëŠ¥
- ì§€ì‹ ê³µìœ  ë¶€ì¬
- ì¤‘ë³µëœ ì‘ì—… ìˆ˜í–‰

### ğŸ’¡ ì €ìì˜ ì˜ê²¬
ì´ˆê¸°ì—ëŠ” ì¤‘ë³µì„ í—ˆìš©í•˜ë”ë¼ë„ íŒ€ ê°„ ë…ë¦½ì„±ì„ ë³´ì¥í•˜ëŠ” ê²ƒì´ ì „ì²´ì ì¸ ê°œë°œ ì†ë„ í–¥ìƒì— ë„ì›€ì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## 2.2 ë¼ì´ë¸ŒëŸ¬ë¦¬, ê·¸ë¦¬ê³  ì½”ë“œë² ì´ìŠ¤ ì‚¬ì´ì—ì„œ ì½”ë“œ ê³µìœ  (í˜ì´ì§€ 23-27)

### 2.2.1 ê³µìœ  ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ íŠ¸ë ˆì´ë“œì˜¤í”„ì™€ ë‹¨ì  (í˜ì´ì§€ 24-26)

**TO-BE: ê³µìœ  ë¼ì´ë¸ŒëŸ¬ë¦¬ ì ‘ê·¼ë²•**
```kotlin
// ê³µìœ  ë¼ì´ë¸ŒëŸ¬ë¦¬
class AuthLibrary {
    fun isTokenValid(token: String): Boolean {
        return token == "secret"
    }
}

// Payment ì„œë¹„ìŠ¤ì—ì„œ ì‚¬ìš©
class PaymentService {
    private val authLibrary = AuthLibrary()
    
    fun processPayment(token: String, paymentData: PaymentData```Result {
        return if (authLibrary.isTokenValid(token)) {
            // ê²°ì œ ì²˜ë¦¬ ë¡œì§
            Result.success()
        } else {
            Result.unauthorized()
        }
    }
}

// Person ì„œë¹„ìŠ¤ì—ì„œ ì‚¬ìš©
class PersonService {
    private val authLibrary = AuthLibrary()
    
    fun getPerson(token: String, personId: String): Person? {
        return if (authLibrary.isTokenValid(token)) {
            // ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ ë¡œì§
            findPersonById(personId)
        } else {
            null
        }
    }
}
```

### ì£¼ìš” ê³ ë ¤ì‚¬í•­

**1. ì˜ì¡´ì„± ì¶©ëŒ ë¬¸ì œ**
```kotlin
// ë¬¸ì œ ìƒí™©: ë²„ì „ ì¶©ëŒ
// AuthLibraryê°€ Guava 27.0ì— ì˜ì¡´
// ThirdPartyLibraryê°€ Guava 28.0ì— ì˜ì¡´
// -> methodA()ê°€ 28.0ì—ì„œ ì œê±°ë˜ì–´ ëŸ°íƒ€ì„ ì˜¤ë¥˜ ë°œìƒ
```

**2. ê°œë°œ ê³¼ì • ì„¤ì •**
- ì½”ë”© ê´€ë¡€ ìˆ˜ë¦½
- ë°°í¬ í”„ë¡œì„¸ìŠ¤ êµ¬ì¶•  
- ë¬¸ì„œí™” ë° í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ ìœ ì§€
- ë¼ì´ë¸ŒëŸ¬ë¦¬ í™ë³´ ë° ì±„íƒ

### ğŸ’¡ ì €ìì˜ ì˜ê²¬
ë¼ì´ë¸ŒëŸ¬ë¦¬ ì ‘ê·¼ë²•ì€ ì½”ë“œ ì¤‘ë³µì„ í•´ê²°í•˜ì§€ë§Œ, ì˜ì¡´ì„± ê´€ë¦¬ì™€ ë²„ì „ í˜¸í™˜ì„± ë¬¸ì œë¥¼ ì‹ ì¤‘íˆ ê³ ë ¤í•´ì•¼ í•©ë‹ˆë‹¤.

## 2.3 ë…ë¦½ì ì¸ ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ë¡œ ì½”ë“œ ì¶”ì¶œ (í˜ì´ì§€ 27-34)

### ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì•„í‚¤í…ì²˜ ì ‘ê·¼ë²•

**TO-BE: ë…ë¦½ ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤**
```kotlin
// Authorization ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤
@RestController
@RequestMapping("/auth")
class AuthController {
    private val authService = AuthService()
    
    @GetMapping("/validate/{token}")
    fun validateToken(@PathVariable token: String): ResponseEntity<Void> {
        return if (authService.isTokenValid(token)) {
            ResponseEntity.ok().build()
        } else {
            ResponseEntity.status(HttpStatus.UNAUTHORIZED).build()
        }
    }
}

// HTTP í´ë¼ì´ì–¸íŠ¸ë¥¼ í†µí•œ ì¸ê°€ ì„œë¹„ìŠ¤ í˜¸ì¶œ
class AuthServiceClient {
    private val httpClient = HttpClient.newHttpClient()
    private val authServiceUrl = "http://auth```rvice"
    
    fun isTokenValid(token: String): Boolean {
        return try {
            val request = HttpRequest.newBuilder()
                .uri(URI.create("$authServiceUrl/auth/validate/$token"))
                .GET()
                .build()
                
            val response = httpClient.send(request, HttpResponse.BodyHandlers.ofString())
            response.statusCode() == 200
        } catch (e: Exception) {
            false
        }
    }
}

// Payment ì„œë¹„ìŠ¤ì—ì„œ ì‚¬ìš©
class PaymentController {
    private val authClient = AuthServiceClient()
    private val paymentService = PaymentService```    
    @PostMapping("/payment")
    fun createPayment(@RequestHeader("Authorization") token: String, 
                     @RequestBody payment: PaymentRequest```ResponseEntity<PaymentResponse> {
        return if (authClient.isTokenValid(token)) {
            val result = paymentService```ocessPayment(payment)
            ResponseEntity.ok(result)
        } else {
            ResponseEntity.status(HttpStatus.UNAUTHORIZED).build()
        }
    }
}
```

### 2.3.1 ë…ë¦½ì ì¸ ì„œë¹„ìŠ¤ì˜ íŠ¸ë ˆì´ë“œì˜¤í”„ì™€ ë‹¨ì  (í˜ì´ì§€ 30-33)

### ì£¼ìš” ê³ ë ¤ì‚¬í•­

**1. ë°°í¬ ê³¼ì •**
- í”„ë¡œì„¸ìŠ¤ ê°ì‹œ ë° ëª¨ë‹ˆí„°ë§ í•„ìš”
- ê²½ë³´ ì‹œìŠ¤í…œ ì„¤ì •
- ì¥ì•  ëŒ€ì‘ í”„ë¡œì„¸ìŠ¤

**2. ë²„ì „ ê´€ë¦¬**  
- API í•˜ìœ„ í˜¸í™˜ì„± ìœ ì§€
- ì—”ë“œí¬ì¸íŠ¸ ì‚¬ìš© í˜„í™© ëª¨ë‹ˆí„°ë§
- ì ì§„ì  ì§€ì› ì¤‘ë‹¨ ê°€ëŠ¥

**3. ìì› ì†Œë¹„**
- í´ë¼ì´ì–¸íŠ¸ ì¸¡ ì²˜ë¦¬ ë¶€í•˜ ê°ì†Œ
- ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì¸¡ í™•ì¥ í•„ìš”
- HTTP í˜¸ì¶œ ì˜¤ë²„í—¤ë“œ

**4. ì„±ëŠ¥ ê³ ë ¤ì‚¬í•­**
- ì¶”ê°€ HTTP ìš”ì²­ìœ¼ë¡œ ì¸í•œ ì§€ì—°ì‹œê°„
- SLA ì˜í–¥ ë¶„ì„ í•„ìš”
- ìºì‹± ì „ëµ êµ¬í˜„

### ì„±ëŠ¥ ìµœì í™” ì˜ˆì œ
```kotlin
// í† í° ìºì‹±ì„ í†µí•œ ì„±ëŠ¥ ìµœì í™”
class CachedAuthServiceClient {
    private val authClient = AuthServiceClient()
    private val tokenCache = ConcurrentHashMap<String, C```eEntry>()
    private val cacheExpirationMinutes = 5L
    
    data class CacheEntry(
        val isValid: Boolean,
        val timestamp: LocalDateTime
    )
    
    fun isTokenValid(token: String): Boolean {
        val cached = tokenCache[token]
        val now = LocalDateTime.now()
        
        // ìºì‹œê°€ ìˆê³  ë§Œë£Œë˜ì§€ ì•Šì•˜ìœ¼ë©´ ìºì‹œëœ ê°’ ë°˜```       if (cached != null && 
            Duration.between(cached.timestamp, now).toMinutes() < cacheExpirationMinutes) {
            return cached.isValid
        }
        
        // ìºì‹œê°€ ì—†ê±°ë‚˜ ë§Œë£Œë˜ì—ˆìœ¼ë©´ ì‹¤ì œ í˜¸ì¶œ
        val isValid = authClient.isTokenVali```oken)
        tokenCache[token] = CacheEntry(isValid, now)
        
        return isValid
    }
}
```

### ì¥ì•  ì²˜ë¦¬ ë° íšŒë¡œ ì°¨ë‹¨ê¸° íŒ¨í„´
```kotlin
// íšŒë¡œ ì°¨ë‹¨ê¸° íŒ¨í„´ êµ¬í˜„
class CircuitBreakerAuthClient {
    private val authClient = AuthServiceClient()
    private var circuitState = CircuitState.CLOSED```  private var failureCount = 0
    private var lastFailureTime = LocalDateTime.```()
    private val failureThreshold = 5
    private val timeoutMinutes = 1L
    
    enum class CircuitState { CLOSED, OPEN, HALF_OPEN }
    
    fun isTokenValid(token: String): Boolean {
        when (circuitState) {
            CircuitState.OPEN -> {
                if (Duration.between(lastFailureTime, LocalDateTime.now()).toMinutes() >= timeoutMinutes) {
                    circuitState = CircuitState.```F_OPEN
                } else {
                    // ê¸°ë³¸ê°’ ë°˜í™˜ ë˜ëŠ” ì˜ˆì™¸ ì²˜ë¦¬
                    return false
                }
            }
            CircuitState.HALF_OPEN -> {
                return try {
                    val result = authClient.isTokenVali```oken)
                    circuitState = CircuitState.CLOSED```                  failureCount = 0
                    result
                } catch (e: Exception) {
                    circuitState = CircuitState.OPEN```                  lastFailureTime = LocalDateTime.now```                    false
                }
            }
            CircuitState.CLOSED -> {
                return try {
                    authClient.isTokenValid(token)
                } catch (e: Exception) {
                    failureCount++
                    if (failureCount >= failureThreshold) {
                        circuitState```CircuitState.OPEN```                      lastFailureTime = Local```eTime.now()
                    }
                    false
                }
            }
        }
    }
}
```

### ğŸ’¡ ì €ìì˜ ì˜ê²¬
ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì ‘ê·¼ë²•ì€ ë” ë§ì€ ë³µì¡ì„±ì„ ê°€ì ¸ì˜¤ì§€ë§Œ, ë…ë¦½ì ì¸ í™•ì¥ê³¼ ë°°í¬ê°€ ê°€ëŠ¥í•œ ì¥ì ì´ ìˆìŠµë‹ˆë‹¤. ë‹¨ìˆœí•œ ë¡œì§ì˜ ê²½ìš° ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€, ë³µì¡í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ë„ë©”ì¸ì˜ ê²½ìš° ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ê°€ ì í•©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## í…ŒìŠ¤íŠ¸ ì½”ë“œ (Kotest)

```kotlin
import io.kotest.core.spec.style.BehaviorSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
import io.mockk.every
import io.mockk.mockk
import io.mockk.verify

class AuthServiceTest : BehaviorSpec({
    
    given("ê³µìœ  ë¼ì´ë¸ŒëŸ¬ë¦¬ ë°©ì‹ì˜ AuthService") {
        val authService = AuthLibrary()
        
        `when`("ìœ íš¨í•œ í† í°ìœ¼ë¡œ ê²€ì¦í•  ë•Œ") {
            val result = authService.isTokenValid("secret")
            
            then("trueë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤") {
                result shouldBe true
            }
        }
        
        `when`("ë¬´íš¨í•œ í† í°ìœ¼ë¡œ ê²€ì¦í•  ë•Œ") {
            val result = authService.```okenValid("invalid")
            
            then("falseë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤") {
                result shouldBe false
            }
        }
    }
    
    given("ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ë°©ì‹ì˜ AuthServiceClient") {
        val mockHttpClient = mockk<Auth```viceClient>()
        
        `when`("ì¸ì¦ ì„œë¹„ìŠ¤ê°€ ì •ìƒ ì‘ë‹µí•  ë•Œ") {
            every { mockHttpClient.isTokenValid("valid-token") } returns true
            
            val result = mockHttpClient```TokenValid("valid-token")
            
            then("trueë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤") {
                result shouldBe true
                verify { mockHttpClient.isTokenValid("valid-token") }
            }
        }
        
        `when`("ì¸ì¦ ì„œë¹„ìŠ¤ê°€ ì˜¤ë¥˜ ì‘ë‹µí•  ë•Œ") {
            every { mockHttpClient.isTokenValid("invalid-token") } returns false
            
            val result = mockHttpClient.isTokenVali```invalid-token")
            
            then("falseë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤") {
                result shouldBe false
            }
        }
    }
    
    given("ìºì‹± ê¸°ëŠ¥ì´ ìˆëŠ” AuthServiceClient") {
        val cachedAuthClient = CachedAuthServiceClient()
        
        `when`("ë™ì¼í•œ í† í°ìœ¼ë¡œ ì—°ì† í˜¸ì¶œí•  ë•Œ") {
            val firstResult = cachedAuthClient.is```enValid("test-token")
            val secondResult = cachedAuthClient.isToken```id("test-token")
            
            then("ìºì‹œëœ ê²°ê³¼ë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤") {
                firstResult shouldBe```condResult
            }
        }
    }
})
```

## ê´€ë ¨ ìë£Œ

### ì¶”ê°€ í•™ìŠµ ìë£Œ

1. **DRY ì›ì¹™ì˜ í•¨ì •** : [The Fallacy of DRY](https://dev.to/jeroendedauw/the-fallacy-of-dry)[1]
   - DRYë¥¼ ë§¹ëª©ì ìœ¼ë¡œ ë”°ë¥¼ ë•Œì˜ ìœ„í—˜ì„±ê³¼ ì ì ˆí•œ ì¤‘ë³µì˜ ê°€ì¹˜ì— ëŒ€í•´ ì„¤ëª…

2. **ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ vs ê³µìœ  ë¼ì´ë¸ŒëŸ¬ë¦¬** : [When to use shared libraries in Microservices](https://shekhargulati.com/2021/10/20/when-to-use-shared-libraries-in-microservices-architecture/)[2]
   - ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ì—ì„œ ê³µìœ  ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš© ì‹œì ê³¼ ê³ ë ¤ì‚¬í•­

3. **ì•”ë‹¬ì˜ ë²•ì¹™** : [Understanding Amdahl's Law](https://www.splunk.com/en_us/blog/learn/amdahls-law.html)[3]
   - ë³‘ë ¬ ì²˜ë¦¬ì˜ í•œê³„ì™€ ì„±ëŠ¥ ê°œì„  ê°€ëŠ¥ì„± ê³„ì‚°

## ìš”ì•½

### í•µì‹¬ ë‚´ìš©

1. **DRY vs ìœ ì—°ì„± íŠ¸ë ˆì´ë“œì˜¤í”„**
   - DRY ì›ì¹™ì„ ë§¹ëª©ì ìœ¼ë¡œ ë”°ë¥´ê¸°ë³´ë‹¤ ìƒí™©ì— ë§ëŠ” íŒë‹¨ í•„ìš”
   - ë¶„ì‚° ì‹œìŠ¤í…œì—ì„œëŠ” ì¤‘ë³µì´ ë” ë‚˜ì€ ì„ íƒì¼ ìˆ˜ ìˆìŒ

2. **ì½”ë“œ ê³µìœ  ë°©ë²•ë¡  ë¹„êµ**
   - **ì¤‘ë³µ í—ˆìš©**: íŒ€ ë…ë¦½ì„± ë³´ì¥, ë¹ ë¥¸ ê°œë°œ ì†ë„
   - **ê³µìœ  ë¼ì´ë¸ŒëŸ¬ë¦¬**: ì½”ë“œ ì¬ì‚¬ìš©, ì˜ì¡´ì„± ê´€ë¦¬ ë³µì¡ì„±
   - **ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤**: ë…ë¦½ ë°°í¬, ë†’ì€ ìš´ì˜ ë³µì¡ë„

3. **ì„ íƒ ê¸°ì¤€**
   - ë¡œì§ì˜ ë³µì¡ë„
   - íŒ€ ê°„ ì¡°ì • ë¹„ìš©
   - ì„±ëŠ¥ ìš”êµ¬ì‚¬í•­
   - ìš´ì˜ ë³µì¡ë„ ìˆ˜ìš© ê°€ëŠ¥ì„±

### ì‹¤ë¬´ ì ìš© ê°€ì´ë“œ

| ìƒí™© | ê¶Œì¥ ì ‘ê·¼ë²• | ì´ìœ  |
|------|------------|------|
| ë‹¨ìˆœí•œ ìœ í‹¸ë¦¬í‹° ë¡œì§ | ê³µìœ  ë¼ì´ë¸ŒëŸ¬ë¦¬ | ë‚®ì€ ë³€ê²½ ë¹ˆë„, ì¬ì‚¬ìš©ì„± ë†’ìŒ |
| ë³µì¡í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ | ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ | ë…ë¦½ì  ì§„í™” í•„ìš” |
| ì´ˆê¸° ê°œë°œ ë‹¨ê³„ | ì¤‘ë³µ í—ˆìš© | ë¹ ë¥¸ ì‹¤í—˜ê³¼ ê²€ì¦ |
| ë³´ì•ˆ ê´€ë ¨ ë¡œì§ | ê³µìœ  ë¼ì´ë¸ŒëŸ¬ë¦¬/ì„œë¹„ìŠ¤ | ì¼ê´€ì„±ê³¼ ì „ë¬¸ì„± í•„ìš” |

### ğŸ’¡ ìµœì¢… ì˜ê²¬
ì½”ë“œ ì¤‘ë³µì€ í•­ìƒ ë‚˜ìœ ê²ƒì´ ì•„ë‹ˆë‹¤. íŠ¹íˆ ë¶„ì‚° ì‹œìŠ¤í…œì—ì„œëŠ” ì ì ˆí•œ ì¤‘ë³µì´ ì‹œìŠ¤í…œì˜ ìœ ì—°ì„±ê³¼ íŒ€ì˜ ììœ¨ì„±ì„ ë³´ì¥í•  ìˆ˜ ìˆë‹¤. ì¤‘ìš”í•œ ê²ƒì€ ê° ì ‘ê·¼ë²•ì˜ íŠ¸ë ˆì´ë“œì˜¤í”„ë¥¼ ì´í•´í•˜ê³  ìƒí™©ì— ë§ëŠ” ìµœì ì˜ ì„ íƒì„ í•˜ëŠ” ê²ƒì´ë‹¤.

[1](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/32004849/0d76a881-5369-4015-9ac8-6fe8e6f73230/2504-ipegtibeu-sopeuteuweeo-seolgye-pages-44-61.pdf)
[2](https://dev.to/jeroendedauw/the-fallacy-of-dry)
[3](https://shekhargulati.com/2021/10/20/when-to-use-shared-libraries-in-microservices-architecture/)
[4](http://jeremymikkola.com/posts/2021_01_01_why_software_development_is_hard.html)
[5](https://en.wikipedia.org/wiki/Don't_repeat_yourself)
[6](https://dev.to/thesimdak/shared-library-for-micro-services-why-should-you-have-one-2jod)
[7](https://www.splunk.com/en_us/blog/learn/amdahls-law.html)
[8](https://stackoverflow.com/questions/17788738/is-violation-of-dry-principle-always-bad)
[9](https://www.reddit.com/r/softwarearchitecture/comments/16k76tj/microservice_architecture_shared_lib_vs_dedicated/)
[10](https://deviq.com/laws/amdahls-law/)
[11](https://thevaluable.dev/dry-principle-cost-benefit-example/)
[12](https://stackoverflow.com/questions/57240638/shared-library-vs-microservice)
[13](https://dev.to/luminousmen/understanding-concurrency-through-amdahls-law-1ah4)
[14](https://www.infoq.com/news/2014/09/microservices-shared-libraries/)
[15](https://www.grahamlea.com/2016/04/shared-libraries-in-microservices-bad-advice/)
[16](https://ppl-ai-code-interpreter-files.s3.amazonaws.com/web/direct-files/e24357432d6004bc7d2f4810934ed222/c57e9fc7-f9e0-4e3e-aa5d-ae87796c21a9/fa04ef2f.md)