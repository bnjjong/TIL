# 1장 요약 (p.27–43)

## 1.0 도입: “트레이드오프를 의식적으로 선택하라”  <!-- p.27–29 -->

* 소프트웨어 설계는 항상 상호 제약을 동반한다. 시간이 지날수록 초기 결정의 되돌리기 비용은 커진다. 따라서 **의식적인 선택과 맥락(컨텍스트)** 이 중요하다.&#x20;
* 1부는 코드·API 수준의 저수준 설계, 2부는 컴포넌트/데이터 흐름 등 고수준 아키텍처를 다룬다. 특히 **테스트 전략**(단위·통합·E2E), **싱글턴**, **모놀리스 vs 마이크로서비스** 같은 대표적 트레이드오프를 비교한다.&#x20;

## 1.1 모든 결정과 패턴의 결과  <!-- p.29–33 -->

* **단위 테스트 vs 통합 테스트** 비율은 현실 제약(시간·SLA)에 따라 달라진다. 단위 테스트는 빠른 피드백과 디버깅에 유리하지만, 시스템 레벨 상호작용은 **통합/E2E** 가 보장한다. 따라서 **혼합 전략**이 필요하다. (책에 피드백 속도 관점 피라미드/다차원 비교 도식)&#x20;
* private 메서드 테스트를 위해 가시성 완화(예: `@VisibleForTesting` 수준 공개, 패키지 프라이빗)도 선택지이나, API 오남용 위험/유지보수 비용을 수반한다.&#x20;

## 1.2 코드 디자인 패턴(싱글턴)과 “항상 통하지 않는 이유”  <!-- p.33–39 -->

* 전형적 싱글턴 구현은 멀티스레드에서 **경쟁 상태**로 두 인스턴스가 생길 수 있다 → 동기화(synchronized)로 막으면 안전하지만 **성능 저하**(락 경합).&#x20;
* 개선 패턴:

  * **DCL(Double-Checked Locking)** + `volatile`로 초기화 시점만 동기화하여 경합 감소. 벤치마크에서 동기화 방식 대비 큰 개선.&#x20;
  * **스레드 한정(ThreadLocal)** 으로 공유 자체를 없애 경합 제거(대신 복잡성/수명관리 주의). `withInitial`을 쓰면 null 안전성 향상.&#x20;
* 결론: **컨텍스트(동시성, 성능 우선순위, DI 채택 여부)** 에 따라 패턴 선택이 달라진다. 경우에 따라 DI로 애초에 싱글턴 패턴 자체가 불필요할 수 있다.&#x20;

## 1.3 아키텍처 패턴도 “항상 통하지 않는다” (모놀리스 vs 마이크로서비스)  <!-- p.39–43 -->

* **마이크로서비스 장점**: 수평 확장 용이(인스턴스 증설), 팀 분리·독립 배포로 개발 속도/리스크 저감. 단, 서비스 레지스트리/로드밸런서/상태 점검 등 **운영 복잡성 비용**이 큼.&#x20;
* **모놀리스 장점**: 단순한 배포/운영, 작은 팀·확장성 요구가 낮은 상황에 적합. 단, 대규모 조직/빈번한 변경에는 충돌·릴리스 부담 증가. **컨텍스트에 따라 혼합 접근**도 현실적.&#x20;

---

## 핵심 도표(직접 작성)

### 테스트 유형별 특성 요약  <!-- p.29–33 기반 -->

| 구분              | 범위/목적      | 속도/피드백 | 작성 난이도 | 장점            | 단점            |   |
| --------------- | ---------- | ------ | ------ | ------------- | ------------- | - |
| 단위(Unit)        | 메서드/클래스    | 매우 빠름  | 낮음     | 빠른 회귀, 디버깅 용이 | 상호작용/구성 검증 불가 |   |
| 통합(Integration) | 컴포넌트 간     | 보통     | 중간     | 연결부/구성 검증     | 인프라 의존, 속도↓   |   |
| E2E             | 비즈니스 흐름 전체 | 느림     | 높음     | 실제 시나리오 확신    | 환경 구성/유지 비용↑  |   |

### 아키텍처 비교(요지)  <!-- p.39–43 기반 -->

| 항목      | 모놀리스           | 마이크로서비스                |   |
| ------- | -------------- | ---------------------- | - |
| 확장      | 주로 수직          | 수평(인스턴스 증설) 용이         |   |
| 배포      | 일괄/덩어리         | 독립 배포/릴리스 위험 분산        |   |
| 복잡도(운영) | 낮음             | 서비스 레지스트리/트래픽 라우팅 등 높음 |   |
| 팀 조직    | 공유 리포지토리 충돌 가능 | 도메인별 자율성↑              |   |

---

# 제 코멘트(짧게)

* **테스트 비율**: 광고/오퍼월처럼 외부 시스템(결제, 파트너 API) 연동이 많은 도메인은 **통합/E2E의 최소 골격**(행복 경로 + 실패 1\~2 케이스)을 먼저 박고, 내부 계산 로직은 **단위 테스트를 광범위하게** 가져가는 구성이 현실적.
* **싱글턴**: “전역 접근 편의”보다 “의존성 주입/불변 구성”이 장기 유지보수에 유리합니다. 캐시·레이트리미터 같은 상태 공유는 DCL 또는 ThreadLocal보다 **Spring 빈 + 구성형 전략**이 보수적 선택.
* **아키텍처**: 새로운 광고 플랫폼은 **Monolith-first + 잘게 나눈 모듈화**로 시작해 “변화가 잦은 경계”를 우선 마이크로서비스로 분리하는 하이브리드가 안전합니다.

---

# Kotlin 예제 (광고/오퍼월 도메인)

## 시나리오

* 캠페인 노출 시 **RateLimiter(초당 N회)** 를 전역 싱글턴으로 두면 경합/성능 이슈가 발생.
* **AS-IS**: 전역 동기화 싱글턴.
* **TO-BE**: Spring DI 싱글턴 빈(+ 환경설정으로 동시성 제어)으로 대체하고, **테스트 전략**을 단위/통합으로 분리.

### AS-IS (문제 있는 전역 싱글턴)

```kotlin
// p.33–37 싱글턴 트레이드오프 참고
object GlobalRateLimiter {
    // 단순화한 토큰 버킷
    @Volatile private var tokens: Int = 10
    private val lock = Any()

    fun tryAcquire(): Boolean {
        synchronized(lock) { // 락 경합 → 다중 코어에서 병목
            return if (tokens > 0) { tokens--; true } else false
        }
    }

    // 타이머 스레드가 주기적으로 리필한다고 가정
    fun refill(n: Int) { synchronized(lock) { tokens = (tokens + n).coerceAtMost(10) } }
}
```

### TO-BE (DI 기반 구성형, 동시성 제어를 전략으로 분리)

```kotlin
// 도메인: 오퍼월 클릭 승인 서비스
data class CampaignId(val value: String)
data class UserId(val value: String)

interface RateLimiter {
    fun tryAcquire(key: String): Boolean
}

class TokenBucketLimiter(
    private val capacity: Int,
    private val refillPerSec: Int
) : RateLimiter {
    // key(캠페인/유저)별로 독립 버킷 운영 → 공유경합 감소
    private val buckets = java.util.concurrent.ConcurrentHashMap<String, java.util.concurrent.atomic.AtomicInteger>()

    override fun tryAcquire(key: String): Boolean {
        val bucket = buckets.computeIfAbsent(key) { java.util.concurrent.atomic.AtomicInteger(capacity) }
        val current = bucket.get()
        return if (current > 0 && bucket.compareAndSet(current, current - 1)) true else false
    }

    fun refillAll() {
        buckets.forEach { (_, v) ->
            while (true) {
                val cur = v.get()
                val next = (cur + refillPerSec).coerceAtMost(capacity)
                if (v.compareAndSet(cur, next)) break
            }
        }
    }
}

class OfferwallClickService(private val limiter: RateLimiter) {
    /**
     * 오퍼월 클릭 승인. key는 (캠페인+유저) 조합 등으로 설계.
     */
    fun approveClick(campaignId: CampaignId, userId: UserId): Boolean {
        val key = "${campaignId.value}:${userId.value}"
        return limiter.tryAcquire(key)
    }
}
```

### 단위 테스트 (Kotest) — 빠른 피드백

```kotlin
import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.shouldBe

class OfferwallClickServiceTest : StringSpec({
    "리미터 토큰이 남아있다면 승인된다" {
        val limiter = TokenBucketLimiter(capacity = 2, refillPerSec = 0)
        val svc = OfferwallClickService(limiter)

        svc.approveClick(CampaignId("C1"), UserId("U1")) shouldBe true
        svc.approveClick(CampaignId("C1"), UserId("U1")) shouldBe true
        svc.approveClick(CampaignId("C1"), UserId("U1")) shouldBe false
    }
})
```

### 통합 테스트 스케치 — 실제 구성요소 연결 확인(느리지만 신뢰↑)

```kotlin
// 예: SpringBootTest로 Redis 기반 RateLimiter, JPA 저장소 등을 붙여
// 클릭 승인 → 이벤트 큐 적재 → 비동기 처리 까지 "행복 경로"만 검증.
// (실제 환경에 맞게 구성 파일/컨테이너 필요)
```

> 포인트: **AS-IS 전역 싱글턴**은 락 경합으로 스루풋이 급감할 수 있습니다(책의 동기화 vs DCL vs ThreadLocal 벤치마크 비교와 맥락 동일). **TO-BE DI 싱글턴 빈 + 키별 분산 버킷**으로 공유 자원 경합을 줄이고, 단위/통합 테스트를 **목적별로 분리**합니다.&#x20;

---

# 외부 참고 자료 (짧은 정리 + 출처)

* **테스트 피라미드**: 하위(단위) 많고 상위(E2E) 적게—빠른 피드백과 비용 균형을 잡기 위한 메타포. 실제로는 “서비스/통합 테스트” 층을 적절히 두껍게 하라는 실천론이 중요. ([martinfowler.com][1], [Ministry of Testing][2])
* **DCL와 `volatile`**: JSR-133 이후 `volatile`을 동반한 DCL은 안전. 목적은 **락 획득 비용 최소화**이며, 오용 시 반초기화 관측 위험. ([UMD 컴퓨터 과학부][3], [Baeldung on Kotlin][4], [PVS-Studio][5])
* **ThreadLocal**: 공유 제거를 통해 동기화 없이 스레드별 상태 유지. 세션/트랜잭션 컨텍스트에 유용하나 누수 주의(`remove`). ([Oracle Docs][6], [Baeldung on Kotlin][7], [codefarm0.medium.com][8])
* **모놀리스 vs 마이크로서비스 & Monolith-first**: 작은 팀·초기 단계는 모놀리스로 시작해, 변화가 잦은 경계를 우선 분리하는 접근을 권장. ([martinfowler.com][9])
* **서비스 레지스트리**: 동적 확장 환경에서 인스턴스 등록/조회/상태 점검의 중심 구성요소. ([microservices.io][10], [GeeksforGeeks][11])

---

# 최종 압축 요약

* **핵심 메시지**: 설계는 항상 트레이드오프. 테스트(단위·통합·E2E) 비율, 싱글턴의 동시성/성능, 모놀리스 vs 마이크로서비스의 개발속도/운영복잡도—모두 **맥락에 따른 의식적 선택**이 필요.&#x20;
* **실무 가이드**:

  1. 외부 연동 많은 도메인은 **단위 多 + 최소 통합/E2E 골격**.
  2. 전역 싱글턴보다 **DI/구성형**으로 공유 축소. 필요 시 DCL·ThreadLocal 선택하되 **측정**으로 검증.
  3. **Monolith-first → 점진적 분리**가 위험을 낮춘다.&#x20;

---



### 주석

* (p.xx–yy) 표기는 업로드 문서의 실제 페이지 범위를 가리킵니다(1장 27–43쪽). 세부 인용은 본문 각 절 설명과 표에 반영했습니다.&#x20;



[1]: https://martinfowler.com/articles/practical-test-pyramid.html?utm_source=chatgpt.com "The Practical Test Pyramid"
[2]: https://www.ministryoftesting.com/software-testing-glossary/the-test-pyramid?utm_source=chatgpt.com "The Test Pyramid"
[3]: https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html?utm_source=chatgpt.com "The \"Double-Checked Locking is Broken\" Declaration"
[4]: https://www.baeldung.com/java-singleton-double-checked-locking?utm_source=chatgpt.com "Double-Checked Locking with Singleton"
[5]: https://pvs-studio.com/en/blog/posts/java/1128/?utm_source=chatgpt.com "Volatile, DCL, and synchronization pitfalls in Java"
[6]: https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html?utm_source=chatgpt.com "ThreadLocal (Java Platform SE 8 )"
[7]: https://www.baeldung.com/java-threadlocal?utm_source=chatgpt.com "An Introduction to ThreadLocal in Java"
[8]: https://codefarm0.medium.com/deep-dive-how-threadlocal-works-in-java-a8a6bab3785c?utm_source=chatgpt.com "Deep Dive: How ThreadLocal Works in Java | by Arvind Kumar"
[9]: https://martinfowler.com/articles/microservices.html?utm_source=chatgpt.com "Microservices"
[10]: https://microservices.io/patterns/service-registry.html?utm_source=chatgpt.com "Pattern: Service registry"
[11]: https://www.geeksforgeeks.org/system-design/what-is-service-registry-in-microservices/?utm_source=chatgpt.com "What is Service Registry in Microservices?"
