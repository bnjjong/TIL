# 7장 7.2 날짜와 시간 데이터로 효율적으로 작업하기

## 7.2.1 범위 제한하기

### 핵심 내용

날짜와 시간 정보의 세계는 매우 복잡하지만, 대부분의 애플리케이션에서는 모든 복잡한 정보가 필요하지 않다. 따라서 작업 범위를 명시적으로 제한하고 결정 사항을 문서화하는 것이 중요하다.[1]

**가장 복잡한 측면들을 배제하는 질문들:**
- 애플리케이션이 상대성을 다룰 필요가 있는가?
    > 상대성을 다룰 필요가 어디에 있을까? 예를 들어, 항공편 예약 시스템에서는 사용자의 위치에 따라 시간이 다르게 해석될 수 있다. 하지만 단순한 일정 관리 애플리케이션에서는 상대성을 고려할 필요가 없다.
- 윤초를 인지하고 처리할 필요가 있는가?
    > 윤초는 매우 드물게 발생하며, 대부분의 비즈니스 애플리케이션에서는 무시해도 큰 문제가 없다. 하지만 금융 거래 시스템이나 천문학적 계산이 필요한 경우에는 윤초를 고려해야 한다.
- 과거 달력 시스템 변경과 관련된 먼 날짜를 다룰 필요가 있는가?

[**달력 시스템과 시간대 관련 고려사항:**](https://www.perplexity.ai/search/7jang-7-2-caebteowa-geu-hawica-iGn7XgPNS_O01IkrKHoatQ#1)
- 그레고리력 이외의 다른 달력 시스템이 필요한가?
- 시간대 지원이 필요한가?
- 사용자의 시간대 선택을 허용할 것인가?
- 여러 시간대에서 동작해야 하는가?
- 시간대 규칙을 최신 상태로 유지해야 하는가?

### 개인적 견해
복잡성을 미리 제한하는 것은 매우 현명한 접근법이다. 개발 초기에 이런 가정들을 명확히 하고 문서화하면, 나중에 요구사항이 변경될 때 어떤 부분을 수정해야 하는지 쉽게 파악할 수 있다.

## 7.2.2 날짜와 시간 요구사항을 명확하게 만들기

### 핵심 내용

날짜와 시간 관련 요구사항을 명확하게 만드는 것은 인기 있는 일이 아니지만 반드시 필요하다. "당연한 것"이라고 여겨지는 것도 사람마다 다르게 해석될 수 있기 때문이다.[1]

**온라인 쇼핑 반품 시나리오 예시:**
"고객은 세 달 안에 반품할 수 있다"라는 요구사항을 명확하게 만들기 위해 다음 사항들을 결정해야 한다:

1. **올바른 개념 또는 데이터 유형 선택하기**
    - 데이터 출처 고려 (사용자 제공 vs 시스템 생성)
    - 인스턴트 vs 지역 시간의 선택
    - 시간대 정보 보존 여부

2. **동작 방식에 대해 질문하기**
    - 세 달의 기준점: 결제, 주문 확정, 배송 등 중 어느 시점인가?
    - 어떤 시간대를 기준으로 할 것인가?
    - 달력 산술 연산의 처리 방식

**구체화된 요구사항 예시:**[1]
```
품목 반품 옵션은 배송 주소의 시간대로 품목이 배송된 날짜에 기반한다. 
반품이 유효한 마지막 날짜는 품목이 배송될 때 배송지 주소의 현재 날짜에 
3개월을 더하는 식으로 계산된다. 배송 날짜에 3개월을 더한 결과 해당 월말을 
지나치면 다음 월초를 사용한다.
```

### 개인적 견해
요구사항을 이렇게 구체적으로 명시하는 것이 처음에는 번거로워 보이지만, 실제로는 개발 시간을 크게 단축시킨다. 애매한 요구사항으로 인한 재작업이나 버그 수정에 들어가는 비용을 생각하면 충분히 가치 있는 투자다.

## 7.2.3 올바른 라이브러리 또는 패키지 사용하기

### 핵심 내용

적절한 날짜와 시간 라이브러리를 선택하는 것이 중요하다. 시간이 지남에 따라 기술 생태계가 변화하므로 최신 동향을 파악해야 한다.[1]

**플랫폼별 권장사항:**

| 플랫폼 | 권장 라이브러리 | 특징 |
|--------|-----------------|------|
| Java | java.time 패키지 (Java 8+) | 불변 타입, 개념 분리 |
| Java (레거시) | ThreeTen-Backport | java.time 백포팅 |
| .NET | Noda Time | 개념 분리, 타입 안정성 |

**라이브러리 평가 기준:**[1]
- 그레고리력 이외의 달력 시스템 지원
- 시간대 데이터에 대한 충분한 통제력
- 요구사항의 모든 개념 지원
- 불변 타입 제공
- 외부 의존성과의 호환성

### 개인적 견해
Java 진영에서는 java.time 패키지가 정말 잘 설계되어 있다고 생각한다. LocalDate, LocalDateTime, ZonedDateTime 등으로 개념을 명확히 분리한 것이 인상적이다. Kotlin에서도 kotlinx-datetime을 고려할 수 있지만, JVM 환경에서는 java.time이 여전히 강력한 선택이다.[2]

---

## Kotlin 예제 코드

### As-Is: 문제가 있는 날짜/시간 처리

```kotlin
// ❌ 문제가 있는 반품 정책 구현
data class Order(
    val id: String,
    val customerId: String,
    // Date 사용으로 시간대 정보 손실
    val orderDate: Date,
    val shippedDate: Date?,
    val items: List<OrderItem>
)

data class OrderItem(
    val productId: String,
    val name: String,
    val quantity: Int,
    val price: BigDecimal
)

class ReturnPolicyService {
    // 하드코딩된 반품 기간, 시간대 미고려
    private val returnPeriodMonths = 3L
    
    fun canReturn(order: Order): Boolean {
        // 배송일이 없으면 반품 불가 (너무 단순함)
        val shippedDate = order.shippedDate ?: return false
        
        // 현재 시간과 비교하지만 시간대 고려 안함
        val cutoffDate = Date(shippedDate.time)
        val calendar = Calendar.getInstance().apply {
            time = cutoffDate
            add(Calendar.MONTH, returnPeriodMonths.toInt())
        }
        
        // 단순히 현재 시간과 비교 (고객의 시간대 미고려)
        return Date().before(calendar.time)
    }
}
```

### To-Be: 개선된 날짜/시간 처리

```kotlin
import java.time.*
import java.time.format.DateTimeFormatter

// ✅ 개선된 주문 도메인 모델
data class Order(
    val id: OrderId,
    val customerId: CustomerId,
    // Instant로 정확한 시점 저장
    val orderTimestamp: Instant,
    val shippingInfo: ShippingInfo?,
    val items: List<OrderItem>
) {
    companion object {
        fun create(
            id: OrderId,
            customerId: CustomerId,
            items: List<OrderItem>,
            now: Instant = Instant.now()
        ): Order {
            return Order(
                id = id,
                customerId = customerId,
                orderTimestamp = now,
                shippingInfo = null,
                items = items
            )
        }
    }
    
    // 배송 정보 설정 (불변성 유지)
    fun markAsShipped(shippingInfo: ShippingInfo): Order {
        return copy(shippingInfo = shippingInfo)
    }
}

// 배송 정보 - 시간대와 주소 정보 포함
data class ShippingInfo(
    val shippedAt: Instant,           // 배송된 정확한 시점
    val deliveryAddress: Address,     // 배송 주소
    val timeZone: ZoneId              // 배송지 시간대
)

data class Address(
    val street: String,
    val city: String,
    val country: String,
    val postalCode: String
)

// 값 객체들
@JvmInline
value class OrderId(val value: String)

@JvmInline 
value class CustomerId(val value: String)

data class OrderItem(
    val productId: String,
    val name: String,
    val quantity: Int,
    val price: BigDecimal
)

// ✅ 명확한 요구사항을 반영한 반품 정책 서비스
class ReturnPolicyService(
    private val returnPolicyConfig: ReturnPolicyConfig = ReturnPolicyConfig()
) {
    
    /**
     * 고객이 주문 항목을 반품할 수 있는지 확인
     * 
     * 비즈니스 규칙:
     * 1. 배송된 날짜 기준으로 3개월 이내
     * 2. 배송지 시간대 기준으로 계산
     * 3. 월말을 넘어가면 다음 달 첫날로 연장
     */
    fun canReturn(order: Order, checkTime: Instant = Instant.now()): ReturnEligibility {
        val shippingInfo = order.shippingInfo 
            ?: return ReturnEligibility.notShipped("주문이 아직 배송되지 않았습니다")
        
        // 배송지 시간대로 배송일 계산
        val shippedLocalDate = shippingInfo.shippedAt
            .atZone(shippingInfo.timeZone)
            .toLocalDate()
        
        // 반품 마감일 계산 (배송일 + 3개월)
        val returnDeadline = calculateReturnDeadline(
            shippedDate = shippedLocalDate,
            returnPeriodMonths = returnPolicyConfig.returnPeriodMonths
        )
        
        // 현재 날짜를 배송지 시간대로 변환
        val currentLocalDate = checkTime
            .atZone(shippingInfo.timeZone)
            .toLocalDate()
        
        return if (currentLocalDate.isAfter(returnDeadline)) {
            ReturnEligibility.expired(
                deadline = returnDeadline,
                message = "반품 기간이 만료되었습니다 (마감일: ${returnDeadline.format(DateTimeFormatter.ISO_LOCAL_DATE)})"
            )
        } else {
            ReturnEligibility.eligible(
                deadline = returnDeadline,
                remainingDays = ChronoUnit.DAYS.between(currentLocalDate, returnDeadline)
            )
        }
    }
    
    /**
     * 반품 마감일 계산
     * 배송일에 지정된 개월 수를 더하되, 월말을 넘어가면 다음 달 첫날로 조정
     */
    private fun calculateReturnDeadline(
        shippedDate: LocalDate,
        returnPeriodMonths: Long
    ): LocalDate {
        val tentativeDeadline = shippedDate.plusMonths(returnPeriodMonths)
        
        // 원래 배송일의 일(day)이 마감월의 마지막 날보다 크면 다음 달 첫날로 조정
        val lastDayOfDeadlineMonth = tentativeDeadline.withDayOfMonth(
            tentativeDeadline.lengthOfMonth()
        )
        
        return if (shippedDate.dayOfMonth > lastDayOfDeadlineMonth.dayOfMonth) {
            tentativeDeadline.withDayOfMonth(1).plusMonths(1)
        } else {
            tentativeDeadline
        }
    }
}

// 반품 가능 여부를 나타내는 도메인 객체
sealed class ReturnEligibility {
    data class Eligible(
        val deadline: LocalDate,
        val remainingDays: Long,
        val message: String = "반품 가능"
    ) : ReturnEligibility()
    
    data class Expired(
        val deadline: LocalDate,
        val message: String
    ) : ReturnEligibility()
    
    data class NotShipped(
        val message: String
    ) : ReturnEligibility()
    
    companion object {
        fun eligible(deadline: LocalDate, remainingDays: Long) = 
            Eligible(deadline, remainingDays)
        
        fun expired(deadline: LocalDate, message: String) = 
            Expired(deadline, message)
        
        fun notShipped(message: String) = 
            NotShipped(message)
    }
    
    val isEligible: Boolean
        get() = this is Eligible
}

// 설정 객체
data class ReturnPolicyConfig(
    val returnPeriodMonths: Long = 3,
    val gracePeriodMinutes: Long = 5,  // 유예 시간 (분)
    val formTimeoutHours: Long = 2     // 폼 작성 제한 시간
)
```

### 테스트 코드 (Kotest)

```kotlin
import io.kotest.core.spec.style.BehaviorSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.types.shouldBeInstanceOf
import java.math.BigDecimal
import java.time.*

class ReturnPolicyServiceTest : BehaviorSpec({
    
    given("반품 정책 서비스") {
        val service = ReturnPolicyService()
        val koreaTimeZone = ZoneId.of("Asia/Seoul")
        val customerId = CustomerId("customer-123")
        
        `when`("3개월 이내에 배송된 주문이 있을 때") {
            val now = Instant.parse("2024-01-15T10:00:00Z")
            val shippedDate = Instant.parse("2023-11-15T05:00:00Z") // 2개월 전
            
            val order = createTestOrder(customerId, shippedDate, koreaTimeZone)
            val result = service.canReturn(order, now)
            
            then("반품 가능해야 한다") {
                result.isEligible shouldBe true
                result.shouldBeInstanceOf<ReturnEligibility.Eligible>()
            }
        }
        
        `when`("3개월이 지난 후에 확인할 때") {
            val now = Instant.parse("2024-03-16T10:00:00Z")
            val shippedDate = Instant.parse("2023-11-15T05:00:00Z") // 4개월 전
            
            val order = createTestOrder(customerId, shippedDate, koreaTimeZone)
            val result = service.canReturn(order, now)
            
            then("반품 불가능해야 한다") {
                result.isEligible shouldBe false
                result.shouldBeInstanceOf<ReturnEligibility.Expired>()
            }
        }
        
        `when`("월말에 배송되어 다음달로 연장되는 경우") {
            // 11월 30일에 배송 -> 3개월 후는 3월 1일이 되어야 함
            val shippedDate = Instant.parse("2023-11-30T05:00:00Z")
            val checkDate = Instant.parse("2024-02-29T10:00:00Z") // 2월 29일 (윤년)
            
            val order = createTestOrder(customerId, shippedDate, koreaTimeZone)
            val result = service.canReturn(order, checkDate)
            
            then("아직 반품 가능해야 한다") {
                result.isEligible shouldBe true
                result.shouldBeInstanceOf<ReturnEligibility.Eligible>()
            }
        }
        
        `when`("아직 배송되지 않은 주문일 때") {
            val order = Order.create(
                id = OrderId("order-123"),
                customerId = customerId,
                items = listOf(createTestOrderItem())
            )
            
            val result = service.canReturn(order)
            
            then("배송되지 않음으로 처리되어야 한다") {
                result.isEligible shouldBe false
                result.shouldBeInstanceOf<ReturnEligibility.NotShipped>()
            }
        }
        
        `when`("서로 다른 시간대에서 테스트할 때") {
            val utcTimeZone = ZoneId.of("UTC")
            val nyTimeZone = ZoneId.of("America/New_York")
            
            // 같은 Instant이지만 다른 시간대
            val shippedInstant = Instant.parse("2023-11-15T13:00:00Z")
            val checkInstant = Instant.parse("2024-02-14T13:00:00Z")
            
            val orderInKorea = createTestOrder(customerId, shippedInstant, koreaTimeZone)
            val orderInNY = createTestOrder(customerId, shippedInstant, nyTimeZone)
            
            val resultKorea = service.canReturn(orderInKorea, checkInstant)
            val resultNY = service.canReturn(orderInNY, checkInstant)
            
            then("동일한 결과를 반환해야 한다") {
                resultKorea.isEligible shouldBe resultNY.isEligible
                resultKorea.shouldBeInstanceOf<ReturnEligibility.Eligible>()
                resultNY.shouldBeInstanceOf<ReturnEligibility.Eligible>()
            }
        }
    }
})

// 테스트 헬퍼 함수들
private fun createTestOrder(
    customerId: CustomerId,
    shippedAt: Instant,
    timeZone: ZoneId
): Order {
    return Order.create(
        id = OrderId("order-123"),
        customerId = customerId,
        items = listOf(createTestOrderItem())
    ).markAsShipped(
        ShippingInfo(
            shippedAt = shippedAt,
            deliveryAddress = Address(
                street = "123 Test St",
                city = "Seoul",
                country = "KR",
                postalCode = "12345"
            ),
            timeZone = timeZone
        )
    )
}

private fun createTestOrderItem(): OrderItem {
    return OrderItem(
        productId = "product-123",
        name = "테스트 상품",
        quantity = 1,
        price = BigDecimal("29.99")
    )
}
```

## 관련 자료

- [Java time 패키지 - LocalDate, LocalTime, Instant] - Java 8의 java.time 패키지에 대한 상세한 설명[3]
- [Kotlin 날짜와 시간 클래스] - Kotlin에서 날짜와 시간을 다루는 방법[2]
- [Domain model purity and the current time] - 도메인 모델에서 시간을 다루는 베스트 프랙티스[4]

## 요약

7.2장에서는 날짜와 시간 데이터를 효율적으로 처리하기 위한 체계적인 접근법을 제시한다:

1. **범위 제한**: 복잡한 요구사항(상대성, 윤초, 다양한 달력 시스템)을 미리 배제하고 필요한 기능만 구현
2. **요구사항 명확화**: 애매한 날짜/시간 요구사항을 구체적이고 테스트 가능한 형태로 변환
3. **적절한 라이브러리 선택**: Java의 경우 java.time 패키지, .NET의 경우 Noda Time 사용 권장

핵심은 **명확한 요구사항 정의**와 **적절한 도구 선택**이다. 날짜와 시간은 복잡한 도메인이지만, 체계적으로 접근하면 견고하고 이해하기 쉬운 코드를 작성할 수 있다.

***


[1](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/32004849/544c0dc8-4e54-4e9b-9293-ccedd75ee4f7/2504-ipegtibeu-sopeuteuweeo-seolgye-pages-227-236.pdf)
[2](https://jinudmjournal.tistory.com/216)
[3](https://0soo.tistory.com/109)
[4](https://enterprisecraftsmanship.com/posts/domain-model-purity-current-time/)
[5](https://product.kyobobook.co.kr/detail/S000215851706)
[6](https://youngwon.io/study/software-mistakes-and-tradeoffs)
[7](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=361686658)
[8](https://www.youtube.com/watch?v=9qGhNPLvzKA)
[9](https://always-regret.tistory.com/24)
[10](https://kr.linkedin.com/pulse/%EB%8F%84%EB%A9%94%EC%9D%B8-%EB%AA%A8%EB%8D%B8-%EA%B3%BC%EA%B1%B0-%ED%98%84%EC%9E%AC-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EB%AF%B8%EB%9E%98-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%95%88%EB%82%B4%EC%84%9C-toby-lee-zhu0e)
[11](https://www.slideshare.net/slideshow/ss-8149/276656907)
[12](https://zzang9ha.tistory.com/478)
[13](https://jeongjaino.tistory.com/59)
[14](https://www.reddit.com/r/csharp/comments/wwri6q/is_datetimeoffsetnow_good_enough_for_database/)
[15](https://ridibooks.com/books/1160000201)
[16](https://qwebnm7788.tistory.com/7)
[17](https://www.servicenow.com/docs/ko-KR/bundle/washingtondc-it-service-management/page/product/change-management/concept/c_ITILChangeManagement.html)
[18](https://devlemon.tistory.com/25)
[19](https://techdocs.broadcom.com/kr/ko/symantec-security-software/endpoint-security-and-management/endpoint-protection/all/Using-policies-to-manage-security/about-application-control-system-lockdown-and-devi-v36534292-d45e176/adding-custom-rules-to-application-control-v36657576-d45e836/best-practices-for-adding-application-control-rule-v36535321-d45e492.html)
[20](https://hoestory.tistory.com/58)
[21](https://www.samsungsds.com/kr/insights/human_in_the_loop.html)