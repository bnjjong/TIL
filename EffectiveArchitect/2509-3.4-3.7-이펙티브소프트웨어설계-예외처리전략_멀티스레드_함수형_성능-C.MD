# 3장 3.4 \~ 3.7 핵심 정리

## 3.4 타사 라이브러리에서 오는 예외

* **문제**: API 시그니처에 타사 예외(예: `FileExistsException`)를 그대로 노출하면, 클라이언트 코드가 특정 구현(타사 라이브러리)와 **강결합** 됩니다. 나중에 라이브러리를 바꾸면 시그니처가 깨져 **호환성** 문제가 생깁니다.
* **해법**: **도메인 전용 예외**(예: `PersonCatalogException`)로 **감싸서(wrap)** 외부로 노출합니다. 그러면

    1. API 진화 유연성 ↑,
    2. 호출자에게 **의미 있는 메시지/컨텍스트** 제공,
    3. 스택 추적과 함께 원인 파악 용이.
* **포인트**: 모든 예외를 무조건 새로 정의하라는 뜻은 아니고, **유지보수 비용 vs 이점**을 비교해 결정. 그래도 **공개 API** 경계에서는 도메인 예외 래핑이 일반적으로 유리합니다.
> 외부 예외를 도메인에 포함할 경우 강결합 된다는 의미. 조금 귀찮지만 특정 라이브러를 사용할때 어댑터 구간을 두고 거기서 에러를 도메인 예외로 래핑처리 하라는 의미.

## 3.5 멀티스레드 환경 예외 주의점

* **`submit()` vs `execute()`**

    * `submit()`은 `Future`를 반환 → `get()`에서 **예외를 관찰·전파** 가능(차단 호출).
    * `execute()`는 **발사-후-망각**(no result) → **조용한 실패** 위험. 풀 스레드 고갈/자원 누수 위험도 있습니다.
* **전역 처리기**: `UncaughtExceptionHandler`를 등록해 스레드에서 삼켜지는 예외를 **로깅/복구**하도록 합니다(테스트로 검증 가능).
* **CompletableFuture로 비동기 예외 처리(3.5.1)**

    * 동기 API를 비동기 흐름에 올릴 땐 `supplyAsync`로 감싸되, **예외를 다시 던지기보단** `completeExceptionally` 등으로 **프라미스에 채워** 호출자에게 **원인(원래 예외)**가 보이게 하세요(불필요한 `CompletionException` 중첩을 줄임).

> 참고(JDK 문서)
>
> * `CompletableFuture` 예외 전파(`join()`은 실패 시 `CompletionException`로 감쌈). ([docs.oracle.com][1])
> * `Thread.UncaughtExceptionHandler` 공식 정의(기본/개별 스레드에 설정). ([docs.oracle.com][2], [download.java.net][3])

## 3.6 함수형 접근: Try 모나드

* **아이디어**: 함수의 **가능한 모든 결과(성공/실패)** 를 **타입**으로 모델링. 예외(부작용)를 **값**으로 다뤄서 map/filter로 **연쇄** 가능. Vavr의 `Try`(Success/Failure)가 전형.
* **장점**: 비즈니스 로직이 `try-catch`에 오염되지 않고, 실패 처리를 **명시적**으로 강제. `mapTry`로 **예외 가능 연산**을 안전하게 조합. `toOption()` 등 다른 FP 타입과 상호변환 용이.
* **주의**: **예외 기반 코드와 Try를 섞어 쓰면** 가독성·일관성이 떨어집니다. 한 메커니즘을 팀 차원에서 **일관되게** 선택하세요(외부 API가 체크 예외를 명시해주면 Try로 감싸기 수월).

> 참고(Vavr & 개요)
>
> * Vavr Try 가이드 & 개념 요약. ([Baeldung on Kotlin][4], [Vived][5])

## 3.7 예외 처리 성능 비교

* **결과 개요(마이크로벤치마크, JMH)**:

    * **기준(baseline)** < **단순 throw/catch** ≈ **Try로 감싸기** ≪ (**스택 추적 얻기**) ≪≪ (**예외 로깅**: 스택 추적 + 문자열 구성 + I/O) 순으로 **비용 증가**.
    * 결론: **로깅/스택 추적**이 비용 대부분을 차지. “상위 계층에서 한 번만 로깅” 원칙이 유효. 일반 로직에서 예외를 남용하지 않는 한 성능 이슈는 **대개 사소**.

> 참고(JMH/예외 비용 논의)
>
> * JMH 개요 및 벤치마킹 모범사례. ([Baeldung on Kotlin][6], [Medium][7])
> * 예외 비용과 흐름 제어에 쓰지 말라는 권고. ([Baeldung on Kotlin][8])

---

## 한 장 요약(압축)

* **경계(API)** 에서는 **타사 예외를 도메인 예외로 감싸라**.
* **멀티스레드/비동기**에서는 **결과 관찰 경로** (Future/CF)와 **전역 처리기**를 반드시 마련.
* **함수형(Try/Result)** 로 실패를 **값**처럼 다루면 조합성이 좋아지고, 예외-오염이 줄어듭니다(일관성 유지!).
* **성능**은 스택 추적/로깅이 핵심 비용. **한 번만 로깅**, 불필요한 re-throw+log 금지.

## 짧은 첨언(제 의견)

* 공개 API는 **의미 중심 에러 모델**(도메인 예외/에러 코드)로 설계할수록 장기 유지보수에 유리합니다.
* Kotlin 팀이라면 Java의 `Try` 대신 **`runCatching`/`Result`** 또는 **Arrow `Either`**로 **일관된 함수형 에러 처리**를 권합니다.
* 운영 환경에선 **“로그는 경계 한 번”** 원칙을 팀 규칙으로 못박아두면 장애 분석/비용 모두 개선됩니다.

---

# 직접 표 (핵심 도표 재구성)

### \[표 1] 예외 노출 vs 도메인 예외 감싸기

| 항목      | 타사 예외 노출                | 도메인 예외로 감싸기         |
| ------- | ----------------------- | ------------------- |
| 결합도     | 타사 라이브러리에 **강결합**       | **약결합**(교체 용이)      |
| 호출자 정보성 | 예외명이 저수준(`IOException`) | **업무 맥락** 포함 메시지/원인 |
| API 진화  | 시그니처 깨짐 위험              | 유연                  |
| 권장      | ❌                       | ✅                   |

### \[표 2] 작업 제출 방식과 예외 관찰

| 메서드                         | 반환       | 예외 관찰            | 비고          |
| --------------------------- | -------- | ---------------- | ----------- |
| `execute(Runnable)`         | 없음       | **불가**(조용히 실패)   | 전역 처리기 필수   |
| `submit(Callable/Runnable)` | `Future` | `get()`에서 **가능** | 차단/관찰 경로 제공 |

### \[표 3] `CompletableFuture` 예외 처리 메서드

| 메서드             | 용도          | 특징                                                     |
| --------------- | ----------- | ------------------------------------------------------ |
| `exceptionally` | 실패 시 대체값    | 실패에서만 호출(간단 복구) ([DZone][9], [Baeldung on Kotlin][10]) |
| `handle`        | 성공/실패 모두 처리 | 결과/예외 동시 인자(관통 처리) ([Stack Overflow][11])              |
| `whenComplete`  | 관찰/부수효과     | 결과 수정 X(로깅 등) ([Medium][12])                           |

### \[표 4] 성능(개념적 경향)

| 케이스             | 상대 비용(↑=느림) | 비고                |
| --------------- | ----------- | ----------------- |
| baseline(예외 없음) | ↑           | 기준                |
| throw/catch     | ↑↑          | 경미                |
| Try/값 캡슐화       | ↑↑          | throw/catch와 유사   |
| **스택 추적 생성**    | **↑↑↑↑**    | \~10배 수준 느려질 수 있음 |
| **로깅(스택+I/O)**  | **↑↑↑↑↑↑**  | 가장 비쌈(환경 의존)      |

(전체 경향은 장에서 소개된 JMH 결과 요약. 구체 수치는 환경별 상이)

---

# Kotlin 예제 (도메인 로직, as-is → to-be, Kotest 포함)

## 1) \[경계/API] 타사 예외 감싸기

### as-is: 타사 예외 노출(강결합)

```kotlin
// 외부 스토리지 클라이언트(가정): IOException, FileAlreadyExistsException 등을 던짐
interface ExternalStorage {
    fun read(path: String): ByteArray // throws IOException
    fun write(path: String, bytes: ByteArray) // throws IOException, FileAlreadyExistsException
}

// 공개 API가 타사 예외를 그대로 던지는 문제적 설계
interface DocumentCatalog {
    fun loadDoc(docId: String): ByteArray // throws IOException
    fun createDoc(docId: String, bytes: ByteArray) // throws FileAlreadyExistsException, IOException
}
```

### to-be: 도메인 예외로 감싸기(약결합)

```kotlin
// 도메인 전용 예외
sealed class DocumentException(message: String, cause: Throwable? = null) : RuntimeException(message, cause) {
    class AlreadyExists(docId: String, cause: Throwable? = null) :
        DocumentException("문서가 이미 존재합니다: $docId", cause)
    class IoFailure(action: String, docId: String, cause: Throwable? = null) :
        DocumentException("문서 $action 중 I/O 오류: $docId", cause)
}

// 경계에서 래핑
class DocumentCatalogImpl(
    private val storage: ExternalStorage
) : DocumentCatalog {
    override fun loadDoc(docId: String): ByteArray = try {
        storage.read("/docs/$docId")
    } catch (t: Throwable) {
        throw DocumentException.IoFailure("조회", docId, t)
    }

    override fun createDoc(docId: String, bytes: ByteArray) {
        try {
            storage.write("/docs/$docId", bytes)
        } catch (t: Throwable) {
            // 원인에 따라 도메인화
            val ex = if (t::class.simpleName?.contains("AlreadyExists") == true)
                DocumentException.AlreadyExists(docId, t)
            else DocumentException.IoFailure("생성", docId, t)
            throw ex
        }
    }
}
```

### Kotest

```kotlin
class DocumentCatalogSpec : io.kotest.core.spec.style.StringSpec({

    "타사 예외를 도메인 예외로 래핑한다" {
        val stub = object : ExternalStorage {
            override fun read(path: String) = error(java.io.IOException("disk!"))
            override fun write(path: String, bytes: ByteArray) = Unit
        }
        val sut = DocumentCatalogImpl(stub)

        val ex = io.kotest.assertions.throwables.shouldThrow<DocumentException.IoFailure> {
            sut.loadDoc("A-100")
        }
        ex.cause!!.message shouldBe "disk!"
    }
})
```

> 근거: 공개 API에서 타사 예외를 누출하지 말고 도메인 예외로 감싸라.
> (일반 원칙으로도 권장됩니다. ([mezocode.com][13], [Stack Overflow][14]))

---

## 2) \[비동기] 전역 처리기 + CompletableFuture 안전 처리

### as-is: `execute()`로 조용한 실패

```kotlin
class SettlementJob(private val svc: () -> Unit) {
    private val pool = java.util.concurrent.Executors.newFixedThreadPool(4)

    fun runAsyncFireAndForget() {
        pool.execute { // 실패가 관찰되지 않음
            svc() // 여기서 예외 발생 시 사라질 수 있음
        }
    }
}
```

### to-be: 전역 처리기 + `submit()`/`CompletableFuture`

```kotlin
object GlobalUncaught {
    fun installLogger(handler: (Thread, Throwable) -> Unit) {
        Thread.setDefaultUncaughtExceptionHandler { t, e -> handler(t, e) }
    }
}

class SafeSettlementJob(private val svc: () -> Int) {
    private val pool = java.util.concurrent.Executors.newFixedThreadPool(4)

    fun runWithFuture(): Int {
        val future = pool.submit<Int> { svc() } // 관찰 가능
        return future.get() // 필요 시 타임아웃 활용
    }

    fun runWithCF(onError: (Throwable) -> Unit): java.util.concurrent.CompletableFuture<Int> =
        java.util.concurrent.CompletableFuture.supplyAsync(
            { svc() }, pool
        ).exceptionally { ex ->
            onError(ex)
            // 도메인 관점 fallback (예: 0건 처리)
            0
        }.whenComplete { _, _ -> /* metric/trace */ }
}
```

### Kotest(핵심만)

```kotlin
class AsyncSpec : io.kotest.core.spec.style.StringSpec({

    "전역 UncaughtExceptionHandler가 호출된다" {
        val called = java.util.concurrent.atomic.AtomicBoolean(false)
        GlobalUncaught.installLogger { _, _ -> called.set(true) }

        val t = Thread { error("boom") }
        t.start(); t.join()

        called.get() shouldBe true
    }

    "CompletableFuture exceptionally로 복구" {
        val job = SafeSettlementJob { error("downstream") }
        val cf = job.runWithCF { /* log once */ }
        cf.join() shouldBe 0 // fallback
    }
})
```

> 참고: `UncaughtExceptionHandler` / `setDefaultUncaughtExceptionHandler` 공식 정의. ([docs.oracle.com][2], [download.java.net][3])
> `CompletableFuture` 예외 처리(`exceptionally/handle/whenComplete`) 차이. ([Baeldung on Kotlin][10], [Stack Overflow][11], [dempkow.ski][15])

---

## 3) \[함수형] Kotlin `runCatching`(= Try 유사)로 깨끗한 조합

### as-is: 섞인 스타일(예외+부분적 값 처리)

```kotlin
class SegmentParser {
    fun parseId(json: String): String {
        try {
            val node = com.fasterxml.jackson.module.kotlin.jacksonObjectMapper().readTree(json)
            return node["id"].asText()
        } catch (e: Exception) {
            // 여기서 로깅 + 재던지기(중복 로깅 위험)
            throw IllegalStateException("parse error", e)
        }
    }
}
```

### to-be: `runCatching`으로 성공/실패를 값으로 처리

```kotlin
class SegmentParserFP(
    private val mapper: com.fasterxml.jackson.databind.ObjectMapper =
        com.fasterxml.jackson.module.kotlin.jacksonObjectMapper()
) {
    fun parseId(json: String): Result<String> =
        runCatching { mapper.readTree(json) }
            .mapCatching { it["id"].asText() }
            .onFailure { /* 여기선 로깅하지 말고 호출자 경계에서 한 번만 로깅 */ }
}

// 호출 측(경계)에서 정책적으로 한 번만 로깅/대응
fun handleSegment(json: String, parser: SegmentParserFP): String =
    parser.parseId(json)
        .getOrElse { /* log once */ return "DEFAULT_ID" }
```

> 아이디어: 실패를 **타입**으로 모델링(Try/Result). 섞어 쓰지 말고 한 메커니즘을 **일관되게**.
> Vavr Try 배경 지식. ([Baeldung on Kotlin][4])

---

## 4) \[운영 규칙] “로그는 경계 한 번” — anti-pattern 방지

```kotlin
// ❌ 안티패턴: 중간 계층마다 log + rethrow → 로깅 중첩 + 비용 ↑
fun mid(): Unit = try { /* ... */ } catch (e: Exception) {
    logger.error("mid err", e); throw e
}

// ✅ 권장: 중간 계층은 원인 보존/전파만, 최상위 경계에서 단 한 번 로깅
fun midBetter(): Unit = try { /* ... */ } catch (e: Exception) {
    throw DomainException("mid fail", e) // 로그 X
}
fun controllerBoundary() {
    try { midBetter() } catch (e: Exception) {
        logger.error("request failed", e) // 여기서만 로깅
    }
}
```

> 이유: 로깅/스택 추적 비용이 크며(특히 I/O), 재로깅은 성능과 가독성 모두 해침.

---

# 웹 자료 간단 요약 & 링크

* **CompletableFuture 예외 처리 패턴 요약**: `exceptionally`(실패 시 대체), `handle`(성공/실패 모두), `whenComplete`(관찰/부수효과). 메서드별 차이를 예제와 함께 정리. ([Baeldung on Kotlin][10], [DZone][9], [Mincong Huang][16])
* **UncaughtExceptionHandler** 개념과 활용: 스레드 종료 시 잡히지 않은 예외를 한 곳에서 처리/로깅/복구. 기본/스레드별 설정 가능. ([docs.oracle.com][2], [Stack Overflow][17])
* **Vavr Try 소개**: 예외를 값으로 다루는 함수형 접근, 연쇄 조합 예시. ([Baeldung on Kotlin][4])
* **예외 성능**: 예외는 흐름 제어로 쓰지 말고, 로깅/스택 추적이 가장 비싸다는 점을 벤치마크로 설명. ([Baeldung on Kotlin][8])
* **JMH 가이드**: JVM 특성(웜업/JIT)을 고려한 미시 벤치마크 방법. ([Baeldung on Kotlin][6])

---


[1]: https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?utm_source=chatgpt.com "CompletableFuture (Java Platform SE 8 )"
[2]: https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.UncaughtExceptionHandler.html?utm_source=chatgpt.com "Thread.UncaughtExceptionHandler (Java Platform SE 8 )"
[3]: https://download.java.net/java/early_access/valhalla/docs/api/java.base/java/lang/Thread.html?utm_source=chatgpt.com "Thread (Java SE 23 & JDK 23 [build 1])"
[4]: https://www.baeldung.com/vavr-try?utm_source=chatgpt.com "Guide to Try in Vavr"
[5]: https://vived.io/on-modern-error-handling-not-just-in-java-monads-effects-and-project-amber-jvm-weekly-vol-172/?utm_source=chatgpt.com "On Modern Error Handling (Not Just in Java): Monads ..."
[6]: https://www.baeldung.com/java-microbenchmark-harness?utm_source=chatgpt.com "Microbenchmarking with Java"
[7]: https://medium.com/%40AlexanderObregon/introduction-to-java-microbenchmarking-with-jmh-java-microbenchmark-harness-55af74b2fd38?utm_source=chatgpt.com "Java JMH Guide: Benchmarking Essentials"
[8]: https://www.baeldung.com/java-exceptions-performance?utm_source=chatgpt.com "Performance Effects of Exceptions in Java"
[9]: https://dzone.com/articles/exception-handling-in-java-completablefuture?utm_source=chatgpt.com "Exception Handling in Java CompletableFuture"
[10]: https://www.baeldung.com/java-exceptions-completablefuture?utm_source=chatgpt.com "Working with Exceptions in Java CompletableFuture"
[11]: https://stackoverflow.com/questions/62867655/completablefuture-exceptionally-and-handle-swallowing-runtimeexception?utm_source=chatgpt.com "java - CompletableFuture exceptionally() and handle ..."
[12]: https://medium.com/%40prawin609/error-handling-in-completablefuture-understanding-exceptionally-handle-and-whencomplete-5cd9d8bcc8a8?utm_source=chatgpt.com "Error Handling in CompletableFuture: Understanding ..."
[13]: https://mezocode.com/exception-handling-in-java-like-a-pro/?utm_source=chatgpt.com "Exception Handling in Java Like a Pro"
[14]: https://stackoverflow.com/questions/409563/best-practices-for-exception-management-in-java-or-c-sharp?utm_source=chatgpt.com "Best practices for exception management in Java or C# - ..."
[15]: https://dempkow.ski/blog/java-completablefuture-exception-handling/?utm_source=chatgpt.com "whenComplete vs. handle - Nat Dempkowski"
[16]: https://mincong.io/2020/05/30/exception-handling-in-completable-future/?utm_source=chatgpt.com "3 Ways to Handle Exception In Completable Future"
[17]: https://stackoverflow.com/questions/19422366/java-uncaught-global-exception-handler?utm_source=chatgpt.com "Java uncaught global exception handler"
