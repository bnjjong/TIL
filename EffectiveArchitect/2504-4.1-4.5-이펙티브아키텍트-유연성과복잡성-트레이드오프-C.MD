# 📖 4장: 유연성과 복잡성 사이의 균형

## 4.1 탄탄하지만 확장성은 떨어지는 API

* **내용**

    * 새로운 컴포넌트(`HttpClientExecution`) 설계: 요청 성공/실패/재시도 메트릭 기록.
    * 초기 설계는 단순하고 유지보수하기 쉬움. 그러나 특정 메트릭 라이브러리(`Dropwizard Metrics`)에 강하게 결합.
    * 확장 지점이 부족하여 다른 라이브러리를 쓰고 싶은 클라이언트에게 제약 발생.
    * 단위 테스트로 성공, 실패, 재시도 케이스 검증.

* **제 생각**
  단순 구현으로 시작하는 건 현명합니다. 하지만 조직 단위 재사용 컴포넌트라면 “처음부터 확장 가능성”을 의식하지 않으면 금방 리팩터링 지옥에 빠지기 쉽습니다.

---

## 4.2 메트릭 추상화

* **내용**

    * `MetricsProvider` 인터페이스 도입 → 메트릭 로직 추상화.
    * 기본 구현(`DefaultMetricsProvider`) 제공.
    * 복잡성은 내부에서 줄었지만 클라이언트가 구현 부담을 떠안게 됨.
    * **트레이드오프**: 유연성 증가 ↔ 클라이언트 부담 증가.

* **제 생각**
  API 설계에서 흔히 등장하는 **“내부 단순화 vs 외부 복잡화”** 문제. 좋은 타협은 “추상화 + 기본 구현 제공”이라고 생각합니다.

---

## 4.3 훅(Hook) API

* **내용**

    * 클라이언트가 특정 시점에 자신만의 코드를 삽입 가능.
    * 장점: 미래 요구사항을 예측하지 않고도 확장성 확보.
    * 단점:

        * 예외 처리 필요 (클라이언트 코드가 던지는 런타임 예외 방어).
        * 성능 저하 가능 (차단/IO 작업으로 인한 지연, 데드락 위험).
        * 해결책: 훅 실행을 스레드풀로 병렬 처리.

* **제 생각**
  “확장성은 공짜가 아니다.” 성능 저하 + 운영 리스크를 가져오기 때문에 훅은 꼭 필요한 경우에만 최소화해야 한다고 봅니다.

---

## 4.4 리스너(Listener) API

* **내용**

    * 옵저버 패턴 활용: 특정 이벤트(예: 재시도 상태) 발생 시 클라이언트에게 알림.
    * 비동기 처리라 성능상 안전.
    * 단점:

        * 상태 불변성 문제 (클라이언트가 전달받은 상태 변경 가능).
        * 해결책: 방어적 복사 또는 불변 객체(`ImmutableList`) 활용.
        * 트래픽 급증 시 리스너 과부하 → 역압(Backpressure) 필요.

* **제 생각**
  리스너는 확장성에 유리하지만, “상태 전달”이 항상 민감 포인트. 저는 리스너 설계 시 무조건 **불변 데이터 전달 원칙**을 지키는 편입니다.

---

## 4.5 종합 (유연성 vs 복잡성)

* **내용**

    * 모든 새로운 기능은 복잡성을 증가시킨다.
    * 추상화: 내부 복잡성 감소, 외부 복잡성 증가.
    * 훅/리스너: 강력한 유연성, 하지만 상태 관리·성능·예외 처리 비용 발생.
    * 설계 시 **유연성과 복잡성 사이의 균형**을 반드시 고려해야 한다.

* **제 생각**
  유연성은 조직 성숙도와 **운영 능력에 맞게** 가져가야 합니다. `스타트업 단계라면 단순한 추상화`, `대규모 플랫폼이라면 훅/리스너`까지 고려가 합리적입니다.

---

# 📝 요약 (압축)

* 단순 → 추상화 → 훅 → 리스너 순으로 갈수록 **유연성 ↑ / 복잡성 ↑**.
* 좋은 타협: 추상화 + 기본 구현 제공.
* 훅: 클라이언트 코드 삽입 가능하지만 성능·안정성 비용 있음.
* 리스너: 비동기 이벤트 알림 구조, 불변 데이터 전파 필수.
* 핵심 교훈: **유연성은 공짜가 아니며, 복잡성과 항상 트레이드오프 관계**.

---

# 💻 Kotlin 예제 코드 (도메인: 결제 재시도)

### As-Is (단순 구현)

```kotlin
class PaymentService(
    private val metrics: PaymentMetrics,
    private val maxRetries: Int
) {
    fun pay(orderId: String): Boolean {
        repeat(maxRetries + 1) { attempt ->
            try {
                val result = callExternalPayment(orderId)
                if (result) {
                    metrics.success()
                    return true
                } else {
                    metrics.failure()
                }
            } catch (ex: Exception) {
                metrics.failure()
            }
            if (attempt < maxRetries) metrics.retry()
        }
        return false
    }

    private fun callExternalPayment(orderId: String): Boolean {
        // 실제 결제 API 호출 (간단히 true/false 반환한다고 가정)
        return orderId.length % 2 == 0
    }
}

interface PaymentMetrics {
    fun success()
    fun failure()
    fun retry()
}

class DefaultPaymentMetrics : PaymentMetrics {
    override fun success() = println("Success +1")
    override fun failure() = println("Failure +1")
    override fun retry() = println("Retry +1")
}
```

---

### To-Be (리스너 확장 적용)

```kotlin
/**
 * 재시도 과정에서의 상태 스냅샷.
 *
 * @property attempt 1부터 시작하는 재시도 횟수 (예: 첫 재시도=1)
 */
data class RetryStatus(val attempt: Int)

/**
 * 결제 재시도 이벤트를 비동기/옵저버처럼 받아 처리하는 리스너.
 * - 설계 의도: 내부 로직을 직접 수정하지 않고도 외부에서 확장(로깅/모니터링 등) 가능
 */
interface RetryListener {
    /**
     * 재시도 상태들의 스냅샷을 통지받는다.
     * - 불변 전달을 위해 호출 측에서 snapshot(toList())을 만들어 준다.
     */
    fun onRetry(statuses: List<RetryStatus>)
}

/**
 * 결제 처리 서비스(확장형).
 *
 * 설계 포인트
 * 1) Metrics 추상화 주입: 내부는 특정 라이브러리에 결합하지 않음.
 * 2) Listener 확장 지점: 재시도 이벤트를 외부로 브로드캐스트(상태는 스냅샷으로 전달).
 * 3) 상태 불변성: listeners에 전달하는 컬렉션은 매 호출 시 snapshot을 넘겨 side-effect 차단.
 *
 * @param metrics   성공/실패/재시도 카운팅을 담당하는 추상화된 메트릭 기록자
 * @param maxRetries 최대 재시도 횟수 (예: 2면 총 시도 횟수는 1+2=3회)
 * @param listeners 재시도 이벤트를 구독하는 리스너 목록(기본은 빈 목록)
 */
class PaymentServiceV2(
    private val metrics: PaymentMetrics,
    private val maxRetries: Int,
    private val listeners: MutableList<RetryListener> = mutableListOf()
) {

    /**
     * 리스너 등록.
     * - 멀티스레드 환경이라면 CopyOnWriteArrayList 등으로 교체 고려.
     */
    fun registerListener(listener: RetryListener) {
        listeners.add(listener)
    }

    /**
     * 결제 시도 진입점.
     *
     * 흐름
     * - (성공) 즉시 success() 기록 후, 지금까지의 재시도 상태 스냅샷을 리스너에 통지하고 true 반환
     * - (실패) failure() 기록 → (재시도 가능) retry() 및 상태 축적 → 반복
     * - (전부 실패) 마지막에 최종 스냅샷을 리스너에 통지하고 false 반환
     *
     * 주의
     * - 반복문은 0..maxRetries(포함)로 총 시도 횟수 = 초기 1회 + 재시도 N회
     * - 리스너에는 매번 새로운 List 스냅샷(toList())을 넘겨 외부 변경으로부터 내부 상태 보호
     */
    fun pay(orderId: String): Boolean {
        val statuses = mutableListOf<RetryStatus>() // 누적 재시도 상태(시도할 때마다 추가)

        repeat(maxRetries + 1) { attempt ->
            try {
                val result = callExternalPayment(orderId)

                if (result) {
                    // 1) 성공: 성공 메트릭 기록 후, 현재까지의 재시도 상태 스냅샷을 통지하고 종료
                    metrics.success()
                    notifyListeners(statuses.toList()) // 불변 스냅샷 전달(방어적 복사)
                    return true
                } else {
                    // 2) 외부 호출은 성공적으로 끝났지만 비즈니스 실패로 간주되는 경우
                    metrics.failure()
                }
            } catch (ex: Exception) {
                // 3) 네트워크/예외 등 기술적 실패
                metrics.failure()
            }

            // 4) 아직 재시도 기회가 남았으면 재시도 메트릭 기록 + 상태 축적
            if (attempt < maxRetries) {
                metrics.retry()
                statuses.add(RetryStatus(attempt = attempt + 1)) // attempt는 0부터 시작하므로 +1
            }
        }

        // 5) 모두 실패: 누적 상태를 마지막으로 통지 후 false 반환
        notifyListeners(statuses.toList())
        return false
    }

    /**
     * 리스너들에게 재시도 상태 스냅샷을 브로드캐스트.
     * - List는 읽기 전용 뷰지만, 외부 변경에 대비해 항상 toList()로 새 리스트를 넘긴다.
     * - 고부하/고빈도라면 큐/백프레셔/비동기 디스패치 고려.
     */
    private fun notifyListeners(statuses: List<RetryStatus>) {
        // 필요 시 try-catch로 개별 리스너 실패 격리 & 로깅 권장
        listeners.forEach { it.onRetry(statuses) }
    }

    /**
     * 실제 외부 결제 시스템 호출(샘플).
     * - 예제에서는 orderId 길이의 짝/홀로 성공/실패를 흉내낸다.
     * - 실전에서는 타임아웃/재시도 정책/에러 매핑 등을 함께 다룬다.
     */
    private fun callExternalPayment(orderId: String): Boolean {
        return orderId.length % 2 == 0
    }
}

/**
 * 메트릭 추상화.
 * - 특정 라이브러리(Dropwizard, Micrometer 등)에 대한 결합을 제거하기 위한 포트(Port)
 */
interface PaymentMetrics {
    fun success()
    fun failure()
    fun retry()
}

```

---

# ✅ Kotest 테스트 예시

```kotlin
import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.shouldBe

class PaymentServiceTest : StringSpec({

    "첫 시도에 성공하면 재시도 없음" {
        val metrics = TestMetrics()
        val service = PaymentService(metrics, maxRetries = 3)

        val result = service.pay("1234")

        result shouldBe true
        metrics.successCount shouldBe 1
        metrics.retryCount shouldBe 0
    }

    "실패 후 재시도 성공 시 리스너 호출" {
        val metrics = TestMetrics()
        val service = PaymentServiceV2(metrics, maxRetries = 2)
        val retries = mutableListOf<RetryStatus>()

        service.registerListener(object : RetryListener {
            override fun onRetry(status: RetryStatus) {
                retries.add(status)
            }
        })

        val result = service.pay("123") // 홀수 → 첫 실패, 두 번째 성공

        result shouldBe true
        retries.size shouldBe 1
        retries.first().attempt shouldBe 1
    }
})

class TestMetrics : PaymentMetrics {
    var successCount = 0
    var failureCount = 0
    var retryCount = 0
    override fun success() { successCount++ }
    override fun failure() { failureCount++ }
    override fun retry() { retryCount++ }
}
```

---

# 🌐 참고 자료

* [Dropwizard Metrics 공식 문서](https://metrics.dropwizard.io/4.2.0) – 메트릭 수집 라이브러리
* [Observer Pattern (GoF 디자인 패턴)](https://refactoring.guru/design-patterns/observer)
* [Hook vs Listener API 설계 비교](https://martinfowler.com/articles/injection.html)
