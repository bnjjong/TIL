# 3.1 예외의 계층 구조 — 무엇을 어디서 잡을 것인가

* 자바의 모든 예외는 `Throwable`을 루트로 하며, 크게 `Error`(치명적, 보통 잡지 않음)와 `Exception`으로 나뉨. `Exception`은 다시 **Checked**(컴파일러가 처리 강제)와 **Unchecked**(`RuntimeException` 계열, 선택 처리)로 구분. 이 구분은 “호출자에게 복구 기회를 줄 것인가?”를 API 계약 차원에서 표현하는 장치다.
* **세분화된 catch** vs **광역 catch**: 더 넓은 타입(예: `IOException`)으로 잡으면 코드가 단순해지지만, 구체 예외 정보(예: `FileAlreadyExistsException`)를 잃어 디버깅/처치가 어려워질 수 있다. 필요 시 **멀티-catch**( `catch (IOException | InterruptedException e)` )로 중복을 줄이되, 의미 있는 정보는 유지한다.
* Unchecked 예외는 선언도/처리도 강제가 아니어서 쉽게 `main`까지 전파돼 앱을 중단시킬 수 있다. 따라서 “정말 복구 불가”이거나 “계약 위반(선행조건 위반)”을 신속 실패로 처리할 때 사용한다.

**도식: 자바 예외 계층(요약)**

| 루트          | 분기                            | 대표 타입                                              | 처리 가이드                         |
| ----------- | ----------------------------- | -------------------------------------------------- | ------------------------------ |
| `Throwable` | `Error`                       | `OutOfMemoryError` 등                               | 일반적으로 잡지 않음                    |
| 〃           | `Exception`(Checked)          | `IOException`, `InterruptedException`              | 호출자 복구 의도 → 메서드 시그니처에 선언/처리 강제 |
| 〃           | `RuntimeException`(Unchecked) | `IllegalArgumentException`, `NullPointerException` | 선행조건 위반/프로그래밍 오류/복구 불가 → 선택 처리 |

> ✍️ 짧은 첨언: 도메인 경계(public API)에서는 **가능한 실패를 “명시적으로” 드러내는** 편이 협업/유지보수에 유리합니다. 내부(private) 구현은 불필요한 장황함을 줄이되, 상위 계층이 복구를 의도하는 지점이라면 **구체 예외 정보를 잃지 않게** 설계하는 게 포인트.

---

# 3.2 내가 소유한 코드(API)에서의 우수 사례

* **공개 API에서 Checked 예외 선언**: 호출자에게 “무엇이 실패할 수 있는지”를 계약으로 알려준다. 필요하면 내부에서 한 번 잡아 **Unchecked로 감싸 재전파**(wrap)해 호출자 부담을 낮출 수도 있지만, 이 방식은 **의미 있는 실패 신호를 감추는 부작용**이 있으니 남용 금지.
* **Unchecked 예외의 문서화 역할**: `IllegalArgumentException`, `IllegalStateException`을 시그니처에 **선언(throws 없이 타입 언급 차원)** 해 두면, 호출자는 선행조건/상태 제약을 IDE 수준에서 즉시 인지한다(실제 잡을 의무는 없음). 과도한 선언은 장황해질 수 있으나, **public API** 일부에 한정되므로 과하지 않게 유지 가능.
* 어떤 유형(Checked/Unchecked)을 쓸지는 **컨텍스트 트레이드오프**의 문제:

    * **내부 모듈 간**(작성자 동일): Unchecked로 단순화해도 리스크가 작음.
    * **외부/타팀 호출 가능 API**: Checked로 명시적으로 실패를 모델링하는 편이 호출자 경험/안전성 향상.

> ✍️ 짧은 첨언: “명시성이냐, 단순성이냐”의 균형 싸움입니다. **도메인 실패는 타입/프로토콜로, 시스템 실패는 예외로** 구분하면 API가 깔끔해집니다. 예: “잔액 부족”은 도메인 결과(`Result`)로, “DB 연결 끊김”은 예외로.

---

# 3.3 피해야 할 안티 패턴

1. **예외 삼키기(swallow)**: `catch (Exception e) {}` 혹은 `printStackTrace()`만 찍고 끝. 이렇게 하면 **무언(無言)의 실패**가 생겨 추적 불가. 반드시 **로깅 + 전파** 또는 **로깅 + 변환 후 전파** 하자.
2. **자원 누수**: 처리 중 예외가 나면 `close()`가 실행되지 않을 수 있음 → `try-with-resources`(Java) / Kotlin의 `use {}`로 자동 해제.   또한 “예외 여부와 무관하게 실행” 보장을 위해 `finally`를 사용(언어가 지원 시).
3. **흐름 제어로 예외 남용**: 정상 분기(예: 값이 없음/조건 불일치)를 예외로 처리하면 호출자 로직이 예외적인 분기들로 오염되고 비용까지 증가. 이런 경우는 `Result/Either/Try` 같은 **값 기반 결과**(함수형)로 모델링하는 것이 바람직.

> ✍️ 짧은 첨언: “예외는 예외적인 상황”일 때만 쓰세요. **빈 컬렉션/옵셔널/도메인 결과 타입**으로 충분히 표현 가능한 것들은 예외 대신 값으로 돌려주는 게 유지보수/성능 모두 이점.

---

# (참고) “Let it crash” 철학과의 조화

* 에릭슨/Erlang/아카(Akka)의 **슈퍼비전/Let-it-crash**는 **경량 프로세스/액터 격리**가 전제일 때 유효. JVM 웹앱의 단일 프로세스/스레드 풀 모델에 무비판 적용은 위험. 다만 **액터/워크 단위 격리**가 있는 곳에서는 “치명적 오류 시 재시작” 전략이 유효하다. ([Akka Documentation][1], [SoftwareMill Tech Blog][2], [Medium][3])
* Akka Typed 액터는 예외가 발생했을 때 기본적으로 중지되는 특징을 가지고 있습니다. 이는 Classic Akka 액터가 기본적으로 재시작되는 것과는 다른 중요한 차이점입니다

## 실패 유형 구분
### Validation Error vs Failure
- **Validation Error (검증 오류)** 는 액터에게 보내진 명령의 데이터가 유효하지 않은 경우로, 이는 예외를 발생시키기보다는 `액터 프로토콜의 일부로 모델링`되어야 합니다.
- **Failure (실패)** 는 데이터베이스 연결 끊김과 같이 예상치 못한 상황이나 `액터가 제어할 수 없는 상황`을 의미합니다. 이러한 실패에 대해서는 "Let it crash" 철학을 적용하는 것이 유용합니다.


> ✍️ 짧은 첨언: “충돌을 허용”하려면 **격리 단위**가 먼저 있어야 합니다. 없으면 한 요청의 크래시가 전체 서비스로 번질 수 있어요. 본문도 바로 이 지점을 강조합니다.

---

# 도메인 예제 (Kotlin) — “쿠폰 발급” 시나리오

## 배경

* 마케터가 캠페인별 **쿠폰 발급**을 요청.
* 제약: 캠페인이 **활성 상태**여야 하며, **발급 한도**와 **예산**을 만족해야 함.
* 외부 시스템(쿠폰 저장소, 회계 API) 호출 중 **시스템 오류**가 날 수 있음.

## AS-IS (안티 패턴이 섞인 구현)

문제점: (1) 흐름 제어로 예외 남발, (2) 예외 삼키기, (3) 자원 누수 위험.

```kotlin
// AS-IS: 나쁜 예 (예외로 정상 분기, 삼키기, 로깅만 하고 끝)
class CouponServiceAsIs(
    private val repo: CouponRepository,     // AutoCloseable 아님 가정
    private val billing: BillingClient      // AutoCloseable
) {
    fun issue(campaignId: String, userId: String): String {
        try {
            // 1) 도메인 정상 분기를 예외로 처리(남용)
            if (!repo.isCampaignActive(campaignId)) {
                throw IllegalStateException("INACTIVE") // 정상 분기인데 예외!
            }
            if (repo.issuedCount(campaignId) >= repo.quota(campaignId)) {
                throw RuntimeException("QUOTA_EXCEEDED") // 역시 정상 분기
            }

            // 2) 외부 자원(close 필요)을 try-finally 없이 사용 → 누수 위험
            val tx = billing.openTransaction() // 가정: 명시 close 필요
            val coupon = repo.createCoupon(campaignId, userId)
            billing.reserveBudget(tx, campaignId, repo.unitCost(campaignId))
            return coupon.code
        } catch (e: Exception) {
            e.printStackTrace() // 😱 삼키기 + 표준출력
            return "FALLBACK"   // 😱 침묵 실패 + 의미 불명 결과
        }
    }
}
```

## TO-BE (개선) — “도메인 결과는 값으로, 시스템 오류만 예외로”, “자원은 `use`로”

핵심:

* 정상 실패(재고 없음/비활성/한도 초과)는 **값 기반 결과**(`sealed class IssueResult`)로 모델링.
* 외부 자원은 `AutoCloseable`을 구현하고 **`use {}`**로 누수 방지.
* 시스템 예외는 **로깅 + 변환(필요 시) + 전파**.

```kotlin
// 결과 모델: 도메인 "정상 실패"는 값으로
sealed class IssueResult {
    data class Success(val code: String) : IssueResult()
    data object InactiveCampaign : IssueResult()
    data object QuotaExceeded : IssueResult()
    data object BudgetInsufficient : IssueResult()
}

// 외부 자원: AutoCloseable로 가정 → Kotlin use{} 가능
interface BillingClient : AutoCloseable {
    fun openTransaction(): BillingClient // 데모를 위해 자기 자신 반환
    fun reserveBudget(campaignId: String, amount: Long): Boolean
    override fun close()
}

interface CouponRepository {
    fun isCampaignActive(campaignId: String): Boolean
    fun issuedCount(campaignId: String): Int
    fun quota(campaignId: String): Int
    fun unitCost(campaignId: String): Long
    fun createCoupon(campaignId: String, userId: String): Coupon
}

data class Coupon(val code: String)

class CouponService(
    private val repo: CouponRepository,
    private val billingFactory: () -> BillingClient
) {
    fun issue(campaignId: String, userId: String): IssueResult {
        // 1) 도메인 정상 분기는 값으로 표현
        if (!repo.isCampaignActive(campaignId)) return IssueResult.InactiveCampaign
        if (repo.issuedCount(campaignId) >= repo.quota(campaignId)) return IssueResult.QuotaExceeded

        // 2) 시스템 상호작용은 예외 가능 → use{}로 자원 해제 보장
        return try {
            billingFactory().use { billing ->
                val amount = repo.unitCost(campaignId)
                val ok = billing.reserveBudget(campaignId, amount)
                if (!ok) return IssueResult.BudgetInsufficient

                val coupon = repo.createCoupon(campaignId, userId)
                IssueResult.Success(coupon.code)
            }
        } catch (e: Exception) {
            // 의미 있는 로깅 + 상위 전파 또는 매핑
            // (여기선 런타임으로 변환 후 전파 예시)
            throw IllegalStateException("Failed to issue coupon: ${e.message}", e)
        }
    }
}
```
### use { ... } 한 장 요약

- 무엇: Closeable/AutoCloseable 리소스를 안전하게 쓰고 블록 종료 시 무조건 close 해주는 확장 함수.
- 왜: 예외가 나더라도 자원 누수 없이 닫아주고, block 예외가 우선되며 close 중 예외는 **억제(suppressed)** 로 붙여줌.
- 언제: 파일/스트림/JDBC/HTTP 클라이언트 등 “닫아야 하는” 모든 자원에 사용.
- 특징: inline 이라 use 블록 안의 return이 바깥 함수로 바로 반환(non-local return).

### Kotest 테스트 (예외/정상 실패 모두 검증)

* **정상 실패는 값 매칭**
* **시스템 오류는 `shouldThrow`** 로 명확 검증( Kotest 문서 참고 ). ([Kotest][4])

```kotlin
import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.shouldBe
import io.kotest.assertions.throwables.shouldThrow

class CouponServiceTest : StringSpec({

    "비활성 캠페인은 값 기반 실패를 반환" {
        val repo = stubRepo(active = false)
        val svc = CouponService(repo) { stubBilling(success = true) }
        svc.issue("C1", "U1") shouldBe IssueResult.InactiveCampaign
    }

    "한도 초과는 값 기반 실패를 반환" {
        val repo = stubRepo(issued = 10, quota = 10)
        val svc = CouponService(repo) { stubBilling(success = true) }
        svc.issue("C1", "U1") shouldBe IssueResult.QuotaExceeded
    }

    "예산 부족은 값 기반 실패를 반환" {
        val repo = stubRepo(unitCost = 100)
        val svc = CouponService(repo) { stubBilling(success = false) }
        svc.issue("C1", "U1") shouldBe IssueResult.BudgetInsufficient
    }

    "시스템 오류는 예외로 전파" {
        val repo = object : CouponRepository by stubRepo() {
            override fun createCoupon(campaignId: String, userId: String) =
                throw RuntimeException("db down")
        }
        val svc = CouponService(repo) { stubBilling(success = true) }
        shouldThrow<IllegalStateException> {
            svc.issue("C1", "U1")
        }
    }
})

/** --- 테스트용 스텁 --- **/
fun stubRepo(
    active: Boolean = true,
    issued: Int = 0,
    quota: Int = 100,
    unitCost: Long = 10
): CouponRepository = object : CouponRepository {
    override fun isCampaignActive(campaignId: String) = active
    override fun issuedCount(campaignId: String) = issued
    override fun quota(campaignId: String) = quota
    override fun unitCost(campaignId: String) = unitCost
    override fun createCoupon(campaignId: String, userId: String) = Coupon("CP-$userId")
}

fun stubBilling(success: Boolean): BillingClient = object : BillingClient {
    override fun openTransaction(): BillingClient = this
    override fun reserveBudget(campaignId: String, amount: Long) = success
    override fun close() { /* no-op */ }
}
```

> 💡 `use {}`는 Kotlin에서 Java의 try-with-resources와 동일 목적. `Closeable/AutoCloseable` 대상에 적용되며, 블록 종료 시 예외 여부와 무관하게 `close()`가 호출됩니다. ([Baeldung on Kotlin][5], [Joao Alves][6], [Kotlin Discussions][7])

### JPA에선 어떻게 close되는걸까?
- **Spring JPA(=Spring Data JPA + Hibernate)**에서는 EntityManager, Hibernate Session, JDBC Connection 같은 리소스를 스프링이 트랜잭션 경계(@Transactional) 안에서 `자동으로 관리`합니다.
- 그래서 일반적으로 close()를 직접 호출할 일이 없었고(맞아요!), 대신 트랜잭션이 끝날 때 적절히 flush → commit/rollback → close/반납이 일어납니다.

#### 내가 직접 관리해야 되는 케이스
- Java 8 Stream<T>를 반환하는 JPA 쿼리
    - 예: fun findByStatus(status: Status): Stream<Order>
    - 스트림은 열린 커서를 잡고 있을 수 있어요.
    - 안전한 습관: 트랜잭션 경계 안에서 try-with-resources/Kotlin use {}로 소비 후 닫기.
    ```kotlin
    @Transactional(readOnly = true)
    fun export(): List<OrderDto> =
        orderRepo.findByStatus(ACTIVE).use { stream ->
            stream.map { it.toDto() }.toList()
        }
    
    ```
- LOB(대용량 바이너리/텍스트) 스트리밍
  - InputStream/Reader 등은 JPA 밖의 일반 자원이므로 use {}로 닫으세요.
- 직접 만든 EntityManager
    - EntityManagerFactory#createEntityManager()로 수동 생성했다면, 직접 em.close() 해야 합니다.
    - 보통은 스프링이 주입해 주는(프록시) EntityManager만 쓰면 됩니다.
- JPA 밖의 순수 JDBC 사용
    - DataSource.getConnection()을 직접 열었다면 use {}(또는 try-with-resources)로 닫기.


---

# 한눈 요약

* **3.1**: 예외는 정보다. **Checked**는 “복구 의도”, **Unchecked**는 “프로그래밍 오류/선행조건 위반/복구 불가”를 신속 실패로 표명. 광역-catch는 쉽지만 **구체 정보 손실**이 크다.
* **3.2**: **공개 API**는 실패를 **명시적으로 계약화**(Checked); 불필요한 장황함은 필요한 곳에서만. Unchecked는 **선행조건 위반** 등 문서화 용도로 제한적으로.
* **3.3**: **예외 삼키기**, **자원 누수**, **흐름 제어로 예외 남용** 금지. 자원은 `try-with-resources`/`use {}`로, 정상 실패는 **값 결과**로.

---

# 더 읽을거리(간단 정리 + 링크)

* **Java 예외 가이드(오라클 튜토리얼)**: Checked/Unchecked 정의, 언제/어떻게 사용할지 기본기. ([Oracle Docs][8])
* **Kotlin의 try-with-resources 대안**: `use {}` 확장으로 자원 해제 보장(2024.03 최신 정리). ([Baeldung on Kotlin][5])
* **Kotest로 예외 테스트**: `shouldThrow`, 메시지 검증 등. ([Kotest][4])
* **Akka/Erlang “Let it crash”**: 격리/슈퍼비전이 전제일 때 유효한 전략—JVM 웹앱에서의 적용 한계와 포인트 정리. ([Akka Documentation][1], [SoftwareMill Tech Blog][2])

---

[1]: https://doc.akka.io/libraries/akka-core/current/typed/fault-tolerance.html?utm_source=chatgpt.com "Fault Tolerance"
[2]: https://blog.softwaremill.com/supervision-error-handling-in-zio-akka-and-monix-part-3-series-summary-abe75f964c2a?utm_source=chatgpt.com "Supervision & error handling in ZIO, Akka and Monix (part ..."
[3]: https://medium.com/%40rng/erlang-a-veterans-take-on-concurrency-fault-tolerance-and-scalability-adff3f96565b?utm_source=chatgpt.com "Erlang: A Veteran's Take on Concurrency, Fault Tolerance, ..."
[4]: https://kotest.io/docs/assertions/exceptions.html?utm_source=chatgpt.com "Exceptions"
[5]: https://www.baeldung.com/kotlin/try-with-resources?utm_source=chatgpt.com "Try-with-resources in Kotlin"
[6]: https://joaoalves.dev/posts/kotlin-playground/kotlin-trywithresources-use/?utm_source=chatgpt.com "Kotlin try-with-resources — use - Joao Alves"
[7]: https://discuss.kotlinlang.org/t/closing-db-connection/2393?utm_source=chatgpt.com "Closing DB connection"
[8]: https://docs.oracle.com/javase/tutorial/essential/exceptions/index.html?utm_source=chatgpt.com "Lesson: Exceptions - Java™ Tutorials"
