# 2장 코드 중복 대 유연성 - 코드 중복이 항상 나쁘지만은 않다

## 개요 (페이지 18-19)

DRY(Don't Repeat Yourself) 원칙은 가장 잘 알려진 소프트웨어 공학 규칙이다. 하지만 가능한 모든 시스템을 구축하는 과정에서 DRY 원칙에 지나치게 집중하는 것은 위험할 수 있으며 많은 복잡성을 숨길 수 있다.

오늘날 분산 시스템에서 코드 중복을 줄이려는 선택은:
- 컴포넌트 사이에 강한 결합 초래
- 팀의 개발 속도 저하  
- 여러 장소에서 사용될 코드 변경 시 많은 조정 필요

### 💡 저자의 의견
DRY 원칙을 맹목적으로 따르기보다는 상황에 맞는 트레이드오프를 고려하는 것이 중요합니다. 특히 분산 시스템에서는 중복을 허용하는 것이 더 나은 선택일 수 있습니다.

## 2.1 코드베이스 사이의 공통 코드와 중복 (페이지 18-23)

### 2.1.1 시나리오 설정 (페이지 18-19)

두 팀이 독립적인 서비스를 개발하는 시나리오:
- 팀 A: Payment 서비스 (`/payment` 엔드포인트)
- 팀 B: Person 서비스 (`/person` 엔드포인트)

이때 높은 개발 회전율(속도)을 얻을 수 있는 이유는 **팀 사이의 동기화가 필요하지 않기 때문**이다.

### 암달의 법칙 (Amdahl's Law) 적용 (페이지 18-19)

암달의 법칙을 사용해 동기화가 소프트웨어 배포 과정의 전체 시간에 미치는 영향을 계산할 수 있다:

| 병렬 비중 | 최대 성능 개선 | 특징 |
|-----------|---------------|------|
| 50% | 2배 | 동기화 부하가 높아 성능 개선 제한적 |
| 75% | 4배 | 적당한 성능 개선 가능 |
| 90% | 10배 | 상당한 성능 개선 가능 |
| 95% | 20배 | 매우 높은 성능 개선 가능 |

### 2.1.2 새로운 비즈니스 요구사항: 인가 컴포넌트 추가 (페이지 20-22)

두 서비스에 인가(authorization) 기능을 추가해야 하는 요구사항이 생겼을 때:

**AS-IS: 중복 구현**
```kotlin
// Payment 서비스의 인가 컴포넌트
class PaymentAuthService {
    fun isTokenValid(token: String): Boolean {
        return token == "secret"
    }
}

// Person 서비스의 인가 컴포넌트  
class PersonAuthService {
    fun isTokenValid(token: String): Boolean {
        return token == "secret" // 동일한```이 중복됨
    }
}
```

### 2.1.3 결과 평가 (페이지 22-23)

**장점:**
- 팀 간 독립적 개발 가능
- 조정 없는 빠른 작업 진행

**단점:**
- 더 많은 버그와 실수 유발 가능
- 지식 공유 부재
- 중복된 작업 수행

### 💡 저자의 의견
초기에는 중복을 허용하더라도 팀 간 독립성을 보장하는 것이 전체적인 개발 속도 향상에 도움이 될 수 있습니다.

## 2.2 라이브러리, 그리고 코드베이스 사이에서 코드 공유 (페이지 23-27)

### 2.2.1 공유 라이브러리의 트레이드오프와 단점 (페이지 24-26)

**TO-BE: 공유 라이브러리 접근법**
```kotlin
// 공유 라이브러리
class AuthLibrary {
    fun isTokenValid(token: String): Boolean {
        return token == "secret"
    }
}

// Payment 서비스에서 사용
class PaymentService {
    private val authLibrary = AuthLibrary()
    
    fun processPayment(token: String, paymentData: PaymentData```Result {
        return if (authLibrary.isTokenValid(token)) {
            // 결제 처리 로직
            Result.success()
        } else {
            Result.unauthorized()
        }
    }
}

// Person 서비스에서 사용
class PersonService {
    private val authLibrary = AuthLibrary()
    
    fun getPerson(token: String, personId: String): Person? {
        return if (authLibrary.isTokenValid(token)) {
            // 사용자 정보 조회 로직
            findPersonById(personId)
        } else {
            null
        }
    }
}
```

### 주요 고려사항

**1. 의존성 충돌 문제**
```kotlin
// 문제 상황: 버전 충돌
// AuthLibrary가 Guava 27.0에 의존
// ThirdPartyLibrary가 Guava 28.0에 의존
// -> methodA()가 28.0에서 제거되어 런타임 오류 발생
```

**2. 개발 과정 설정**
- 코딩 관례 수립
- 배포 프로세스 구축  
- 문서화 및 테스트 커버리지 유지
- 라이브러리 홍보 및 채택

### 💡 저자의 의견
라이브러리 접근법은 코드 중복을 해결하지만, 의존성 관리와 버전 호환성 문제를 신중히 고려해야 합니다.

## 2.3 독립적인 마이크로서비스로 코드 추출 (페이지 27-34)

### 마이크로서비스 아키텍처 접근법

**TO-BE: 독립 마이크로서비스**
```kotlin
// Authorization 마이크로서비스
@RestController
@RequestMapping("/auth")
class AuthController {
    private val authService = AuthService()
    
    @GetMapping("/validate/{token}")
    fun validateToken(@PathVariable token: String): ResponseEntity<Void> {
        return if (authService.isTokenValid(token)) {
            ResponseEntity.ok().build()
        } else {
            ResponseEntity.status(HttpStatus.UNAUTHORIZED).build()
        }
    }
}

// HTTP 클라이언트를 통한 인가 서비스 호출
class AuthServiceClient {
    private val httpClient = HttpClient.newHttpClient()
    private val authServiceUrl = "http://auth```rvice"
    
    fun isTokenValid(token: String): Boolean {
        return try {
            val request = HttpRequest.newBuilder()
                .uri(URI.create("$authServiceUrl/auth/validate/$token"))
                .GET()
                .build()
                
            val response = httpClient.send(request, HttpResponse.BodyHandlers.ofString())
            response.statusCode() == 200
        } catch (e: Exception) {
            false
        }
    }
}

// Payment 서비스에서 사용
class PaymentController {
    private val authClient = AuthServiceClient()
    private val paymentService = PaymentService```    
    @PostMapping("/payment")
    fun createPayment(@RequestHeader("Authorization") token: String, 
                     @RequestBody payment: PaymentRequest```ResponseEntity<PaymentResponse> {
        return if (authClient.isTokenValid(token)) {
            val result = paymentService```ocessPayment(payment)
            ResponseEntity.ok(result)
        } else {
            ResponseEntity.status(HttpStatus.UNAUTHORIZED).build()
        }
    }
}
```

### 2.3.1 독립적인 서비스의 트레이드오프와 단점 (페이지 30-33)

### 주요 고려사항

**1. 배포 과정**
- 프로세스 감시 및 모니터링 필요
- 경보 시스템 설정
- 장애 대응 프로세스

**2. 버전 관리**  
- API 하위 호환성 유지
- 엔드포인트 사용 현황 모니터링
- 점진적 지원 중단 가능

**3. 자원 소비**
- 클라이언트 측 처리 부하 감소
- 마이크로서비스 측 확장 필요
- HTTP 호출 오버헤드

**4. 성능 고려사항**
- 추가 HTTP 요청으로 인한 지연시간
- SLA 영향 분석 필요
- 캐싱 전략 구현

### 성능 최적화 예제
```kotlin
// 토큰 캐싱을 통한 성능 최적화
class CachedAuthServiceClient {
    private val authClient = AuthServiceClient()
    private val tokenCache = ConcurrentHashMap<String, C```eEntry>()
    private val cacheExpirationMinutes = 5L
    
    data class CacheEntry(
        val isValid: Boolean,
        val timestamp: LocalDateTime
    )
    
    fun isTokenValid(token: String): Boolean {
        val cached = tokenCache[token]
        val now = LocalDateTime.now()
        
        // 캐시가 있고 만료되지 않았으면 캐시된 값 반```       if (cached != null && 
            Duration.between(cached.timestamp, now).toMinutes() < cacheExpirationMinutes) {
            return cached.isValid
        }
        
        // 캐시가 없거나 만료되었으면 실제 호출
        val isValid = authClient.isTokenVali```oken)
        tokenCache[token] = CacheEntry(isValid, now)
        
        return isValid
    }
}
```

### 장애 처리 및 회로 차단기 패턴
```kotlin
// 회로 차단기 패턴 구현
class CircuitBreakerAuthClient {
    private val authClient = AuthServiceClient()
    private var circuitState = CircuitState.CLOSED```  private var failureCount = 0
    private var lastFailureTime = LocalDateTime.```()
    private val failureThreshold = 5
    private val timeoutMinutes = 1L
    
    enum class CircuitState { CLOSED, OPEN, HALF_OPEN }
    
    fun isTokenValid(token: String): Boolean {
        when (circuitState) {
            CircuitState.OPEN -> {
                if (Duration.between(lastFailureTime, LocalDateTime.now()).toMinutes() >= timeoutMinutes) {
                    circuitState = CircuitState.```F_OPEN
                } else {
                    // 기본값 반환 또는 예외 처리
                    return false
                }
            }
            CircuitState.HALF_OPEN -> {
                return try {
                    val result = authClient.isTokenVali```oken)
                    circuitState = CircuitState.CLOSED```                  failureCount = 0
                    result
                } catch (e: Exception) {
                    circuitState = CircuitState.OPEN```                  lastFailureTime = LocalDateTime.now```                    false
                }
            }
            CircuitState.CLOSED -> {
                return try {
                    authClient.isTokenValid(token)
                } catch (e: Exception) {
                    failureCount++
                    if (failureCount >= failureThreshold) {
                        circuitState```CircuitState.OPEN```                      lastFailureTime = Local```eTime.now()
                    }
                    false
                }
            }
        }
    }
}
```

### 💡 저자의 의견
마이크로서비스 접근법은 더 많은 복잡성을 가져오지만, 독립적인 확장과 배포가 가능한 장점이 있습니다. 단순한 로직의 경우 라이브러리가, 복잡한 비즈니스 도메인의 경우 마이크로서비스가 적합할 수 있습니다.

## 테스트 코드 (Kotest)

```kotlin
import io.kotest.core.spec.style.BehaviorSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
import io.mockk.every
import io.mockk.mockk
import io.mockk.verify

class AuthServiceTest : BehaviorSpec({
    
    given("공유 라이브러리 방식의 AuthService") {
        val authService = AuthLibrary()
        
        `when`("유효한 토큰으로 검증할 때") {
            val result = authService.isTokenValid("secret")
            
            then("true를 반환해야 한다") {
                result shouldBe true
            }
        }
        
        `when`("무효한 토큰으로 검증할 때") {
            val result = authService.```okenValid("invalid")
            
            then("false를 반환해야 한다") {
                result shouldBe false
            }
        }
    }
    
    given("마이크로서비스 방식의 AuthServiceClient") {
        val mockHttpClient = mockk<Auth```viceClient>()
        
        `when`("인증 서비스가 정상 응답할 때") {
            every { mockHttpClient.isTokenValid("valid-token") } returns true
            
            val result = mockHttpClient```TokenValid("valid-token")
            
            then("true를 반환해야 한다") {
                result shouldBe true
                verify { mockHttpClient.isTokenValid("valid-token") }
            }
        }
        
        `when`("인증 서비스가 오류 응답할 때") {
            every { mockHttpClient.isTokenValid("invalid-token") } returns false
            
            val result = mockHttpClient.isTokenVali```invalid-token")
            
            then("false를 반환해야 한다") {
                result shouldBe false
            }
        }
    }
    
    given("캐싱 기능이 있는 AuthServiceClient") {
        val cachedAuthClient = CachedAuthServiceClient()
        
        `when`("동일한 토큰으로 연속 호출할 때") {
            val firstResult = cachedAuthClient.is```enValid("test-token")
            val secondResult = cachedAuthClient.isToken```id("test-token")
            
            then("캐시된 결과를 반환해야 한다") {
                firstResult shouldBe```condResult
            }
        }
    }
})
```

## 관련 자료

### 추가 학습 자료

1. **DRY 원칙의 함정** : [The Fallacy of DRY](https://dev.to/jeroendedauw/the-fallacy-of-dry)[1]
   - DRY를 맹목적으로 따를 때의 위험성과 적절한 중복의 가치에 대해 설명

2. **마이크로서비스 vs 공유 라이브러리** : [When to use shared libraries in Microservices](https://shekhargulati.com/2021/10/20/when-to-use-shared-libraries-in-microservices-architecture/)[2]
   - 마이크로서비스에서 공유 라이브러리 사용 시점과 고려사항

3. **암달의 법칙** : [Understanding Amdahl's Law](https://www.splunk.com/en_us/blog/learn/amdahls-law.html)[3]
   - 병렬 처리의 한계와 성능 개선 가능성 계산

## 요약

### 핵심 내용

1. **DRY vs 유연성 트레이드오프**
   - DRY 원칙을 맹목적으로 따르기보다 상황에 맞는 판단 필요
   - 분산 시스템에서는 중복이 더 나은 선택일 수 있음

2. **코드 공유 방법론 비교**
   - **중복 허용**: 팀 독립성 보장, 빠른 개발 속도
   - **공유 라이브러리**: 코드 재사용, 의존성 관리 복잡성
   - **마이크로서비스**: 독립 배포, 높은 운영 복잡도

3. **선택 기준**
   - 로직의 복잡도
   - 팀 간 조정 비용
   - 성능 요구사항
   - 운영 복잡도 수용 가능성

### 실무 적용 가이드

| 상황 | 권장 접근법 | 이유 |
|------|------------|------|
| 단순한 유틸리티 로직 | 공유 라이브러리 | 낮은 변경 빈도, 재사용성 높음 |
| 복잡한 비즈니스 로직 | 마이크로서비스 | 독립적 진화 필요 |
| 초기 개발 단계 | 중복 허용 | 빠른 실험과 검증 |
| 보안 관련 로직 | 공유 라이브러리/서비스 | 일관성과 전문성 필요 |

### 💡 최종 의견
코드 중복은 항상 나쁜 것이 아니다. 특히 분산 시스템에서는 적절한 중복이 시스템의 유연성과 팀의 자율성을 보장할 수 있다. 중요한 것은 각 접근법의 트레이드오프를 이해하고 상황에 맞는 최적의 선택을 하는 것이다.

[1](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/32004849/0d76a881-5369-4015-9ac8-6fe8e6f73230/2504-ipegtibeu-sopeuteuweeo-seolgye-pages-44-61.pdf)
[2](https://dev.to/jeroendedauw/the-fallacy-of-dry)
[3](https://shekhargulati.com/2021/10/20/when-to-use-shared-libraries-in-microservices-architecture/)
[4](http://jeremymikkola.com/posts/2021_01_01_why_software_development_is_hard.html)
[5](https://en.wikipedia.org/wiki/Don't_repeat_yourself)
[6](https://dev.to/thesimdak/shared-library-for-micro-services-why-should-you-have-one-2jod)
[7](https://www.splunk.com/en_us/blog/learn/amdahls-law.html)
[8](https://stackoverflow.com/questions/17788738/is-violation-of-dry-principle-always-bad)
[9](https://www.reddit.com/r/softwarearchitecture/comments/16k76tj/microservice_architecture_shared_lib_vs_dedicated/)
[10](https://deviq.com/laws/amdahls-law/)
[11](https://thevaluable.dev/dry-principle-cost-benefit-example/)
[12](https://stackoverflow.com/questions/57240638/shared-library-vs-microservice)
[13](https://dev.to/luminousmen/understanding-concurrency-through-amdahls-law-1ah4)
[14](https://www.infoq.com/news/2014/09/microservices-shared-libraries/)
[15](https://www.grahamlea.com/2016/04/shared-libraries-in-microservices-bad-advice/)
[16](https://ppl-ai-code-interpreter-files.s3.amazonaws.com/web/direct-files/e24357432d6004bc7d2f4810934ed222/c57e9fc7-f9e0-4e3e-aa5d-ae87796c21a9/fa04ef2f.md)